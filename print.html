<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GAMES103</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The note of GAMES103">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">BackGround</li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 数学基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_math_vector.html"><strong aria-hidden="true">2.1.</strong> Vector</a></li><li class="chapter-item expanded "><a href="2_math_matrix.html"><strong aria-hidden="true">2.2.</strong> Matrix</a></li><li class="chapter-item expanded "><a href="2_math_calculus.html"><strong aria-hidden="true">2.3.</strong> Tensor Calculus</a></li></ol></li><li class="chapter-item expanded "><a href="Graphics.html"><strong aria-hidden="true">3.</strong> 图形学基础</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 仿真的基本单位</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Unit/Particle.html"><strong aria-hidden="true">4.1.</strong> 粒子</a></li><li class="chapter-item expanded "><a href="Unit/Grid.html"><strong aria-hidden="true">4.2.</strong> 格子</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> 粒子与格子的混合</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 刚体 - 粒子以相对位置不变的关系聚合</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rigid/Attribution.html"><strong aria-hidden="true">5.1.</strong> 刚体的属性</a></li><li class="chapter-item expanded "><a href="Rigid/Force.html"><strong aria-hidden="true">5.2.</strong> 刚体动力学</a></li><li class="chapter-item expanded "><a href="Rigid/supplementary.html"><strong aria-hidden="true">5.3.</strong> 补充</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 粒子与刚体组成的系统</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="ParticleRigid/Attribution.html"><strong aria-hidden="true">6.1.</strong> 系统的属性</a></li></ol></li><li class="chapter-item expanded "><a href="4_rigidcontact.html"><strong aria-hidden="true">7.</strong> 刚体系统 - 多个刚体组成的系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4_rigidcontact_Particle.html"><strong aria-hidden="true">7.1.</strong> 粒子的碰撞检测与响应</a></li><li class="chapter-item expanded "><a href="9_collision_detect.html"><strong aria-hidden="true">7.2.</strong> 刚体的碰撞检测 - Broad Phase</a></li><li class="chapter-item expanded "><a href="9_collision_detect_narrow.html"><strong aria-hidden="true">7.3.</strong> 刚体的碰撞检测 - Narrow Phase</a></li><li class="chapter-item expanded "><a href="4_rigidcontact_Rigid.html"><strong aria-hidden="true">7.4.</strong> Energy Based 刚体碰撞响应</a></li><li class="chapter-item expanded "><a href="9_collision_response.html"><strong aria-hidden="true">7.5.</strong> Constrain Based 刚体碰撞响应</a></li><li class="chapter-item expanded "><a href="4_rigidcontact_supplementary.html"><strong aria-hidden="true">7.6.</strong> 补充</a></li><li class="chapter-item expanded "><a href="9_collision_summary.html"><strong aria-hidden="true">7.7.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">弹性体</li><li class="chapter-item expanded "><a href="5_cloth.html"><strong aria-hidden="true">8.</strong> 布料</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_cloth_spring.html"><strong aria-hidden="true">8.1.</strong> Mass Spring System</a></li><li class="chapter-item expanded "><a href="5_cloth_bending_blcoking.html"><strong aria-hidden="true">8.2.</strong> Bending and Locking Issues</a></li></ol></li><li class="chapter-item expanded "><a href="5_cloth_shape_matching.html"><strong aria-hidden="true">9.</strong> Shape Matching</a></li><li class="chapter-item expanded "><a href="6_constraints.html"><strong aria-hidden="true">10.</strong> 约束方法</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_constraints_Projection.html"><strong aria-hidden="true">10.1.</strong> 投影函数 Projection Function</a></li><li class="chapter-item expanded "><a href="6_constraints_PBD.html"><strong aria-hidden="true">10.2.</strong> PBD</a></li><li class="chapter-item expanded "><a href="6_constraints_strain.html"><strong aria-hidden="true">10.3.</strong> Strain Limiting</a></li><li class="chapter-item expanded "><a href="6_constraints_Projective_Dynamics.html"><strong aria-hidden="true">10.4.</strong> 投影动力学 (Projective Dynamics)</a></li><li class="chapter-item expanded "><a href="6_constraints_Contrained_Dynamics.html"><strong aria-hidden="true">10.5.</strong> Contrained Dynamics</a></li><li class="chapter-item expanded "><a href="6_constraints_summary.html"><strong aria-hidden="true">10.6.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="7_FEM.html"><strong aria-hidden="true">11.</strong> 07-FEM</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7_FEM_FEM.html"><strong aria-hidden="true">11.1.</strong> Linear Finite Element Method</a></li><li class="chapter-item expanded "><a href="7_FEM_FVM.html"><strong aria-hidden="true">11.2.</strong> Finite Volume Method</a></li><li class="chapter-item expanded "><a href="7_FEM_Hyperelastic.html"><strong aria-hidden="true">11.3.</strong> Hyperelastic Models</a></li><li class="chapter-item expanded "><a href="7_FEM_summary.html"><strong aria-hidden="true">11.4.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="8_FEM2.html"><strong aria-hidden="true">12.</strong> 08-FEM2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_FEM2_Nonlinear_optimization.html"><strong aria-hidden="true">12.1.</strong> Nonlinear optimization</a></li></ol></li><li class="chapter-item expanded "><a href="9_collision_untangling.html"><strong aria-hidden="true">13.</strong> Untangling Cloth</a></li><li class="chapter-item expanded affix "><li class="part-title">Grid - 整齐排布的格子</li><li class="chapter-item expanded "><a href="Grid.html"><strong aria-hidden="true">14.</strong> Grid</a></li><li class="chapter-item expanded affix "><li class="part-title">水</li><li class="chapter-item expanded "><a href="10_wave.html"><strong aria-hidden="true">15.</strong> 10-wave</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> 高度场模型</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_wave_height_feild.html"><strong aria-hidden="true">16.1.</strong> 高度场模型</a></li><li class="chapter-item expanded "><a href="10_wave_volume.html"><strong aria-hidden="true">16.2.</strong> Volume Preservation</a></li><li class="chapter-item expanded "><a href="10_wave_boundary.html"><strong aria-hidden="true">16.3.</strong> Boundary Conditions</a></li><li class="chapter-item expanded "><a href="10_wave_coupling.html"><strong aria-hidden="true">16.4.</strong> Two-Way Coupling</a></li><li class="chapter-item expanded "><a href="10_wave_summary.html"><strong aria-hidden="true">16.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="11_EulerianFluids.html"><strong aria-hidden="true">17.</strong> 欧拉模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11_EulerianFluids_Grid.html"><strong aria-hidden="true">17.1.</strong> A Grid Representation and Finite Differencing</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Staggered.html"><strong aria-hidden="true">17.2.</strong> Staggered Grid</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Incompressible.html"><strong aria-hidden="true">17.3.</strong> Incompressible, Viscous  Navier-Stokes Equations</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Air_Smoke.html"><strong aria-hidden="true">17.4.</strong> Air and Smoke</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Summary.html"><strong aria-hidden="true">17.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="12_SPH.html"><strong aria-hidden="true">18.</strong> SPH模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="12_SPH_SPH.html"><strong aria-hidden="true">18.1.</strong> A SPH Model</a></li><li class="chapter-item expanded "><a href="12_SPH_Fluids.html"><strong aria-hidden="true">18.2.</strong> SPH-Based Fluids</a></li><li class="chapter-item expanded "><a href="12_SPH_Display.html"><strong aria-hidden="true">18.3.</strong> Fluid Display</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GAMES103</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CaterpillarStudyGroup/GAMES103_mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>本文以GAMES103课程为始，围绕图形学物理仿真话题，根据自己的理解重新排版、增删。如有侵权，请联系删除。</p>
<p>**仿真是指，根据仿真对象在当前时刻的力计算下一时刻仿真对象的状态。**因此本文根据仿真对象来划分章节。对每一种仿真对象（组合），分析</p>
<ol>
<li>属性，包含固有属性和需要仿真的状态</li>
<li>可能受到的力，包含内力和外力</li>
<li>对象在力的作用下如何响应，即更新状态</li>
<li>这种仿真对象的使用场景</li>
</ol>
<blockquote>
<p>✅ 这里涉及到时间步的概念。仿真的帧率不需要与渲染的帧率保持一致。通常一个渲染step会包含多个仿真step。</p>
</blockquote>
<blockquote>
<p>✅ 王老师建议的学习方法：<br />
读 paper 而不是教材<br />
只读重点不读全文<br />
学知识而不是学用 Unity<br />
多读多写多想</p>
</blockquote>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ol>
<li>基于物理的计算机动画入门 <a href="https://www.bilibili.com/video/BV12Q4y1S73g/?spm_id_from=333.337.search-card.all.click">原始课程链接</a></li>
</ol>
<p><img src="./assets/1-16.png" alt="" /></p>
<ol start="2">
<li>
<p>知乎、Deepseek等网络材料</p>
</li>
<li>
<p>图形学相关</p>
</li>
</ol>
<p><a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/index.html">数学基础</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES105_mdbook/">Animation - 角色动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES103_mdbook/">Animation - 物理动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/">Geometry</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/">Rendering</a></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="vector-basics"><a class="header" href="#vector-basics">Vector: Basics</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>An (Euclidean) vector: <em>A geometric entity endowed with magnitude and direction</em>.</p>
<p>$$
\mathbf{P} =\begin{bmatrix}
p_x\\ 
p_y\\ 
p_z\\
\end{bmatrix}\in \mathbf{R} ^3
$$</p>
<p>$$
\mathbf{o} =\begin{bmatrix}
0\\ 
0\\ 
0\\
\end{bmatrix}
$$</p>
<p>The vector <strong>p</strong> is defined with respect to the origin <strong>o</strong>.</p>
<h2 id="坐标系"><a class="header" href="#坐标系">坐标系</a></h2>
<p><img src="./assets/02-02.png" alt="" /></p>
<blockquote>
<p>✅ 用黑来区分，矢量：黑体小写；标量：斜体；矩阵：黑体大写；</p>
</blockquote>
<p>P4</p>
<p>The choice of a right-hand or left-hand system is largely due to:<br />
<strong>the convention of the screen space</strong>.</p>
<p><img src="./assets/02-3.png" alt="" /></p>
<blockquote>
<p>✅ 左手坐标系，E轴正方向朝屏幕内，好处是物体坐标 x、y、z 都是正值。右手系统的物体都在E轴负方向。</p>
</blockquote>
<p>P5</p>
<h2 id="stacked-vector"><a class="header" href="#stacked-vector">Stacked Vector</a></h2>
<p>Vectors can be stacked up to form a high-dimensional vector, commonly used for describing the state of an object.</p>
<p><img src="./assets/02-4-1.png" alt="" /></p>
<p>Not a geometric vector,but a <strong>stacked vector</strong>.</p>
<p>P6</p>
<h1 id="vector-arithematic-addition-and-subtraction"><a class="header" href="#vector-arithematic-addition-and-subtraction">Vector Arithematic: Addition and Subtraction</a></h1>
<p>$$
\mathbf{p\pm q=} \begin{bmatrix}
p_x\pm q_x\\
p_y\pm q_y\\
p_z\pm q_z\\
\end{bmatrix}
$$</p>
<p>$$
\mathbf{p+q=q+p} 
$$</p>
<table><thead><tr><th>Addition is commutative.</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/02-5-1.png" alt="" /></p>
<table><thead><tr><th>Geometric Meanings</th></tr></thead><tbody>
</tbody></table>
<p>P7</p>
<h2 id="example-1-linear-representation"><a class="header" href="#example-1-linear-representation">Example 1: Linear Representation</a></h2>
<p>A (geometric) vector can represent a position, a velocity, a force, or a line/ray/segment.</p>
<p><img src="./assets/02-6-2.png" alt="" /></p>
<p><img src="./assets/02-7-2.png" alt="" /></p>
<blockquote>
<p>✅ 图2。同一个公式，对\(t\)做不同的约束，可以定义不同的东西。<br />
\(\mathbf{P}(t)\) 是 \(\mathbf{P}\) 和 \(\mathbf{q}\) 的 blend </p>
</blockquote>
<p>P8</p>
<h1 id="vector-norm"><a class="header" href="#vector-norm">Vector Norm</a></h1>
<p>A vector norm measures the magnitude of a vector: its length. </p>
<p><img src="./assets/02-8.png" alt="" /></p>
<blockquote>
<p>✅ L1-Norm 又称为曼哈顿的距离。没写下标一般默认L2-Norm</p>
</blockquote>
<p>P9</p>
<h2 id="vector-norm-usage"><a class="header" href="#vector-norm-usage">Vector Norm: Usage</a></h2>
<p>Distance between <strong>q</strong> and <strong>p</strong>：
$$
\mathbf{||q-p||} 
$$</p>
<p>A unit vector：</p>
<p>$$
\mathbf{||p||} =1
$$</p>
<p>Normalization：
$$
\mathbf{\bar{p} =p/||p||} 
$$</p>
<p>P10</p>
<h1 id="vector-arithematic-dot-product"><a class="header" href="#vector-arithematic-dot-product">Vector Arithematic: Dot Product</a></h1>
<p>A dot product, also called inner product, is:</p>
<p><img src="./assets/02-11-1.png" alt="" /> </p>
<table><thead><tr><th>Geometric Meanings</th></tr></thead><tbody>
</tbody></table>
<p>$$
\begin{array}{c} 
\mathbf{p\cdot q}=p_xq_x+p_yq_y+p_zq_z=\mathbf{p^Tq}   \\
=||\mathbf{p} ||||\mathbf{q} ||\cos \theta 
\end{array}
$$</p>
<ul>
<li>\(\mathbf{p\cdot q=q\cdot p} \)</li>
<li>\(\mathbf{p\cdot (q+r)=p\cdot q+p\cdot r} \)</li>
<li>\(\mathbf{p \cdot p = ||p||^2_2} \), a different way to write norm.</li>
<li>If \(\mathbf{p·q} = 0\) and  \(\mathbf{p,q}\ne 0\)  then  \(\cos \theta = 0\),then \(\mathbf{p}\) and \(\mathbf{q}\) are orthogonal.</li>
</ul>
<p>P11</p>
<h2 id="example-2-particle-line-projection"><a class="header" href="#example-2-particle-line-projection">Example 2: Particle-Line Projection</a></h2>
<p><img src="./assets/02-12-2.png" alt="" /></p>
<blockquote>
<p>✅\(X\)为物体中心点的位置，为物体上所有点的整体位移，是前面说的\(T\).<br />
速度是加速度的积分，表示为\(V\)或\(\dot{X} \)<br />
加速度为\(F／M\)，但\(F\)比较复杂，与时间、位置、速度都可能有关系。<br />
位置是速度的积分。</p>
</blockquote>
<p>P12</p>
<h2 id="example-3-plane-representation"><a class="header" href="#example-3-plane-representation">Example 3: Plane Representation</a></h2>
<p><img src="./assets/02-13-1.png" alt="" /></p>
<p><img src="./assets/02-12P.png" alt="" /></p>
<p>S: The <u>signed</u> distance to the plane</p>
<p>Quiz: How to test if a point is within a box?</p>
<p><img src="./assets/02-14-1.png" alt="" /></p>
<p>P13</p>
<h2 id="example-4-particle-sphere-collision"><a class="header" href="#example-4-particle-sphere-collision">Example 4: Particle-Sphere Collision</a></h2>
<p><img src="./assets/02-15.png" alt="" /></p>
<p>If collision does happen, then:</p>
<p>$$
||\mathbf p(t) - \mathbf{c}||^2= r^2
$$</p>
<p>$$
(\mathbf p-\mathbf c+t\mathbf v)·(\mathbf p-\mathbf c +t\mathbf v) =r^2
$$</p>
<p>$$
(\mathbf v·\mathbf v)t^2+2(\mathbf p-\mathbf c)·\mathbf vt+ (\mathbf p-\mathbf c)·(\mathbf p-\mathbf c)-r^2=0
$$</p>
<ul>
<li>Three possiblities:
<ul>
<li>No root、无碰撞</li>
<li>One root、擦边 if \(t &gt; 0\)</li>
<li>Two roots:自碰撞 if \(t &gt; 0 \)</li>
</ul>
</li>
</ul>
<p>P14</p>
<h1 id="vector-arithematic-cross-product"><a class="header" href="#vector-arithematic-cross-product">Vector Arithematic: Cross Product</a></h1>
<p><img src="./assets/02-17.png" alt="" /></p>
<p>The result of a cross product is a vector:</p>
<p>$$
\mathbf{r=p\times q} =\begin{bmatrix}
p_yq_z-p_zq_y \\
p_zq_x-p_xq_z\\
p_xq_y-p_yq_x\\
\end{bmatrix}
$$</p>
<ul>
<li>\(\mathbf r·\mathbf p = 0; \mathbf r·\mathbf q = 0; ||\mathbf r|| = ||\mathbf p||||\mathbf q||   \sin \theta\)</li>
<li>\(\mathbf p\times \mathbf q =-\mathbf q\times \mathbf p\)</li>
<li>\(\mathbf p\times (\mathbf q +\mathbf r) = \mathbf p\times \mathbf q +\mathbf p\times \mathbf r\)</li>
<li>If \( \mathbf p \times  \mathbf q =\mathbf 0\) and \(\mathbf p,\mathbf q\ne 0 \) then \(\sin \theta= 0\), then \(\mathbf p\) and \(\mathbf q \) are parallel (in the same or opposite direction).</li>
</ul>
<p>P15</p>
<h2 id="example-5-triangle-normal-and-area"><a class="header" href="#example-5-triangle-normal-and-area">Example 5: Triangle Normal and Area</a></h2>
<p><img src="./assets/02-18.png" alt="" /></p>
<ul>
<li>Cross product gives both the normal and the area.</li>
<li>The normal depends on the triangle index order, also known as topological order.</li>
</ul>
<p>P16<br />
Quiz: How to test if three points are on the same line (co-linear)?</p>
<p>P17</p>
<h2 id="example-6-triangle-insideoutside-test"><a class="header" href="#example-6-triangle-insideoutside-test">Example 6: Triangle Inside/Outside Test</a></h2>
<p><img src="./assets/02-177.png" alt="" /></p>
<p>P18</p>
<p><img src="./assets/02-21.png" alt="" /></p>
<p><img src="./assets/02-211.png" alt="" /></p>
<p>Otherwise, outside.</p>
<blockquote>
<p>✅ 假设P点在三角形所在平面上<br />
三个点的顺序很重要，不能搞反。</p>
</blockquote>
<p>P19</p>
<h2 id="example-7-barycentric-coordinates"><a class="header" href="#example-7-barycentric-coordinates">Example 7: Barycentric Coordinates</a></h2>
<p><img src="./assets/02-22-1.png" alt="" /></p>
<p>Note that:</p>
<p>$$
\frac{1}{2} \mathbf{(x_0−p)×(x_1−p)\cdot n} =\begin{cases} 
\frac{1}{2}||\mathbf{(x_0−p)×(x_1−p)} ||&amp; \mathrm{inside}  \\<br />
\frac{1}{2}||\mathbf{(x_0−p)×(x_1−p)} || &amp; \mathrm{outside} 
\end{cases} 
$$</p>
<p>Signed areas:</p>
<p>$$
\mathbf{A_2=\frac{1}{2} (x_0−p)×(x_1−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_0=\frac{1}{2} (x_1−p)×(x_2−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_1=\frac{1}{2} (x_2−p)×(x_0−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_0+A_1+A_2=A}
$$</p>
<p>Barycentric weights of <strong>p</strong> :</p>
<p>$$
b_0=A_0/A   \quad  b_1=A_1/A   \quad  b_2=A_2/A 
$$</p>
<p>$$
b_0+b_1+b_2=1
$$</p>
<p>Barycentric Interpolation</p>
<p>$$
\mathbf{p} =b_0\mathbf{x} _0+b_1\mathbf{x} _1+b_2\mathbf{x} _2
$$</p>
<blockquote>
<p>✅ 当 \(\mathbf{p}\) 在三角形外面时，面积为负，但面积总和不变
\(b_0,b_1,b_2\) 为 \(\mathbf{p}\) 在三角形重心坐标系下的坐标 </p>
</blockquote>
<blockquote>
<p>✅ \(\mathbf{p}\) 在三角形外部、重心坐标同样适用，不过权重有负数。</p>
</blockquote>
<p>P20</p>
<h3 id="gouraud-shading"><a class="header" href="#gouraud-shading">Gouraud Shading</a></h3>
<p><img src="./assets/02-23.png" alt="" /></p>
<ul>
<li>
<p>Barycentric weights allows the interior points of a triangle to be interpolated.</p>
</li>
<li>
<p>In a traditional graphics pipeline, pixel colors are calculated at triangle vertices first, and then interpolated within. This is known as <em>Gouraud shading</em>.</p>
</li>
<li>
<p>It is hardware accelerated.</p>
</li>
<li>
<p>It is no longer popular.</p>
</li>
</ul>
<blockquote>
<p>✅ 由于硬件能力提升，已经可以做到逐像素。<br />
shading,不再需要此方法<br />
通常也不是逐像素计算重心坐标，而是扫描线算法<br />
例如要计算某一行，可以 ：<br />
(1) 插值出行起点像素；<br />
(2) 插值出行终点像素；<br />
(3) 起点与终点间批量插值； </p>
</blockquote>
<p>P21</p>
<h2 id="example-9-tetrahedral-volume"><a class="header" href="#example-9-tetrahedral-volume">Example 9: Tetrahedral Volume</a></h2>
<p><img src="./assets/02-24.png" alt="" /></p>
<p>Edge vectors:</p>
<p>$$
\mathbf{X_{10}=X_1-X_0  \quad \quad X_{20}=X_2-X_0   \quad \quad X_{30}=X_3-X_0} 
$$</p>
<p>Base triangle area:</p>
<p>$$
A=\frac{1}{2} ||\mathbf{X} _{10}\times \mathbf{X} _{20}||
$$</p>
<p>Height:<br />
$$
h=\mathbf{x} _{30}\cdot\mathbf{n} =\mathbf{x} _{30}\cdot \frac{\mathbf{x} _{10}\times \mathbf{x} _{20}}{||\mathbf{x} _{10}\times \mathbf{x} _{20}||} 
$$</p>
<p>Volume:</p>
<p>$$
\begin{align*}
V&amp;=\frac{1}{3} ℎA=\frac{1}{6} \mathbf{x} _{30}\cdot \mathbf{x} _{10}\times \mathbf{x} _{20}\\
&amp;=\frac{1}{6}\begin{vmatrix}
\mathbf{x} _1 &amp; \mathbf{x} _2 &amp; \mathbf{x} _3 &amp;\mathbf{x} _0 \\
1&amp; 1 &amp; 1 &amp;1
\end{vmatrix}
\end{align*}
$$</p>
<blockquote>
<p>✅ 四面体<br />
\(h\)是\(\mathbf{x}_{30}\)在 normal 上的投影<br />
行列式是上面叉乘的另一种马法。</p>
</blockquote>
<p>P22</p>
<p>Note that the volume \(V =\frac{1}{3}h\mathit{A} =\frac{1}{6} \mathbf{x} _ {30}\cdot (\mathbf{x} _ {10}\times \mathbf{x}_{20})\) is <strong>signed</strong>.</p>
<p><img src="./assets/02-25.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{x}_{3}\)的后面法线的同方向上，也正四面体，反之为负四面体，四点共面为零体积。</p>
</blockquote>
<p>P23</p>
<h2 id="example-10-barycentric-weights-cont"><a class="header" href="#example-10-barycentric-weights-cont">Example 10: Barycentric Weights (cont.)</a></h2>
<p><img src="./assets/02-26.png" alt="" /></p>
<ul>
<li><strong>p</strong> splits the tetrahedron into four sub-tetrahedra:</li>
</ul>
<p>$$
\begin{matrix}
V_0=\mathrm{Vol} (\mathbf{x}_3,\mathbf{x}_2, \mathbf{x}_1, \mathbf{p} )\\
V_1=\mathrm{Vol} (\mathbf{x}_2,\mathbf{x}_3, \mathbf{x}_0, \mathbf{p} )\\
V_2=\mathrm{Vol} (\mathbf{x}_1,\mathbf{x}_0, \mathbf{x}_3, \mathbf{p} )\\ 
V_3=\mathrm{Vol} (\mathbf{x}_0,\mathbf{x}_1, \mathbf{x}_2, \mathbf{p} )
\end{matrix} 
$$</p>
<ul>
<li>
<p><strong>p</strong> is inside if and only if: \(V_0,V_1,V_2, V_3 &gt; 0\).</p>
</li>
<li>
<p>Barycentric weights:<br />
$$
b_0=V_0/V   \quad   b_1=V_1/V   \quad b_2=V_2/V   \quad   b_3=V_3/V
$$</p>
</li>
</ul>
<p>$$
b_0+b_1+b_2+b_3=1
$$</p>
<p>$$
\mathbf{p} =b_0\mathbf{x} _0+b_1\mathbf{x} _1+b_2\mathbf{x} _2+b_3\mathbf{x} _3
$$</p>
<p>P24</p>
<h2 id="example-11-particle-triangle-intersection"><a class="header" href="#example-11-particle-triangle-intersection">Example 11: Particle-triangle Intersection</a></h2>
<p><img src="./assets/02-27.png" alt="" /></p>
<ul>
<li>First, we find t when the particle hits the plane:</li>
</ul>
<p>$$
(\mathbf{p} (t)−\mathbf{x} _0)\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}=0
$$</p>
<p>$$
(\mathbf{p}-\mathbf{x} _0+t\mathbf{v})\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}=0
$$</p>
<p>$$
t=\frac{(\mathbf{p}−\mathbf{x}_0)\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}}{\mathbf{v}\cdot \mathbf{x} _{10}\times \mathbf{x} _{20}} 
$$</p>
<ul>
<li>We then check if \(\mathbf{p}(t)\) is inside or not.
<ul>
<li>See Example 6.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 代入体积公式，体积为0时发生碰撞</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P26</p>
<h1 id="matrix-basics"><a class="header" href="#matrix-basics">Matrix: Basics</a></h1>
<h2 id="matrix-definition"><a class="header" href="#matrix-definition">Matrix: Definition</a></h2>
<p>A real matrix is a set of real elements arranged in rows and columns.</p>
<p>$$
A=\begin{bmatrix}
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10}&amp; a_{11} &amp; a_{12} \\
a_{20}&amp; a_{21} &amp; a_{22}
\end{bmatrix}=[a_{0} \quad a_{1} \quad  a_{2}]\in \mathbf{R}   ^{3\times 3}
$$</p>
<p><img src="./assets/02-29.png" alt="" /></p>
<p>$$
\mathbf{A^T=A}    \quad  \mathrm{Symmetric} 
$$</p>
<p>P27</p>
<h2 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix: Multiplication</a></h2>
<p>How to do matrix-vector and matrix-matrix multiplication? (Omitted)</p>
<ul>
<li>\(\mathbf{AB≠BA} 	 \quad \quad \quad \quad  	\quad  \quad \quad \quad \mathbf{(AB)x=A(Bx)} \)</li>
<li>\(\mathbf{(AB)^T=B^TA^T}	 \quad \quad	\quad \quad \quad \quad \mathbf{(A^TA)^T=A^TA}\)</li>
<li>\(\mathbf{Ix=x}		 \quad 	\quad \quad   \quad \quad \quad \quad \quad \quad \mathbf{AI=IA=A}\)<br />
\(\quad\)</li>
<li>\(\mathbf{A^{−1}:  AA^{−1}=A^{−1}A=I}	 \quad \quad \mathrm{inverse}\)</li>
<li>\(\mathbf{(AB)^{−1}=B^{−1}A^{−1}}\)</li>
<li>Not every matrix is invertible, e.g., \(\mathbf{A} =\begin{bmatrix}
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0
\end{bmatrix}\)</li>
</ul>
<p>P28</p>
<h2 id="matrix-orthogonality"><a class="header" href="#matrix-orthogonality">Matrix: Orthogonality</a></h2>
<p>An orthogonal matrix is a matrix made of orthogonal <strong>unit</strong> vectors. </p>
<p>$$
\mathbf{A} =[\mathbf{a} _0\quad \mathbf{a} _1\quad \mathbf{a} _2]\quad\mathrm{such \quad that
} \quad \mathbf{a}_i^\mathbf{T}\mathbf{a}_j =\begin{cases}
1，&amp; \text{ if } i= j \text{(unit)}\\
0.&amp; \text{ if } i\ne j \text{(orthogonal)}
\end{cases}
$$</p>
<p>$$
\mathbf{A^TA}=\begin{bmatrix}
\mathbf{a}_0^\mathbf{T} \\
\mathbf{a}_1^\mathbf{T} \\
\mathbf{a}_2^\mathbf{T}
\end{bmatrix}\begin{bmatrix}
\mathbf{a}_0 &amp; \mathbf{a}_1 &amp;\mathbf{a}_2
\end{bmatrix}=\begin{bmatrix}
\mathbf{a}_0^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_0^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_0^\mathbf{T} \mathbf{a}_2\\
\mathbf{a}_1^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_1^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_1^\mathbf{T} \mathbf{a}_2\\
\mathbf{a}_2^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_2^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_2^\mathbf{T} \mathbf{a}_2
\end{bmatrix}=I
$$</p>
<p>$$
\mathbf{A^T=A^{-1}}
$$</p>
<p>P29</p>
<h2 id="matrix-transformation"><a class="header" href="#matrix-transformation">Matrix Transformation</a></h2>
<p>A rotation can be represented by an orthogonal matrix.</p>
<p><img src="./assets/02-30.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{x、y、z}\) 是世界坐标系、 \(\mathbf{u、v、w}\) 是局部坐标系，<strong>旋转矩阵是局部坐标系在世界坐标系中的状态的描述</strong>。 </p>
</blockquote>
<p>P30<br />
A scaling can be represented by a diagonal matrix.</p>
<p><img src="./assets/02-31.png" alt="" /></p>
<p>P31</p>
<h1 id="矩阵分解"><a class="header" href="#矩阵分解">矩阵分解</a></h1>
<h2 id="singular-value-decomposition"><a class="header" href="#singular-value-decomposition">Singular Value Decomposition</a></h2>
<p>A matrix can be decomposed into:<br />
\(\mathbf{A=UDV^T} \quad\)such that \(\mathbf {D}\) is diagonal,and \(\mathbf {U}\) and \(\mathbf {V}\) are orthogonal.<br />
\(\quad \quad \quad  \quad\quad\) D 的对角线元素是<strong>singular values（奇异值）</strong></p>
<p>Any <strong>linear deformation</strong> can be decomposed into three steps: rotation, scaling and rotation:</p>
<p><img src="./assets/02-32.png" alt="" /></p>
<blockquote>
<p>✅ rotation \(\longrightarrow\) scaling \(\longrightarrow\) rotation 分别对应 \(\mathbf{V}_2^\mathbf{T},\mathbf{D}, \mathbf{U}\). 注意顺序！！！<br />
所有 \(\mathbf{A}\) 都能做 \(\mathbf{SVD} \)</p>
</blockquote>
<p>P32</p>
<h2 id="eigenvalue-decomposition"><a class="header" href="#eigenvalue-decomposition">Eigenvalue Decomposition</a></h2>
<p>A <strong>symmetric</strong> matrix can be decomposed into:<br />
\(\mathbf{A=UDU^{-1}}\quad\)such that \(\mathbf {D}\) is diagonal,and \(\mathbf {U}\) is orthogonal.<br />
\(\quad \quad \quad  \quad\quad\) D 的对角线元素是<strong>eigenvalues（特征值）</strong></p>
<blockquote>
<p>✅ \(\mathbf{ED}\) 看作是\(\mathbf{SVD}\)的特例，仅应用于对称矩阵，此时 \(\mathbf{U=V}\)<br />
\(\mathbf{U}\) 是正交矩阵，因此也可写成 \(\mathbf{A = UVU^T}\)</p>
</blockquote>
<blockquote>
<p><strong>As in the textbook</strong><br />
Let \(\mathbf{U} =\begin{bmatrix}
\cdots  &amp; \mathbf{u} _i &amp;\cdots
\end{bmatrix}\), we have:<br />
$$
\mathbf{Au} _i= \mathbf{UDU^T} \mathbf{u} _i=\mathbf{UD} \begin{bmatrix}
\vdots \\
0\\
1\\
0\\
\vdots 
\end{bmatrix}=\mathbf{U} \begin{bmatrix}
\vdots \\
0\\
d_i\\
0\\
\vdots 
\end{bmatrix}=d_i\mathbf{u} _i
$$
\(\mathbf{U}\): 是 the eigenvector of \(d_i\)<br />
\(d_i\): 是 eigenualue</p>
</blockquote>
<p>We can apply eigenvalue decomposition to <u>asymmetric</u> matrices too, if we allow eigenvalues and eigenvectors to be <strong>complex</strong>. <strong>Not considered here</strong>.</p>
<blockquote>
<p>✅ complex：复数<br />
图形学不考虑虚数，因此也不考虑非对称矩阵的 \(\mathbf{ED}\)</p>
</blockquote>
<p>P33</p>
<h2 id="symmetric-positive-definiteness-spd"><a class="header" href="#symmetric-positive-definiteness-spd">Symmetric Positive Definiteness (s.p.d.)</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<p>\(\mathbf{A}\)  is s.p.d. if only if: 		\(\quad\quad\quad\quad\quad\quad\quad\quad	\)	\(\mathbf{v^TAv}&gt;0\), for any \(\mathbf{v} ≠ 0. \)</p>
<p>\(\mathbf{A}\) is symmetric semi-definite if only if: 	\(\quad\quad	\)	\(\mathbf{v^TAv}≥0\), for any \(\mathbf{v}≠ 0\). </p>
<blockquote>
<p>✅ 计算矩阵的有限元或 Hession 时会用到正定性</p>
</blockquote>
<table><thead><tr><th align="left">What does this even mean???</th></tr></thead><tbody>
</tbody></table>
<h3 id="怎么理解spd"><a class="header" href="#怎么理解spd">怎么理解SPD</a></h3>
<p>\(d&gt;0   \quad\quad\quad\quad\Leftrightarrow \quad  \mathbf{v^T} d\mathbf{v} &gt;0\), for any \(\mathbf{v} ≠ 0. \)</p>
<p>\(d_0, d_1,…&gt;0     \quad\Leftrightarrow \quad     \mathbf{v^TDv=v^T} \begin{bmatrix}
\ddots  &amp; \Box  &amp; \Box\\
\Box  &amp; d_i &amp; \Box\\
\Box  &amp;\Box  &amp;\ddots 
\end{bmatrix}\mathbf{v} &gt;0\), for any \(\mathbf{v} ≠0.\)</p>
<blockquote>
<p>✅ 一堆大于零的实数组成一个对角矩阵, 公式1的扩展</p>
</blockquote>
<p>\(d_0, d_1,…&gt;0    \quad\Leftrightarrow \quad     \mathbf{v^T(UDU^T)v=v^TUU^T(UDU^T)UU^Tv}\)</p>
<p>\(\mathbf{U}\) <strong>orthogonal</strong> \(\quad\quad\quad\quad\quad\quad\quad\quad=\mathbf{(U^Tv)^T(D)(U^Tv)&gt;0 } \), for any \(\mathbf{v} ≠0 \)</p>
<blockquote>
<p>✅ 公式3是公式2的扩展</p>
</blockquote>
<p>P34</p>
<h3 id="怎么判断spd"><a class="header" href="#怎么判断spd">怎么判断SPD</a></h3>
<ul>
<li>
<p><strong>A</strong> is s.p.d. if only if all of its eigenvalues are positive:<br />
\(\mathbf{A=UDU^T}\)  and \(d_o,d_1,\cdots &gt; 0.\)</p>
</li>
<li>
<p>But eigenvalue decomposition is a stupid idea most of the time, since it takes lotsof time to compute.</p>
</li>
</ul>
<blockquote>
<p>✅ 实际上不会通过 \(\mathbf{ED}\) 来判断矩阵的正定性。因为ED的计算量很大。</p>
</blockquote>
<ul>
<li>In practice, people often choose other ways to check  if <strong>A</strong> is sp.d. For example,</li>
</ul>
<blockquote>
<p>\(a_{ii}&gt;∑_{i≠j}|a_{ij}|\) for all \(i\)<br />
A diagonally dominant matrix is p.d.</p>
</blockquote>
<p>$$
\begin{bmatrix}
4&amp;3  &amp; 0\\
-1&amp; 5 &amp;3 \\
-8&amp; 0 &amp;9
\end{bmatrix}\begin{matrix}\quad\quad
\quad4&gt;3+0\\
\quad\quad\quad 5&gt;1+3 \\
\quad\quad9&gt;8
\end{matrix}
$$</p>
<blockquote>
<p>✅ 对角占优矩阵必定正定，正定不一定对角占优</p>
</blockquote>
<ul>
<li>Finally, a s.p.d.matrix must be invertible:<br />
$$
\mathbf{A^{-1} =(U^T)^{-1}D^{-1}U^{-1} = UD^{-1}U^T}.
$$</li>
</ul>
<p>P35</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>Prove that if <strong>A</strong> is s.p.d., then \(\mathbf{B} =\begin{bmatrix}
\mathbf{A} &amp;\mathbf{-A} \\
\mathbf{-A}  &amp;\mathbf{A}
\end{bmatrix}\)is symmetric semi-definite.</p>
<p>For any \( \mathbf{x}\) and \(\mathbf{y}\), we know:</p>
<p>$$
\begin{bmatrix}
\mathbf{ x^T}&amp;\mathbf{ y^T}
\end{bmatrix}\mathbf{B}\begin{bmatrix}
\mathbf{x} \\
\mathbf{y}
\end{bmatrix}=\begin{bmatrix}
\mathbf{ x^T}&amp;\mathbf{ y^T}
\end{bmatrix}\begin{bmatrix}
\mathbf{A} &amp;\mathbf{-A} \\
\mathbf{-A}  &amp;\mathbf{A}
\end{bmatrix}\begin{bmatrix}
\mathbf{x} \\
\mathbf{y}
\end{bmatrix}
$$</p>
<p>$$
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\mathbf{=x^TA(x-y)-y^TA(x-y)=(x-y)^TA(x-y)} 
$$</p>
<p>Since <strong>A</strong> is sp.d., we must have:</p>
<p>$$
\begin{bmatrix}
\mathbf{ x^T} &amp; \mathbf{y^T} 
\end{bmatrix}\mathbf{B} \begin{bmatrix}
\mathbf{x} \\
\mathbf{y} 
\end{bmatrix}\ge 0
$$</p>
<p>P36</p>
<h1 id="linear-solver"><a class="header" href="#linear-solver">Linear Solver</a></h1>
<p>Many numerical problems are ended up with solving a linear system:</p>
<p><img src="./assets/02-32-1.png" alt="" /></p>
<p>It's expensive to compute \(\mathbf{A^{-1}} \), especially if \(\mathbf{A} \) is large and sparse. So we cannot simply do:\(\mathbf{x = A^{-1}b}\).</p>
<p>There are two popular linear solver approaches: direct and iterative.</p>
<blockquote>
<p>✅ 当 \(\mathbf{A}\) 是稀疏时. \(\mathbf{A}^{-1}\)通常不是稀疏。 如果 \(\mathbf{A}\) 很大，
\(\mathbf{A}^{-1}\)会占用大量空间</p>
</blockquote>
<p>P37</p>
<h2 id="direct-linear-solver"><a class="header" href="#direct-linear-solver">Direct Linear Solver</a></h2>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<p>A direct solver is typically based LU factorization, or its variant: Cholesky, \(\mathrm{LDL^\top } \), etc…</p>
<blockquote>
<p>✅ \(\mathbf{LU}\) 可用于非对称矩阵。<br />
Cholesky 和 \( \mathbf{LDL^\top}\) 仅用于对称矩阵，但内存消耗更少。<br />
这里不介绍如何做\(\mathbf{LU}\)分解</p>
</blockquote>
<p>$$
\mathbf{A=LU=} \begin{bmatrix}
l_{00} &amp; \Box  &amp; \Box \\
l_{10} &amp;  l_{11} &amp; \Box \\
\vdots &amp; \cdots  &amp;\ddots 
\end{bmatrix}\begin{bmatrix}
\ddots  &amp; \cdots  &amp;\vdots  \\
\Box&amp;u_{n−1,n−1}  &amp;u_{n−1,n} \\
\Box &amp; \Box &amp;u_{n,n}
\end{bmatrix}
$$
\(\quad\quad\quad\quad\quad\quad\quad\)lower triangular   \(\quad\quad\) upper triangular</p>
<p><img src="./assets/02-33-1.png" alt="" /></p>
<p><img src="./assets/02-34-1.png" alt="" /></p>
<p>P38</p>
<h3 id="分析"><a class="header" href="#分析">分析</a></h3>
<ul>
<li>When \(\mathbf{A}\)  is sparse, \(\mathbf{L}\) and \(\mathbf{U}\) are not so sparse. Their sparsity depends on the permutation.(See matlab)</li>
</ul>
<blockquote>
<p>✅ \(\mathbf{L}、\mathbf{U}\) 和稀疏性与行列顺序有关，因此通常在\(\mathbf{LU}\) 分解之前做 permutation,使得到比较好的顺序。</p>
</blockquote>
<ul>
<li>lt contains two steps: factorization and solving. lf we must solve many linear systems with the same \(\mathbf{A}\) , we can factorize it only once.</li>
</ul>
<blockquote>
<p>✅ \(\mathbf{LU}\) 分解是计算量的大头，只做一次 \(\mathbf{LU}\) 分解，能省去大量计算。 </p>
</blockquote>
<ul>
<li>Cannot be easily parallelized:Intel MKL PARDISO</li>
</ul>
<p>P39</p>
<h2 id="iterative-linear-solver"><a class="header" href="#iterative-linear-solver">Iterative Linear Solver</a></h2>
<p>An iterative solver has the form:</p>
<p><img src="./assets/02-355.png" alt="" /></p>
<p>Why does it work?</p>
<p>$$
\begin{matrix}
\mathbf{b−Ax} ^{[k+1]} =\mathbf{b−Ax} ^{[k]}−\mathbf{αAM} ^{−1}(\mathbf{b−Ax} ^{[k]}) \\
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad=(\mathbf{I−αAM} ^{−1})(\mathbf{b−Ax} ^{[k]}) =(\mathbf{I−αAM} ^{−1})^{k+1}(\mathbf{b−Ax} ^ {[0]})
\end{matrix}
$$</p>
<p>So,</p>
<p>\(\mathbf{b−Ax} ^{[k+1]}→0\), if \(ρ(\mathbf{I−αAM} ^{−1})&lt;1.\)</p>
<blockquote>
<p>✅\(\mathbf{b-Ax}^{[k＋1]}\) 代表下一时的残差，迭代要想收敛，\(\mathbf{b-Ax}^{[k+1]}\) 应趋于0</p>
</blockquote>
<p>\(\rho\):矩阵的spectral radius (the largest absolute value of the eigenvalues)</p>
<blockquote>
<p>✅ 不会真的去算 \(\rho\),而是调\(α\),试错。 因为求特征值的代价比较大</p>
</blockquote>
<p>P40<br />
\(\mathbf{M}\) must be easier to solve:</p>
<table><thead><tr><th>\(\mathbf{M} =\mathrm{diag} (\mathbf{A} )\)  <br> Jacobi Method</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\mathbf{M} =\mathrm{lower} (\mathbf{A} )\) <br>Gauss-Seidel Method</th></tr></thead><tbody>
</tbody></table>
<p>The convergence can be accelerated: Chebyshev, Conjugate Gradient, … (Omitted here.)</p>
<p>优点：</p>
<ul>
<li>simple</li>
<li>fast for inexact solution</li>
<li>paralleable</li>
</ul>
<p>缺点：</p>
<ul>
<li>convergence condition</li>
</ul>
<blockquote>
<p>✅ 例如要求M是正定的或对角占优的</p>
</blockquote>
<ul>
<li>slow for exact solution</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P42</p>
<h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<h2 id="1st-order-derivatives"><a class="header" href="#1st-order-derivatives">1st-Order Derivatives</a></h2>
<h3 id="值是实数变量是矢量"><a class="header" href="#值是实数变量是矢量">值是实数，变量是矢量</a></h3>
<p>If  \(f(\mathbf{x} )\in \mathbf{R} \), then \(df=\frac{∂f}{∂x}dx+\frac{∂f}{∂y}dy+\frac{∂f}{∂z}dz=\begin{bmatrix}
\frac{∂f}{∂x} &amp; \frac{∂f}{∂y} &amp;\frac{∂f}{∂z}
\end{bmatrix}\begin{bmatrix}
dx \\
dy\\
dz
\end{bmatrix}\).</p>
<p>$$
\frac{∂f}{∂x}=\begin{bmatrix}
\frac{∂f}{∂x} &amp; \frac{∂f}{∂y} &amp;\frac{∂f}{∂z}
\end{bmatrix}<br />
$$</p>
<p>$$
\mathrm{ or  }
$$</p>
<table><thead><tr><th>\(\nabla f(\mathbf{x} )=\begin{bmatrix}\frac{∂f}{∂x} \\ \frac{∂f}{∂y}\\\frac{∂f}{∂z}\end{bmatrix}\) <br>  gradient</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ \(\nabla f(x)=(\frac{\partial f}{\partial x} )^T\), 重要！！！</p>
</blockquote>
<p><img src="./assets/02-42.png" alt="" /></p>
<p>Gradient is the steepest direction for increasing  \(f\). It’s perpendicular to the isosurface.</p>
<blockquote>
<p>✅ isosurface：等高面</p>
</blockquote>
<p>P43</p>
<h3 id="值是矢量变量是是矢量"><a class="header" href="#值是矢量变量是是矢量">值是矢量，变量是是矢量</a></h3>
<p>If \(f(\mathbf{x} )=\begin{bmatrix}
f(\mathbf{x} ) \\
g(\mathbf{x} )\\
h(\mathbf{x} )
\end{bmatrix}\in \mathbf{R} ^3\),then:</p>
<p><img src="./assets/02-43.png" alt="" /></p>
<blockquote>
<p>✅ Divergence:散度，也是\(\mathbf{J}(\mathbf{x})\)的 trace<br />
✅ Curl：旋度。<br />
怎么理解 curl?把微分算子\(\nabla \)看作是个向量，让它与 \(\mathbf{f}\) 做叉乘、在流体模拟中常用。 </p>
</blockquote>
<p>P44</p>
<h2 id="2nd-order-derivatives"><a class="header" href="#2nd-order-derivatives">2nd-Order Derivatives</a></h2>
<p>If \(f\mathbf{(x)\in R} \),then:</p>
<p><img src="./assets/02-44.png" alt="" /></p>
<blockquote>
<p>✅ 求导顺序不影响求导结果，因此 \(\mathbf{H}\) 是对称的<br />
\(\mathbf{H}\)的trace称为Laplace</p>
</blockquote>
<h1 id="泰勒展开"><a class="header" href="#泰勒展开">泰勒展开</a></h1>
<p>①\(x\in R,f(x)\in R\)<br />
$$
f(x)=f(x_0)+{f}' (x_0)(x-x_0)+\frac{1}{2} {f}'' (x_0)(x-x_0)^2+\cdots 
$$</p>
<p>②\(x\in R^n,f(x)\in R\)</p>
<p>$$
f(x)=f(x_0)+\rhd {f}' (x_0)\cdot (x-x_0)+\frac{1}{2}(x-x_0)^TH(x-x_0)+\cdots 
$$</p>
<blockquote>
<p>✅ 当\(\mathbf{H}\)正定时, \(f(\mathbf{x})\)满足一些特殊的性质</p>
</blockquote>
<p>P45</p>
<h2 id="quiz"><a class="header" href="#quiz">Quiz:</a></h2>
<p>\(\frac{∂||\mathbf{x}||}{∂\mathbf{x}} = ?\)</p>
<p>$$
\frac{∂||\mathbf{x}||}{∂\mathbf{x}  } =  \frac{∂(\mathbf{\mathbf{x^Tx} } )^{1/2}}{∂\mathbf{x} }=\frac{1}{2}(\mathbf{x^{T}x} )^{−1/2}
\frac{∂(\mathbf{x^Tx}  )}{∂\mathbf{x} }=\frac{1}{2||\mathbf{x} ||}2\mathbf{x^T} =\frac{\mathbf{x^T} }{||\mathbf{x} ||}
$$</p>
<table><thead><tr><th>$$\frac{∂(\mathbf{\mathbf{x^Tx} } )}{∂\mathbf{x} }=\frac{∂(x^2+y^2+z^2)}{∂\mathbf{x} }= \begin{bmatrix}2x&amp; 2y &amp;2z \end{bmatrix}= 2\mathbf{x^T}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 向量梯度的物理意义：向量沿什么方向变化能最快地变短/长？答：沿它自己的当前方向。</p>
</blockquote>
<p>P46</p>
<h1 id="spring-example"><a class="header" href="#spring-example">Spring Example</a></h1>
<h2 id="a-spring"><a class="header" href="#a-spring">A Spring</a></h2>
<p><img src="./assets/02-46.png" alt="" /></p>
<blockquote>
<p>🔍 Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH)</p>
</blockquote>
<blockquote>
<p>✅ Energy：物理上的弹性势能<br />
Force：物理上的力，是 Energy 的 gradient 的反方向;<br />
公式后面有个 T,来源于前面的\(\nabla \)，<br />
直观解释，前面是力的大小，后面是力的方向，推荐论文为以\(\bot\)公式推导的详细过程</p>
</blockquote>
<p>P47</p>
<h2 id="a-spring-with-two-ends"><a class="header" href="#a-spring-with-two-ends">A Spring with Two Ends</a></h2>
<p><img src="./assets/02-47-1.png" alt="" /></p>
<blockquote>
<p>✅ \(\nabla_0\) 代表对\(\mathbf{x}_0\)的求导</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-pipeline"><a class="header" href="#graphics-pipeline">Graphics Pipeline</a></h1>
<p><a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/index.html">数学基础</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES105_mdbook/">Animation - 角色动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES103_mdbook/">Animation - 物理动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/">Geometry</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/">Rendering</a></p>
<h2 id="real-time-graphics-pipeline"><a class="header" href="#real-time-graphics-pipeline">Real-Time Graphics Pipeline</a></h2>
<p><img src="./assets/01-1-1.png" alt="" /></p>
<p>P15<br />
The number of frames sent to display in a second is called the <em>frame rate</em>.<br />
For example, 24 FPS, 30 FPS, 60 FPS, …</p>
<blockquote>
<p>✅ 帧率要求主要取决于交互性，因此游戏要求比电­影高。</p>
</blockquote>
<p>P17</p>
<h2 id="animation-playback"><a class="header" href="#animation-playback">Animation Playback</a></h2>
<p><img src="./assets/01-1.png" alt="" /> </p>
<blockquote>
<p>✅ 由于实时比较难，可以把不需要交互的动画，例如过场动画做成离线<br />
✅ 同理，不需要交互的场景。 </p>
</blockquote>
<p>P18</p>
<h2 id="movie"><a class="header" href="#movie">Movie</a></h2>
<blockquote>
<p>✅ Geometry: 离线：构造离线的3D也界<br />
✅ 动画：渲染，实时，需要与3D世界或玩家互动<br />
✅ 电影：离线，不需要交互，提前录下来，例如游戏中的过场动画</p>
</blockquote>
<p><img src="./assets/01-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="粒子的属性"><a class="header" href="#粒子的属性">粒子的属性</a></h1>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>全局位置</td><td>p或x</td><td>是</td></tr>
</tbody></table>
<p>在可变的仿真属性中，通常还会考虑它们的一阶导、二阶导等。</p>
<table><thead><tr><th>属性</th><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td>速度</td><td>v或\(\mathbf{\dot{x}} \)</td><td>p的一阶导</td></tr>
<tr><td>加速度</td><td>a</td><td>p的二阶导</td></tr>
</tbody></table>
<p>更新仿真对象的可变属性。</p>
<h1 id="粒子受到的力"><a class="header" href="#粒子受到的力">粒子受到的力</a></h1>
<p>对于单个粒子的场景，粒子有可能会受到推力、重力、阻力等。</p>
<ul>
<li>重力：</li>
</ul>
<p>F = mg</p>
<p>g：重力加速度</p>
<ul>
<li>阻力</li>
</ul>
<blockquote>
<p>✅ 在做模拟时，如果不要求能量守衡，出于问题简化的目的，直接对速度做衰减，代替引入阻力</p>
</blockquote>
<p>$$
v^{[1]} = \alpha v^{[2]}
$$</p>
<ul>
<li>其它力</li>
</ul>
<p>前面提到的力中，重力是与速度、位置无关的力。阻力是只与速度有关的力。但也有些其它力与粒子的位置有关。例如电磁力。因此使用更通用的形式来描述力：</p>
<p>$$
F = \mathbf{f} (\mathbf{x} (t), \mathbf{v} (t), t)
$$</p>
<h1 id="粒子的仿真"><a class="header" href="#粒子的仿真">粒子的仿真</a></h1>
<p>当粒子同时受到多个力时，通过相加得到它们的合力。<br />
粒子在各种力的作用下会发生位移（transform）。其p, v, a都会发生改变。</p>
<h2 id="连续形式"><a class="header" href="#连续形式">连续形式</a></h2>
<p>真实的物理世界里，属性的变化是连续的。</p>
<p>$$
\begin{cases}
\mathbf{v} (t^{[1]})=\mathbf{v} (t^{[0]})+ m^{−1}\int_{t^{[0]}}^{t^{[1]}} \mathbf{f} (\mathbf{x} (t), \mathbf{v} (t), t)dt\\
\mathbf{x} (t^{[1]})=\mathbf{x} (t^{[0]})+\int_{t^{[0]}}^{t^{[1]}} \mathbf{v} (t)dt
\end{cases}
$$</p>
<blockquote>
<p>✅ 速度是加速度的积分，因此\( \Delta v=\int a=\int \frac{F}{M} =m^{-1}\int F\).<br />
✅ 位置是速度的积分，公式的本质上是解积分。</p>
</blockquote>
<h2 id="离散形式"><a class="header" href="#离散形式">离散形式</a></h2>
<blockquote>
<p>💡 为了方便计算机进行计算，需要把连续积分形式转为离散积分形式。
数值积分相关内容请戳这里：<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/NumericalAnalysis/NumericalIntegration.html">link</a>。最后结论是混合式的积分方法。
<img src="Unit/../assets/03-11.png" alt="" /></p>
</blockquote>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><img src="Unit/../assets/03-14.png" alt="" /></p>
<p><img src="Unit/../assets/03-15.png" alt="" /></p>
<blockquote>
<p>✅ 质量 \(M\) 是一个标量</p>
</blockquote>
<h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<p>实际应用场景中对单个粒子进行仿真没有意义。<br />
可以通过不同的方式把粒子组合成系统再进行复杂场景的仿真。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="grid"><a class="header" href="#grid">Grid</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="刚体的属性"><a class="header" href="#刚体的属性">刚体的属性</a></h1>
<p>无数的粒子以相对位置关系不变的方式聚合到一起，就形成了刚体。<br />
刚体的特点是物体很硬，不考虑形变。</p>
<p>刚体所占的是一个连续的空间，包含了无限多个粒子。实际上会把它离散化为有限个相对位置关系不变的粒子的组合。离散化的方式有两种：</p>
<ol>
<li>仅用极少量的例子来表示刚体的外部轮廓。粒子之间用line连接，构成Mesh。用这种方式构造出的刚体不考虑与粒子之间的相互作用力。是最常见的方式。</li>
<li>用稠密的粒子点云来表示刚体所占据的空间。这种方式可以考虑粒子间的相互作用力，因此可以模拟刚体破碎的效果。</li>
</ol>
<h2 id="子系统粒子的属性"><a class="header" href="#子系统粒子的属性">子系统（粒子）的属性</a></h2>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>相对位置(质心的坐标系)</td><td>p或x</td><td>否。虽然每个粒子都有位置属性，但它们所有的粒子相对位移不变，因此不需要独立对每个粒子的位置属性做仿真，只需要仿真其中一个粒子的位置就可以。其它粒子的位置都是相对它的偏移</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>\(x_i\)</td><td>是。粒子的位置变化是由于质心坐标的平移和旋转导致的，是被动变化的，因此不直接仿真每个粒子的全局位置。</td></tr>
<tr><td>sv</td><td></td><td></td></tr>
</tbody></table>
<h2 id="组合系统刚体的属性"><a class="header" href="#组合系统刚体的属性">组合系统（刚体）的属性</a></h2>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m（均质）或M（非均质）</td><td>否。刚体的质量为其所有粒子的质量之和。</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>p或x</td><td>是。刚体所占的是一个连续的空间，而不是一个点。选择刚体中的某一个点（通常是质心）的位置作为刚体的位置</td></tr>
<tr><td>全局旋转（世界坐标系）</td><td>q <br> 旋转的表示戳这里<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/Geometry/Quaternion.html">link</a>。最后结论是四元数表示方法。</td><td>是</td></tr>
</tbody></table>
<p><img src="Rigid/../assets/03-2.png" alt="" /></p>
<blockquote>
<p>✅ reference：参考状态,无平移,无旋转，假设刚体在reference状态的坐标系与世界坐标系是一致的。<br />
当前状态：旋转为\(\mathbf{R}\)，平移为\(\mathbf{T}\). 那么物体上任意点的位置为：<br />
$$
\mathbf{{x}}' = \mathbf{Rx} + \mathbf{T}
$$</p>
</blockquote>
<p>对应的：</p>
<table><thead><tr><th>属性</th><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td>速度</td><td>v或\(\mathbf{\dot{x}} \)</td><td>p的一阶导</td></tr>
<tr><td>加速度</td><td>a</td><td>p的二阶导</td></tr>
<tr><td>角速度</td><td>v或\(\mathbf{\dot{x}} \)</td><td>q的一阶导</td></tr>
<tr><td>角加速度</td><td>a</td><td>q的二阶导</td></tr>
</tbody></table>
<p>We use a 3D vector \(\mathbf{\omega}\) to denote angular velocity.</p>
<p>$$ 
\begin{cases} \text{The direction of } \mathbf{\omega} \text{ is the axis.} \\<br />
\text{The magnitude of }  \mathbf{\omega} \text{ is the speed.}<br />
\end{cases}
$$ </p>
<p><img src="Rigid/./assets/03-21.png" alt="" /></p>
<h2 id="子系统聚合后产生的新属性"><a class="header" href="#子系统聚合后产生的新属性">子系统聚合后产生的新属性</a></h2>
<table><thead><tr><th>属性</th><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td>占据哪些空间</td><td></td><td>刚体所占的是一个连续的空间，因此有体积的概念。</td></tr>
</tbody></table>
<h1 id="应用场景-1"><a class="header" href="#应用场景-1">应用场景</a></h1>
<p>单个物体的仿真，且物体材质很硬，不考虑形变。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="刚体受到的力"><a class="header" href="#刚体受到的力">刚体受到的力</a></h1>
<h2 id="子系统的相互作用"><a class="header" href="#子系统的相互作用">子系统的相互作用</a></h2>
<p>刚体内的粒子间无相互作用</p>
<h2 id="刚体受到的外界的力"><a class="header" href="#刚体受到的外界的力">刚体受到的外界的力</a></h2>
<p>对于单个刚体的场景，刚体有可能会受到的力与单个粒子场景一致的。</p>
<h1 id="刚体对力的响应"><a class="header" href="#刚体对力的响应">刚体对力的响应</a></h1>
<h2 id="整个刚体对外力的响应"><a class="header" href="#整个刚体对外力的响应">整个刚体对外力的响应</a></h2>
<p>虽然刚体受到的力都是作用在刚体上的某个点上。但受力点不能独立的响应这个力。而是要让刚体作为整体来响应这个力。<br />
即，刚体的质心的全局位置（世界坐标系）和全局旋转（世界坐标系）。<br />
因此，刚体在力的作用下会发生旋转和平移。</p>
<p><img src="Rigid/../assets/03-1.png" alt="" /></p>
<h3 id="平移"><a class="header" href="#平移">平移</a></h3>
<p>刚体受力后的平移响应与粒子相似。</p>
<ol>
<li>当刚体同时受到多个力时，通过相加计算出合力。</li>
<li>连续形式与离散形式下的速度、位置更新公式也相同</li>
</ol>
<p><img src="Rigid/../assets/03-3.png" alt="" /></p>
<p>不同的是，在刚体仿真中，质量 \(M\) 可以是个对角矩阵或实数</p>
<h3 id="旋转"><a class="header" href="#旋转">旋转</a></h3>
<p>当受到的所有力都是作用于质心或者均匀作用于每个点(例如重力)时，刚体不会发生旋转。<br />
因此这里只分析力的作用点不在质心时的场景。<br />
力造成物体运动的趋势。 Torque（力矩）造成物体旋转的趋势。为了计算刚体在下一时刻的旋转状态，需要把力转化力矩。</p>
<blockquote>
<p>✅ 力转化为力矩，不是物理性质上的转化，而是数学形式上的转化。把力用力矩的形式表达，用于计算它对旋转产生的影响。<br />
inertia、torque等概念，请戳这里<a href="Rigid/./supplementary.html">link</a></p>
</blockquote>
<p>参考刚体平移的离散积分过程，可以推导出刚体旋转的更新法则：</p>
<table><thead><tr><th></th><th>Translational (linear)</th><th>Rotational (Angular)</th></tr></thead><tbody>
<tr><td>Updafe</td><td><img src="Rigid/../assets/03-23.png" alt="" /></td><td><img src="Rigid/../assets/03-24.png" alt="" /></td></tr>
<tr><td>states</td><td>Velocity \(\mathbf{v}\) <br> Position \(\mathbf{x}\)</td><td>Angular velocity \(\mathbf{ω} \)<br>   Quaternion \(\mathbf{q}\)</td></tr>
<tr><td>Physical Quantities</td><td>Mass \(\mathbf{M}\) <br> Force \(\mathbf{f}\)</td><td>Inertia \(\mathbf{I} \) <br> Torque \(\mathbf{τ} \)</td></tr>
</tbody></table>
<blockquote>
<p>✅  平移： \(加速度 = \frac{力}{质量}\) ，旋转： \(加速度 =\frac{力矩}{\text{Inertia}}\)<br />
✅  \(q\)是四元数，代表物体的旋转状态<br />
✅  \(q_1\times q_2\)不是叉乘，而是四元数普通乘法<br />
✅  \(\begin{bmatrix}
0 &amp; \frac{\bigtriangleup t}{2}  &amp; w^{(1)}
\end{bmatrix}\)是一个四元数，0为实部，后面为虚部<br />
❗  算完\(q^{[1]}\)的之后要对它 Normalize<br />
🔎 由\(q^{[0]}\)到\(q^{[1]}\)的更新公式的推导过程见Affer Class Reading（Appendix B）</p>
</blockquote>
<p><img src="Rigid/../assets/03-20.png" alt="" /></p>
<p>P30 </p>
<h3 id="总结-1"><a class="header" href="#总结-1">总结</a></h3>
<p><img src="Rigid/../assets/03-27.png" alt="" /><br />
<img src="Rigid/../assets/04-1.png" alt="" /></p>
<h2 id="刚体内部的子系统之间的力的响应"><a class="header" href="#刚体内部的子系统之间的力的响应">刚体内部的子系统之间的力的响应</a></h2>
<p>可以用于做刚体破碎的效果</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力与力矩"><a class="header" href="#力与力矩">力与力矩</a></h1>
<h2 id="力矩-torque-mathbfτ-"><a class="header" href="#力矩-torque-mathbfτ-">力矩 torque \(\mathbf{τ} \)</a></h2>
<p>A torque is the rotational equivalent of a force. It describes the rotational <u>tendency</u> caused by a force.</p>
<blockquote>
<p>✅ Torque：力矩，造成物体旋转的趋势。类比于Force：力，造成物体运动的趋势。</p>
</blockquote>
<p><img src="Rigid/../assets/04-2.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{Rr} _i\)：当前状态下质心到作用点的向量 </p>
</blockquote>
<p>\(\mathbf{τ} _i\) is perpendicular to both vectors: \(\mathbf{Rr} _i\) and \(\mathbf{f} _i\).</p>
<blockquote>
<p>✅ 力矩的方向决定了旋转轴的方向，由叉差乘得到</p>
</blockquote>
<p>\(\mathbf{τ} _i\) is porportional to ||\(\mathbf{Rr} _i\)|| and ||\(\mathbf{f} _i\)||.</p>
<p>\(\mathbf{τ} _i\) is porportional to \(\sin \theta\).<br />
(\(\theta\)  is the angle between two vectors.)</p>
<blockquote>
<p>✅ 力矩的大小决定旋转的快慢。 </p>
</blockquote>
<table><thead><tr><th>\(\mathbf{τ} _i\longleftarrow (\mathbf{Rr} _i)\times \mathbf{f} _i\)</th></tr></thead><tbody>
</tbody></table>
<p><img src="Rigid/./assets/03-22.png" alt="" /> </p>
<p>P6</p>
<h2 id="inertia-tensor"><a class="header" href="#inertia-tensor">inertia tensor</a></h2>
<p>Similar to mass, an inertia tensor describes the resistance to rotational tendency caused by torque. But different from mass, it’s not a constant.</p>
<blockquote>
<p>✅ inertia 也与自身的状态相关</p>
</blockquote>
<p><img src="Rigid/./assets/04-3.png" alt="" /></p>
<p>Which side receives greater resistance?</p>
<blockquote>
<p>✅ 两图的力矩大小相同，但产生的旋转不同<br />
inertia 看作是对运动的抵抗，其效果与力矩的方向有关，因此不是常数</p>
</blockquote>
<p>P7</p>
<p>It’s a matrix! The mass inverse is the resistance (just like mass).</p>
<blockquote>
<p>✅ 用于旋转的质量不再是实数，而是矩阵，称为 Inertia 矩阵，用 \(\mathbf{I}\) 来标记 Inertia 矩阵，其中 \(\mathbf{I}_{ref}\)为参考状态，\(\mathbf{I}\) 为当前状态，\(\mathbf{I}\) 是 \(3\times 3\) 矩阵。</p>
</blockquote>
<table><thead><tr><th>reference state</th><th>current state</th></tr></thead><tbody>
<tr><td><img src="Rigid/../assets/04-4.png" alt="" /></td><td><img src="Rigid/../assets/04-5.png" alt="" /></td></tr>
<tr><td>\(\mathbf{I} _{\mathbf{ref} }=\sum m_i(\mathbf{r} _i^\mathbf{T} \mathbf{r} _i\mathbf{1} −\mathbf{r} _i\mathbf{r} _i^\mathbf{T} )\)<br>\(\mathbf{1}\)  is the 3-by-3 identity.</td><td>\(\mathbf{I} =\sum m_i(\mathbf{r} _i^\mathbf{T}\mathbf{R}  ^\mathbf{T}\mathbf{Rr}  _i\mathbf{1} −\mathbf{Rr} _i\mathbf{r} _i^\mathbf{T} \mathbf{R^T} )\)  <br> \(\quad=\sum m_i(\mathbf{Rr} _i^\mathbf{T}\mathbf{r}  _i\mathbf{1R}  ^\mathbf{T} −\mathbf{Rr} _i\mathbf{r} _i^\mathbf{T} \mathbf{R^T} )\) <br> \(\quad=\sum m_i\mathbf{R}(\mathbf{r}_i^\mathbf{T}\mathbf{r}_i\mathbf{1}−\mathbf{r}_i\mathbf{r}_i^\mathbf{T} ) \mathbf{R^T}\)   <br> \(\quad=\mathbf{RI _{ref}R^T}\)</td></tr>
</tbody></table>
<blockquote>
<p>✅ 不需要每次都根据当前状态计算，而是基于一个已经算好的ref状态的 inertia快速得出。</p>
</blockquote>
<p>P33</p>
<h1 id="after-class-reading-before-collision"><a class="header" href="#after-class-reading-before-collision">After-Class Reading (Before Collision)</a></h1>
<p>P35</p>
<p><a href="https://graphics.pixar.com/pbm2001">https://graphics.pixar.com/pbm2001</a></p>
<blockquote>
<p>✅ 建议读其中的Rigid Body Dynamics部分</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>系统所假设的场景为一个粒子和一个刚体。其中粒子代表有位置无体积的仿真对向。如果系统中有多个粒子，粒子之间无相互作用，所以独立仿真每个粒子。刚体代表有位置有体积的仿真对象，换成弹性体等有位置有体积的仿真对象，此系统也适用。<br />
此系统主要要考虑的是刚体对粒子的作用。</p>
<h2 id="子系统粒子的属性-1"><a class="header" href="#子系统粒子的属性-1">子系统（粒子）的属性</a></h2>
<ul>
<li>粒子属性</li>
</ul>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>全局位置</td><td>p或x</td><td>是</td></tr>
</tbody></table>
<ul>
<li>刚体属性</li>
</ul>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m（均质）或M（非均质）</td><td>否。刚体的质量为其所有粒子的质量之和。</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>p或x</td><td>是。刚体所占的是一个连续的空间，而不是一个点。选择刚体中的某一个点（通常是质心）的位置作为刚体的位置</td></tr>
<tr><td>全局旋转（世界坐标系）</td><td>q <br> 旋转的表示戳这里<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/Geometry/Quaternion.html">link</a>。最后结论是四元数表示方法。</td><td>是</td></tr>
</tbody></table>
<h2 id="组合系统刚体的属性-1"><a class="header" href="#组合系统刚体的属性-1">组合系统（刚体）的属性</a></h2>
<p>无</p>
<h2 id="子系统聚合后产生的新属性-1"><a class="header" href="#子系统聚合后产生的新属性-1">子系统聚合后产生的新属性</a></h2>
<p>无</p>
<h1 id="应用场景-2"><a class="header" href="#应用场景-2">应用场景</a></h1>
<p>实际应用场景中对单个粒子进行仿真没有意义。<br />
是后面多刚体仿真的基础。  </p>
<div style="break-before: page; page-break-before: always;"></div><p>P9</p>
<h1 id="topics-for-the-day"><a class="header" href="#topics-for-the-day">Topics for the Day</a></h1>
<ul>
<li>Particle Collision Detection and Response
<ul>
<li>Penalty methods</li>
<li>Impulse methods</li>
</ul>
</li>
<li>Collision Detection
<ul>
<li>Broad Phase</li>
<li>Narrow Phase</li>
</ul>
</li>
<li>Collision Response
<ul>
<li>Rigid Collision Response by Impulse</li>
</ul>
</li>
<li>Interior Point Methods</li>
<li>Impact Zone Optimization</li>
<li>Shape Matching</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P11</p>
<h1 id="粒子碰撞检测-----sdf"><a class="header" href="#粒子碰撞检测-----sdf">粒子碰撞检测 --- SDF</a></h1>
<h2 id="signed-distance-function"><a class="header" href="#signed-distance-function">Signed Distance Function</a></h2>
<p>A <u>signed</u> distance function \(\phi (\mathbf{x} )\) defines the distance from \(\mathbf{x}\) to a surface with a sign. The sign indicates on which side \(\mathbf{x}\) is located.</p>
<p><img src="./assets/04-6.png" alt="" /></p>
<p>P12</p>
<h3 id="signed-distance-function-examples"><a class="header" href="#signed-distance-function-examples">Signed Distance Function Examples</a></h3>
<p><img src="./assets/04-07.png" alt="" /></p>
<blockquote>
<p>✅ 圆柱SDF基于勾股定理，\(\sqrt{\cdot }\) 内第一项为斜边长，
第二项为底边长，得出点到中轴的距离。</p>
</blockquote>
<p>P13</p>
<h2 id="intersection-of-signed-distance-functions"><a class="header" href="#intersection-of-signed-distance-functions">Intersection of Signed Distance Functions</a></h2>
<p><img src="./assets/04-8.png" alt="" /></p>
<blockquote>
<p>If \(\phi _0(\mathbf{x} )&lt;0\) and \(\phi_1(\mathbf{x} )&lt;0\) and \(\phi_2(\mathbf{x} )&lt;0\)<br />
then inside<br />
\(\quad \phi (\mathbf{x} )\)=max \(⁡(\phi_0(\mathbf{x}),\phi_1(\mathbf{x}),\phi_2(\mathbf{x}))\)<br />
Else outside<br />
\(\quad \phi (\mathbf{x})=?\)</p>
</blockquote>
<p>P14</p>
<h3 id="union-of-signed-distance-functions"><a class="header" href="#union-of-signed-distance-functions">Union of Signed Distance Functions</a></h3>
<p><img src="./assets/04-9.png" alt="" /></p>
<blockquote>
<p>✅ 有时候此公式不成立，例如图中\(\mathbf{x}\) 点</p>
</blockquote>
<p>Intuitively, we can consider collision detection with the union of two objects as <strong>collision detection with two separate objects</strong>.</p>
<p>P15</p>
<h1 id="粒子碰撞响应--penalty-method"><a class="header" href="#粒子碰撞响应--penalty-method">粒子碰撞响应 —— Penalty Method</a></h1>
<h2 id="quadratic-penalty-method"><a class="header" href="#quadratic-penalty-method">Quadratic Penalty Method</a></h2>
<p>A penalty method applies a penalty force in the next update. When the penalty potential is quadratic, the force is linear.</p>
<p><img src="./assets/04-11.png" alt="" /></p>
<p><img src="./assets/04-10.png" alt="" /></p>
<p>当粒子进入物体内部后，就会产生一个向外的推力。</p>
<blockquote>
<p>✅ 力的大小与距离有关，方向为normal<br />
✅ 存在的问题：只有\(\mathbf{x}\) 进入 mesh 内部了，才会有力，但此时穿透的 artifacts 已经产生了。解决方法：使用buffer</p>
</blockquote>
<p>P16</p>
<h2 id="quadratic-penalty-method-with-a-buffer"><a class="header" href="#quadratic-penalty-method-with-a-buffer">Quadratic Penalty Method with a Buffer</a></h2>
<p>A buffer helps lessen the penetration issue. But it cannot strictly prevent penetration, no matter how large \(k\) is.</p>
<p><img src="./assets/04-12.png" alt="" /><br />
<img src="./assets/04-13.png" alt="" /></p>
<blockquote>
<p>✅ 存在的问题：<br />
如果 \(k\) 太小，快速的碰撞仍会产生 artifacts<br />
如果 \(k\) 太大，碰撞的反弹过于强烈(overshooting)<br />
解决方法：不用常数 \(k\) ，而是 \(k\) 与距离相关</p>
</blockquote>
<p>P17</p>
<h2 id="log-barrier-penalty-method"><a class="header" href="#log-barrier-penalty-method">Log-Barrier Penalty Method</a></h2>
<p>A log-barrier penalty potential ensures that the force can be large enough. But it assumes \(\phi (\mathbf{x} ) &lt; 0\) will never happen!!! To achieve that, it needs to adjust \(\Delta t\).</p>
<p><img src="./assets/04-15.png" alt="" /></p>
<blockquote>
<p>✅ 用倒数关系代替线性关系。<br />
✅ 存在的问题：<br />
1.当\(\mathbf{x}\) 靠近物体表面时，仍然会 overshooting<br />
2.\(\mathbf{x}\) 穿透表面后，会越陷越深。<br />
3.本算法如果要求保证穿透永远不会发生，因此要仔细调节 \(\Delta t\).</p>
</blockquote>
<p>P18</p>
<h2 id="a-short-summary-of-penalty-methods"><a class="header" href="#a-short-summary-of-penalty-methods">A Short Summary of Penalty Methods</a></h2>
<ul>
<li>
<p>The use of step size adjustment is a must.</p>
<ul>
<li>To avoid overshooting.</li>
<li>To avoid penetration in log-barrier methods.</li>
</ul>
</li>
<li>
<p>Log-barrier method can be limited within a buffer as well.</p>
<ul>
<li>Li et al. 2020. <em>Incremental Potential Contact: Intersection- and Inversion-free Large Deformation Dynamics</em>. TOG.</li>
<li>Wu et al. 2020. <em>A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions</em>. TOG.</li>
</ul>
</li>
<li>
<p>Frictional contacts are difficult to handle.</p>
</li>
</ul>
<blockquote>
<p>✅ 缺点：<br />
(1) 难以模拟摩擦。<br />
(2) 碰撞-&gt;施加力-&gt;调整，因此效果是滞后的。<br />
优点：易实现</p>
</blockquote>
<p>P19</p>
<h1 id="particle-collision-response--impulse-method"><a class="header" href="#particle-collision-response--impulse-method">Particle Collision Response —— Impulse Method</a></h1>
<p>An impulse method assumes that collision changes the position and the velocity all of sudden.</p>
<blockquote>
<p>✅ Penalty 方法是碰撞 → 力 → 下一时刻的速度和位置，效果滞后。<br />
✅ Impulse方法碰撞时立即更新速度和位置</p>
</blockquote>
<p><img src="./assets/04-16.png" alt="" /></p>
<blockquote>
<p>✅ lmpulse 省去了力这一步，直接更新刚体状态。方法要求已经有一个比较好的\(\phi (x)\)<br />
✅ 关键区别不在于是否使用力，而是位置是怎样计算出来的，前者的位置由力和速度，这个计算出来的(不管是作为下一时刻还是这一时刻)的位置，都不能保证一定能以物体内部推出来，但后者直接求出当前置对应的表面位置的点，并更新上去，因此能立即生效。</p>
</blockquote>
<h2 id="更新位置"><a class="header" href="#更新位置">更新位置</a></h2>
<p><img src="./assets/04-17.png" alt="" /></p>
<blockquote>
<p>✅ 更新方向：N方向。更新距离：穿入的距离。</p>
</blockquote>
<h2 id="更新速度"><a class="header" href="#更新速度">更新速度</a></h2>
<p>P20<br />
Changing the position is not enough, we must change the velocity as well.</p>
<blockquote>
<p>✅ \(\mathbf{v}\cdot \mathbf{N}\ge 0\)：当前速度想要让物体越陷越深, 这种情况下才需要更新速度</p>
</blockquote>
<p><img src="./assets/04-18-1.png" alt="" /></p>
<blockquote>
<p>✅ 把\(\mathbf{v}\)分解为\(\mathbf{v_T}\)（切线方向的速度）和\(\mathbf{v_N}\)（法线方向的速度）.<br />
✅ \(\mathbf{v_N}\)方向速度反弹， \(\mu _\mathbf{N}\) 为反弹系数。\(\mathbf{v_N}\)方向不变或由于摩擦而衰减<br />
✅ a的约束：（1）越小越好，尽量把速度衰减掉（2）满足库仑定律（切方向的速度改变不应大于法线方向的速度改变）（3）切方向速度不能反转，即a不能为负</p>
</blockquote>
<h2 id="impulse方法总结"><a class="header" href="#impulse方法总结">Impulse方法总结</a></h2>
<blockquote>
<p>✅ 优点：可以精确控制摩擦力和反弹位置。缺点：计算比 Penalty 复杂<br />
✅ 刚体常见于 Impulse； 弹性体常见于Penalty.</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="collision-detection-pipeline"><a class="header" href="#collision-detection-pipeline">Collision Detection Pipeline</a></h1>
<p><img src="./assets/09-1.png" alt="" /></p>
<p>P5</p>
<h2 id="方法一spatial-partitioning"><a class="header" href="#方法一spatial-partitioning">方法一：Spatial Partitioning</a></h2>
<p>Spatial partitioning divides the space by a grid and stores objects into grid cells.</p>
<p>P6</p>
<h3 id="静止场景"><a class="header" href="#静止场景">静止场景</a></h3>
<p>To find pair candidates for collision test, we just have to check the grid cells.</p>
<p><img src="./assets/09-2.png" alt="" /></p>
<p>P7</p>
<h3 id="运动场景"><a class="header" href="#运动场景">运动场景</a></h3>
<p>If we need to consider moving objects, we just expand the object region.</p>
<p><img src="./assets/09-3.png" alt="" /></p>
<p>P8</p>
<h3 id="数据存储"><a class="header" href="#数据存储">数据存储</a></h3>
<p>Instead of allocating <strong>memories</strong> to cells, we can build an object-cell list and then sort them. This avoids memories wasted in empty cells.</p>
<blockquote>
<p>✅要解决的问题：3D空间需要划分出大量的小格。有的格子可能包含很多object. 大多数格子可能没有object.<br />
✅方法：3D数组转为list表示法。<br />
✅缺点：内存访问不连续。</p>
</blockquote>
<p><img src="./assets/09-5.png" alt="" /></p>
<p>P9</p>
<h4 id="morton-code"><a class="header" href="#morton-code">Morton Code</a></h4>
<blockquote>
<p>✅ Morton Code：一种对格子编号的顺序。</p>
</blockquote>
<p>One question is how to define the cell ID. Using the grid order is not optimal, since it cannot be easily extended and it is lack of locality. Morton code uses a Z-pattern instead.</p>
<p><img src="./assets/09-6.png" alt="" /></p>
<blockquote>
<p>✅ 希望内存访问尽量连续。也就是下一次访问的内存地址在上次的附近<br />
✅ Grid Order：横向访问连续、纵向访问不连续、三维情况会更严重。</p>
</blockquote>
<p><img src="./assets/09-7.png" alt="" /></p>
<p>P10</p>
<h2 id="after-class-reading"><a class="header" href="#after-class-reading">After-Class Reading</a></h2>
<p>GPU Gems 3</p>
<p>Chapter 32. Broad-Phase Collision Detectionwith CUDA</p>
<p>P14</p>
<h2 id="方法二bounding-volume-hierarchy"><a class="header" href="#方法二bounding-volume-hierarchy">方法二：Bounding Volume Hierarchy</a></h2>
<p>Bounding volume hierarchy is built on geometric/topological proximity of objects.</p>
<blockquote>
<p>✅空间划分→物体划分</p>
</blockquote>
<p>P16</p>
<h2 id="构造bounding-box"><a class="header" href="#构造bounding-box">构造Bounding Box</a></h2>
<p><u>Axis-aligned bounding box (AABB)</u> is the most popular bounding volume. Besides that, there are also <u>spheres</u> and <u>oriented bounding box (OBB)</u>.</p>
<p>Two AABBs intersect if and only if they intersect in every axis.</p>
<h2 id="构造bvh"><a class="header" href="#构造bvh">构造BVH</a></h2>
<p><img src="./assets/09-8.png" alt="" /></p>
<p>P15</p>
<h2 id="外部物体与身体相交检测"><a class="header" href="#外部物体与身体相交检测">外部物体与身体相交检测</a></h2>
<p>To find elements potentially in collision with an object, we just traverse the tree.</p>
<p><img src="./assets/09-9.png" alt="" /></p>
<p>P17</p>
<h2 id="自相交检测"><a class="header" href="#自相交检测">自相交检测</a></h2>
<p>To process <strong>self collisions</strong> by BVH, we define two procedures.</p>
<p><img src="./assets/09-10-1.png" alt="" /></p>
<p><img src="./assets/09-10.png" alt="" /></p>
<p>P18</p>
<p>The performance depends on the effectiveness of 剪枝。</p>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2012</td><td>Energy-based Self-Collision Culling for Arbitrary Mesh Deformations</td><td>✅ 对每个区域计算能量，根据形变能量的大小来判断有没有可能相交，此方法不适用于衣服，因为在衣服模拟中大形变很常见、不代表有相交。</td><td></td><td></td></tr>
</tbody></table>
<p>P19</p>
<h1 id="comparison-between-sh-and-bvh"><a class="header" href="#comparison-between-sh-and-bvh">Comparison between SH and BVH</a></h1>
<ul>
<li>
<p>Spatial Hashing</p>
<ul>
<li>Easy to implement</li>
<li>GPU friendly</li>
<li>Needs to <u>recompute</u> after updating objects</li>
</ul>
</li>
<li>
<p>Bounding Volume Hierarchy</p>
<ul>
<li>More involved</li>
<li>Not GPU friendly</li>
<li>To update BVH, just update bounding volumes</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ CUDA 代码. NVIDIA 代码通常使用SH。GPU 喜欢简单粗爆的数据结构，BVH相对于GPU过于复杂。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P21</p>
<h1 id="discrete-collision-detection-dcd"><a class="header" href="#discrete-collision-detection-dcd">Discrete Collision Detection (DCD)</a></h1>
<p>DCD tests if any intersection exists in each state at discrete time instant: \(\mathbf{x}^{[0]}\), \(\mathbf{x}^{[1]}\), …</p>
<blockquote>
<p>✅ 准确来说。DCD检测的不是碰撞，而是相交</p>
</blockquote>
<h2 id="edge-triangle-intersection"><a class="header" href="#edge-triangle-intersection">edge-triangle intersection</a></h2>
<p>To a triangle mesh, the basic test is <u>edge-triangle intersection</u> test.</p>
<p><img src="./assets/09-13.png" alt="" /></p>
<p><img src="./assets/09-14.png" alt="" /></p>
<blockquote>
<p>\(t\) 代表相交位置对应 \(\mathbf{x}_a\) 和\(\mathbf{x}_b\)的插值量</p>
</blockquote>
<blockquote>
<p>✅ 检测在特定状态下是否相交，每一帧都不相交就认为无碰撞。<br />
✅ 相交和碰撞的区别：相交分析的是运动前后的状态、碰撞检测的是运动的过程、未相交不一定无碰撞、</p>
</blockquote>
<p>P22</p>
<h2 id="tunneling"><a class="header" href="#tunneling">Tunneling</a></h2>
<p>DCD is simple and robust, but it suffers from the tunneling problem: objects penetrating through each other without being detected.</p>
<p><img src="./assets/09-15.png" alt="" /></p>
<blockquote>
<p>tunneling problem：当物体运动特别快时，有可能的穿透另一物体而没有被检测到，常见于细薄物体、例如衣服<br />
这种情况无相交但是有碰撞</p>
</blockquote>
<p>P23</p>
<h1 id="continuous-collision-detection-ccd"><a class="header" href="#continuous-collision-detection-ccd">Continuous Collision Detection (CCD)</a></h1>
<p>CCD tests if any intersection exists between two states: \(\mathbf{x} ^{[0]}\) and \(\mathbf{x} ^{[1]}\).</p>
<p>To a triangle mesh, there two basic tests: <u>vertex-triangle</u> and <u>edge-edge</u> tests.</p>
<h2 id="vertex-triangle-tests"><a class="header" href="#vertex-triangle-tests">vertex-triangle tests</a></h2>
<p><img src="./assets/09-17.png" alt="" /></p>
<p><img src="./assets/09-16.png" alt="" /></p>
<blockquote>
<p>✅ 当四点共面时，构成的四面体体积为0、利用四面体的体积公式，可求出四点共面的时间 \(t\) . <strong>这里的</strong>\(\mathbf{t}\)<strong>是时间</strong><br />
✅ 假设运动是匀速的，\( \mathbf{x}_ {30}(t)、 \mathbf{x}_ {10}(t)、\mathbf{x}_ {20}(t)\)都是关于\(t\)的线性函数。<br />
✅ 一元三次方程有公式解，但用到\(\sqrt[3]{\cdot}\)，\(\sqrt[3]{\cdot }\) 的误差非常大。因此不建议使用，建议用牛顿法。</p>
</blockquote>
<p>P24</p>
<h2 id="edge-edge-tests"><a class="header" href="#edge-edge-tests">edge-edge tests</a></h2>
<blockquote>
<p>✅ 为什么要检测边边相交，因为有可能三角形相交但点面没有相交。</p>
</blockquote>
<p><img src="./assets/09-18.png" alt="" /></p>
<p><img src="./assets/09-19.png" alt="" /></p>
<blockquote>
<p>✅ 先求四点共面的 \(t\)<br />
✅ 解一元三次方程也不建议牛顿法，而是二分法，因为\(t\)的范围是[0,1]</p>
</blockquote>
<p>P25</p>
<h2 id="issues-with-ccd"><a class="header" href="#issues-with-ccd">Issues with CCD</a></h2>
<ul>
<li>Floating-point errors, especially due to root finding of a cubic equation
<ul>
<li>Buffering epsilons, but that causes <strong>false positives</strong>.</li>
<li>Gaming GPUs often use single floating-point precision.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 游戏 GPU 以单精度为主，因此要注意浮点误差问题。</p>
</blockquote>
<ul>
<li>
<p>Computational costs: more expensive than DCD.</p>
<ul>
<li>Some argue that broad-phase collision culling is the bottleneck.</li>
</ul>
</li>
<li>
<p>Difficulty in implementation.</p>
</li>
</ul>
<p>P26</p>
<h2 id="after-class-reading-1"><a class="header" href="#after-class-reading-1">After-Class Reading</a></h2>
<p>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact and Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</p>
<p>Relative simple explicit integration of cloth dynamics</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P24</p>
<h1 id="rigid-body-discrete-collision-response"><a class="header" href="#rigid-body-discrete-collision-response">Rigid Body Discrete Collision Response</a></h1>
<h2 id="rigid-body-collision-response-by-impulse"><a class="header" href="#rigid-body-collision-response-by-impulse">Rigid Body Collision Response by Impulse</a></h2>
<p>碰撞 → 粒子响应 → 粒子速度 → 刚体冲重 → 刚体状态</p>
<h3 id="刚体碰撞响应与粒子碰撞响应的区别"><a class="header" href="#刚体碰撞响应与粒子碰撞响应的区别">刚体碰撞响应与粒子碰撞响应的区别</a></h3>
<p><img src="./assets/04-20.png" alt="" /></p>
<p>以Vertex i为例，先分析i当前的位置和速度:</p>
<p><img src="./assets/04-21.png" alt="" /></p>
<p>Problem: <strong>we cannot directly modif</strong>y \(\mathbf{x}_i\) or \(\mathbf{v}_i\) <strong>isince they not state variables</strong>. They areindirectly determined.</p>
<blockquote>
<p>✅\(x\)和\(v\)分别是刚体质心点的位置和速度,第二项为刚体上的特定点相对于质心点的位置和速度<br />
<strong>对于粒子，可以直接用Impulse修改\(x\)和\(v\)</strong><br />
<strong>对于刚体，impulse只能修改\(x\)和\(v\)，不能修改\(x_i\)和\(v_i\)</strong>；其中\(x\)可以通过直接修改更新，也可以通过修改\(v\)来更新，这里选择后者。</p>
</blockquote>
<h2 id="解决方法通过修改mathbfv和mathbfomega实现修改x_i和v_i"><a class="header" href="#解决方法通过修改mathbfv和mathbfomega实现修改x_i和v_i">解决方法：通过修改\(\mathbf{v}\)和\(\mathbf{\omega}\)实现修改\(x_i\)和\(v_i\)</a></h2>
<p>P25</p>
<h3 id="反向思考"><a class="header" href="#反向思考">反向思考</a></h3>
<p>What happens to \(\mathbf{v}_i\) when an impulse \(\mathbf{j}\) is appliedat vertex \(i\)?</p>
<blockquote>
<p>✅ \(\mathbf{j}\) 是一个未知的冲量。\(\mathbf{v}_i\) 是点速度、\(\mathbf{v}\)是线速度<br />
✅假设：此时对\(x_i\)点施加冲量\(j\)，会发生什么？</p>
</blockquote>
<p><img src="./assets/04-22-1.png" alt="" /></p>
<blockquote>
<p>✅ 冲量 = \(Ft\) = \(m\Delta v \Rightarrow \Delta v\) = 冲量/\(m\)，由此得到\(v^{new}\)<br />
✅ 冲量=质量矩阵 * \( \Delta \omega \) = 力矩 * \(t(Rr_i) \times fi·t=(Rr_i \times j)\)，可得：
\(Rr_i \times j\) = 冲量造成的力矩 ＝ 质量矩阵 · \(\Delta \omega \Rightarrow \Delta \omega\) ＝ 质量矩阵\(^{-1}\) · 冲量力矩 ，由此得到\(\omega^{new}\)<br />
❓ 为什么质量矩阵是单位阵？</p>
</blockquote>
<h3 id="由线速度vnew得到点速度mathbfv_inew"><a class="header" href="#由线速度vnew得到点速度mathbfv_inew">由线速度\(v^{new}\)得到点速度\(\mathbf{v}_i^{new}\)</a></h3>
<p><img src="./assets/04-22-2.png" alt="" /></p>
<p>P27</p>
<p>$$
\mathbf{v_i^{new}} = \mathbf{v} _i+\frac{1}{M}\mathbf{j} −(\mathbf{Rr} _i)×(\mathbf{I} ^{−1}(\mathbf{Rr} _\mathbf{i}\times \mathbf{j} ))
$$</p>
<blockquote>
<p>✅ 向量之间的点乘可以转化为矩阵与向量的乘法，方便化简。具体内容见页面最后的<strong>补充1</strong></p>
</blockquote>
<p>$$
\mathbf{v_i^{new}} = \mathbf{v} _i+\frac{1}{M} \mathbf{j} −(\mathbf{Rr} _i)^∗\mathbf{I} ^{−1} (\mathbf{Rr} _i)^∗\mathbf{j} 
$$</p>
<p>化简得：</p>
<blockquote>
<p>$$
\mathbf{v_i^{new}}-\mathbf{v}_i=\mathbf{Kj}
$$
$$
\mathbf{K} \longleftarrow \frac{1}{M} \mathbf{1} −(\mathbf{Rr} _i)^{∗}\mathbf{I} ^{−1}(\mathbf{Rr} _i)^{∗}
$$</p>
</blockquote>
<blockquote>
<p>✅ 结论，当碰撞点\(i\)确定时，冲量\(j\)和其造成的速度改变量\(Δv\)是确定的，这样，可以通过施加\(j\)，精确修改\(v_i\)<br />
✅ 已知 \(\mathbf{v}_i^{new},\mathbf{v}_i,\mathbf{K}\),可求得 \(\mathbf{j}\)</p>
</blockquote>
<p>P28</p>
<h3 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h3>
<p><img src="./assets/04-24.png" alt="" /></p>
<blockquote>
<p>✅ \(i\)点发生碰撞 → 算出i点碰撞后的速度 → 算出给i点什么样的冲量能让\(i\)出现碰撞后的效果 → 真的施加这样一个冲量 → 更新刚体状态</p>
</blockquote>
<p>P29</p>
<h2 id="some-implementation-details"><a class="header" href="#some-implementation-details">Some Implementation Details</a></h2>
<ul>
<li>If there are many vertices in collision, we use their position average.</li>
</ul>
<blockquote>
<p>✅ 如果有多个顶点发生碰撞呢？
答：方法1，问题简化，用平均值。方法2，解线性系统，见下一页</p>
</blockquote>
<ul>
<li>We can decrease the restitution \(\mathbf{\mu_N} \) to reduce oscillation（抖动）.</li>
</ul>
<blockquote>
<p>✅ 抖动原因：重力让它往下，冲量让它往上，导致在地面上反复振荡<br />
解决方法：接近静止时衰减 \(\mathbf{\mu_N} \)</p>
</blockquote>
<ul>
<li>We don't update the position here. Why?
<ul>
<li>Because the problem is nonlinear.</li>
<li>We will come back to this later when we talk about constraints.</li>
</ul>
</li>
</ul>
<p>P30</p>
<h2 id="多碰撞点场景"><a class="header" href="#多碰撞点场景">多碰撞点场景</a></h2>
<p><img src="./assets/04-25.png" alt="" /></p>
<p>Relative velocity at joints</p>
<p>$$
\begin{cases}
\mathbf{v} _0 ^{\mathbf{new} }− \mathbf{v} _0=\mathbf{K} _{a00 }\mathbf{j} _0+\mathbf{K} _{a01 }\mathbf{j} _1 −(−\mathbf{K} _{b00 }\mathbf{j} _0 +\mathbf{K} _{b02}\mathbf{j} _2 )\\
\mathbf{v} _1 ^{\mathbf{new} }− \mathbf{v} _1=\mathbf{K} _{a10 }\mathbf{j} _0+\mathbf{K} _{a11 }\mathbf{j} _1 −(−\mathbf{K} _{c11 }\mathbf{j} _0 +\mathbf{K} _{c13 }\mathbf{j} _3 )\\
\mathbf{v} _2 ^{\mathbf{new} }− \mathbf{v} _2=\mathbf{K} _{b20 }\mathbf{j} _0+\mathbf{K} _{b22 }\mathbf{j} _2\\
\mathbf{v} _3 ^{\mathbf{new} }− \mathbf{v} _3=\mathbf{K} _{c31 }\mathbf{j} _1+\mathbf{K} _{c33 }\mathbf{j} _3
\end{cases}
$$</p>
<p>$$
\Downarrow
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{K} _{a00 }+\mathbf{K} _{b00 } &amp; \mathbf{K} _{a01 } &amp; -\mathbf{K} _{b02 } &amp; \Box \\
\mathbf{K} _{a10 } &amp; \mathbf{K} _{a11 }+\mathbf{K} _{c11 } &amp; \Box  &amp; -\mathbf{K} _{c13 }\\
-\mathbf{K} _{b20 } &amp; \Box  &amp; \mathbf{K} _{b22} &amp; \Box \\
\Box  &amp; -\mathbf{K} _{c31 } &amp; \Box  &amp; \mathbf{K} _{c33 } 
\end{bmatrix}\begin{bmatrix}
\mathbf{j} _{0 }\\
\mathbf{j} _{1}\\
\mathbf{j} _{2}\\
\mathbf{j} _{3}
\end{bmatrix}=\begin{bmatrix}
\bigtriangleup \mathbf{v} _{0}\\
\bigtriangleup \mathbf{v} _{1}\\
\bigtriangleup \mathbf{v} _{2}\\
\bigtriangleup \mathbf{v} _{3}
\end{bmatrix}
$$</p>
<p>\(\mathbf{K} _{a01}\mathbf{j} _1\) stands for the velocity change of bunny \(a\) at joint 0, caused by impulse \(\mathbf{j}_1\).</p>
<p>P31</p>
<h2 id="after-class-reading-before-collision-1"><a class="header" href="#after-class-reading-before-collision-1">After-Class Reading (Before Collision)</a></h2>
<p><a href="https://graphics.pixar.com/pbm2001">https://graphics.pixar.com/pbm2001</a><br />
Rigid Body Dynamics</p>
<p>P32</p>
<h2 id="shape-matching"><a class="header" href="#shape-matching">Shape Matching</a></h2>
<blockquote>
<p>✅ 用粒子的方法来解决刚体的问题</p>
</blockquote>
<p>P33</p>
<h3 id="basic-idea"><a class="header" href="#basic-idea">Basic Idea</a></h3>
<p>We allow each vertex to have its own velocity, so it can move by itself.</p>
<p><img src="./assets/04-26.png" alt="" /></p>
<p>First, move vertices <strong>independently</strong> by its velocity, with collision and friction being handled.</p>
<p>Second, enforce the <strong>rigidity</strong> constraint to become a rigid body again.</p>
<blockquote>
<p>✅ 第二步是 Shape Matching 的关键</p>
</blockquote>
<p>Rigidity：包含更新质心的位置和旋转</p>
<p>P34</p>
<h3 id="更新质心位置"><a class="header" href="#更新质心位置">更新质心位置</a></h3>
<p>Now \(\mathbf{c}\) and \(\mathbf{R}\) are unknowns we want to find out from:</p>
<p><img src="./assets/04-27.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{c}\) 代表质心，即前面的 \(\mathbf{x}\)<br />
✅ 约束1：新的顶点位置与原顶点位置的距离尽量接近。<br />
✅ 约束2：\(\mathbf{R}\) 是旋转矩阵。<br />
✅ 很难通过定义目标函数来满足约束2，因此问题简化：用任意矩阵A代替需要满足旋转矩阵约束的\(R\)。<br />
✅ \(\sum Ar_i = A \sum r_i = 0\)，因此得出结论：约束前后质心位置不变<br />
❓ 优化之后的刚体可能还是与地面穿透的。</p>
</blockquote>
<p>P35</p>
<h3 id="更新质心速度"><a class="header" href="#更新质心速度">更新质心速度</a></h3>
<p><img src="./assets/04-28-1.png" alt="" /></p>
<blockquote>
<p>✅ 先假设 \(\mathbf{R}\) 是任意矩阵 \(\mathbf{A}\),再从中提取旋转成分<br />
✅ <a href="%5BTODO%5D">Polar Decomposition</a>：极性分解，把任意矩阵分解旋转部分和形变部分。</p>
</blockquote>
<p>P36</p>
<p>结论：<br />
\(A^TA=S^TS=S^2\)<br />
\(R=AS^{-1}\)</p>
<p>P39</p>
<h3 id="shape-matching-pipeline"><a class="header" href="#shape-matching-pipeline">Shape Matching Pipeline</a></h3>
<p><img src="./assets/04-33.png" alt="" /> </p>
<p><img src="./assets/04-34.png" alt="" /> </p>
<p><img src="./assets/04-35.png" alt="" /> </p>
<p>Physical quantities are attached to each vertex, not to the entire body.</p>
<p>P40</p>
<h2 id="算法分析"><a class="header" href="#算法分析">算法分析</a></h2>
<ul>
<li>
<p>优点：Easy to implement and compatible with other nodal systems, i.e., cloth, soft bodies and even particle fluids.</p>
</li>
<li>
<p>局限性：Difficult to strictly enforce friction and other goals. The rigidification process will destroy them.</p>
</li>
<li>
<p>适用场景：More suitable when the <strong>friction accuracy is unimportant</strong>, i.e., buttons on clothes.</p>
</li>
</ul>
<p>P41</p>
<h2 id="after-class-reading-2"><a class="header" href="#after-class-reading-2">After-Class Reading</a></h2>
<p>Muller et al. 2005.<br />
<em>Meshless Deformations Based on Shape Matching</em>. TOG (SIGGRAPH).</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P27</p>
<h1 id="continuous-collision-response"><a class="header" href="#continuous-collision-response">Continuous Collision Response</a></h1>
<blockquote>
<p>✅ 发现碰撞的pairs后如何处理。</p>
</blockquote>
<p>P28</p>
<h2 id="interior-point-methods-and-impact-zone-optimization"><a class="header" href="#interior-point-methods-and-impact-zone-optimization">Interior Point Methods and Impact Zone Optimization</a></h2>
<blockquote>
<p>✅ 这是两个大的套路，不是具体的方法。</p>
</blockquote>
<p>Given the calculated next state \(\mathbf{x} ^{[1]}\), we want to update it into \(\bar{\mathbf{x} } ^{[1]}\), such that the path from \(\mathbf{x} ^{[0]}\) to \(\bar{\mathbf{x} } ^{[1]}\) is intersection-free.</p>
<p><img src="./assets/09-20.png" alt="" /></p>
<blockquote>
<p>✅ 整个图代表刚体的状态空间而不是位置空间。<br />
✅ 每个小圆点代表一个刚体状态，而不是一个粒子。<br />
✅ \(\mathbf{x} \) 是刚体状态的表示符，至少包含质心的状态和旋转信息。</p>
</blockquote>
<table><thead><tr><th></th><th>内点法</th><th>Impact Zone 法</th><th></th></tr></thead><tbody>
<tr><td></td><td>✅ 从\(\mathbf{x}^{[0]}\)出来，朝\(\mathbf{x}^{[1]}\)走，并永远保证只在安全区域走，直到不能走为止。</td><td>✅ 从\(\mathbf{x}^{[1]}\)出发，反复优化结果（投影），直到回到安全区域为止。</td><td>✅ 蓝色区域为安全区域</td></tr>
<tr><td>优点</td><td>Always succeed</td><td>Fast. <br> 1. Close to solution. <br> 2. Only vertices in collision (impact zones). <br> 3. Can take large step sizes.</td><td>✅ Impact Zone：1. \(\mathbf{x}^{[1]}\)通常离安全区域不太远，且优化时只针对 Impact Zone 优化，因此快。<br> 2. 只有\(\mathbf{x}\)不在安全区域时才需要做。 <br>  ✅ 内点：哪怕\(\mathbf{\bar{x}}^{[1]}\)最终没有到最佳位置，但能保证一定在安全区域，因此一定成功。</td></tr>
<tr><td>局限性</td><td>Slow.  <br> 1. Cautiously by small step sizes. <br> 2. Far from solution. <br> 3. All of the vertices.</td><td>May not succeed.</td><td>✅ 内点：1. 为保证每一步安全，步长不能太大，因此慢。<br> 2. \(\mathbf{x}^{[0]}\)和\(\mathbf{x}^{[1]}\)可能比较远，也导致慢。 <br> 3. 每一次都必须要做</td></tr>
</tbody></table>
<p>P30</p>
<h2 id="log-barrier-interior-point-methods"><a class="header" href="#log-barrier-interior-point-methods">Log-Barrier Interior Point Methods</a></h2>
<h3 id="算法过程"><a class="header" href="#算法过程">算法过程</a></h3>
<p>For simplicity, let’s consider the Log-barrier repulsion between two vertices.</p>
<p>$$E(\mathbf{x} )=−\rho \text{ log} ||\mathbf{x} _{ij}||$$</p>
<p>$$
\mathbf{f} _i(\mathbf{x} )=−∇_iE=ρ\frac{\mathbf{x} _ {ij}}{||\mathbf{x} _ {ij}||^2} \\
\mathbf{f} _j(\mathbf{x} )=−∇_jE=−ρ\frac{\mathbf{x} _ {ij}}{||\mathbf{x} _{ij}||^2}
$$</p>
<p>[TODO]<br />
$$
\frac{\alpha ||\mathbf{x}|| }{\alpha \mathbf{x}} =\frac{\mathbf{x}^\mathbf{T} }{||\mathbf{x}||} 
$$</p>
<blockquote>
<p>✅ 用 Log 定义能量、前面某一节课讲过。距离 → 能量 → 斥力<br />
❓ \(||\mathbf{x}_{ij}|| \) 的物理含义没有定义。可能是希望两个三角形之间穿透矩离。\( \mathbf{x}\) 代表两个刚体的状态。</p>
</blockquote>
<p><img src="./assets/09-23.png" alt="" /></p>
<blockquote>
<p>✅ 不需要互斥力一直存在，因此做了一个截断（IPC）</p>
</blockquote>
<p>P31</p>
<h3 id="算法实现"><a class="header" href="#算法实现">算法实现</a></h3>
<p>We can then formulate the problem as:</p>
<p>$$
\bar{\mathbf{x} }^ {[1]}\longleftarrow \mathrm{argmin} _\mathbf{x} (\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2−ρ\sum \mathrm{log} ||\mathbf{x} _{ij}||)
$$</p>
<blockquote>
<p>✅ 优化目标：点的位置与目标位置（穿模）尽量接近，且不穿模。<br />
✅ 绿色是来自\(\mathbf{x}^{[1]}\)的引力，对应公式第1页。黄色是来自边界的斥力对应公式第2页。</p>
</blockquote>
<p><img src="./assets/09-24.png" alt="" /></p>
<p>Gradient Descent:</p>
<blockquote>
<p>\(\mathbf{x} ^{(0)}\longleftarrow \mathbf{x} ^{[0]}\)<br />
For \(k=0…K\)<br />
$$\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+α(\mathbf{x} ^{[1]}−\mathbf{x} ^{(k)}+ρ\sum \frac{\mathbf{x} _{ij}}{||\mathbf{x} _{ij}||^2})$$ 
\(\bar{\mathbf{x} }^ {[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
</blockquote>
<blockquote>
<p>✅ <strong>每走一小步都需要反复的碰撞检测，重新计算</strong>\(||\mathbf{x} _{ij}||\)。<br />
✅ 关键是步长\(\alpha \)</p>
</blockquote>
<p>The step size \({\color{Red} α}\) must be adjusted to ensure that no collision happens on the way.  To find \({\color{Red} α}\), <strong>we need collision tests</strong>.</p>
<p>[❓] \( \alpha \) 不是 learning rate 吗？为什么碰撞检测的结果会影响到\( \alpha \) ？</p>
<p>P32</p>
<h2 id="impact-zone-optimization"><a class="header" href="#impact-zone-optimization">Impact Zone Optimization</a></h2>
<p>The goal of impact zone optimization is to optimize \(\mathbf{x}^{[1]}\) until it becomes intersection-free. (This potentially suffers from the tunneling issue, but it’s uncommon.)</p>
<blockquote>
<p>tunneling issue 是指：\(\mathbf{x} ^{[1]}\) 离两个安全区都比较近。\(\mathbf{x} ^{[0]}\) 在其中一个安全区，而\(\mathbf{x} ^{[1]}\) 被优化到了另一个安全区。表现出的现象为穿透。</p>
</blockquote>
<p>目标优化：</p>
<p>$$
\bar{\mathbf{x} }^{[1]}\longleftarrow \mathrm{argmin} _\mathbf{x}  \frac{1}{2} ||\bar{\mathbf{x} }-\mathbf{x}^{[1]}||^2
$$</p>
<p>约束：</p>
<p>$$
\text{such that}
\begin{cases}
C(\mathbf{x} )=−(\mathbf{x} _3−b_0\mathbf{x} _0−b_1\mathbf{x} _1−b_2\mathbf{x} _1)\cdot \mathbf{N} ≤0 &amp; \text{ For each detected vertex-triangle pair }  \\
C(\mathbf{x} )=−(b_2\mathbf{x} _2+b_3\mathbf{x} _3−b_0\mathbf{x} _0−b_1\mathbf{x} _1)\cdot \mathbf{N}≤0 &amp; \text{ For each detected edge-edge pair }
\end{cases}
$$</p>
<p><img src="./assets/09-25.png" alt="" /></p>
<h3 id="无约束优化问题"><a class="header" href="#无约束优化问题">无约束优化问题　　　</a></h3>
<p>这是一个带约束优化问题。　　　  Ⓐ</p>
<p>P36</p>
<p>We can then convert it into an unconstrained form:</p>
<p>$$\bar{\mathbf{x} } {[1]}\longleftarrow \text{argmin}_{x,λ}(\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2+\frac{ρ}{2} ||\text{max}(\tilde{C}  (\mathbf{x} ))||^2−\frac{1}{2ρ}||\mathbf{λ} ||^2)
$$</p>
<p>$$
\tilde{C}  (\mathbf{x})= \text{max}(\mathbf{C} (\mathbf{x} )+\mathbf{λ} /ρ)
$$</p>
<p>Augmented Lagrangian:</p>
<blockquote>
<p>\(\mathbf{x} ^{(0)} \longleftarrow \mathbf{x} ^{[0]}\)<br />
\(\mathbf{λ \longleftarrow 0} \)<br />
For \(k=0…K\)<br />
$$\mathbf{x} ^{(k+1)} \longleftarrow \mathbf{x} ^{(k)}−α∇(\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2+\frac{ρ}{2} ||\text{max}(\tilde{C} (\mathbf{x} ))||^2−\frac{1}{2ρ}||\mathbf{λ} ||^2)$$<br />
\(λ\longleftarrow ρ\tilde{C} (\mathbf{x} )\)<br />
\(\bar{\mathbf{x} } ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
</blockquote>
<p>Tang et al. 2018. I-Cloth: <em>Incremental Collision Handling for GPU-Based Interactive Cloth Simulation</em>. TOG. (SIGGRAPH Asia)</p>
<p>P37</p>
<h3 id="about-impact-zone-optimization"><a class="header" href="#about-impact-zone-optimization">About Impact Zone Optimization</a></h3>
<ul>
<li>
<p>Fast per iteration</p>
<ul>
<li>Only have to deal with vertices in collision.</li>
</ul>
</li>
<li>
<p>Convergence sensitive to \(||\mathbf{x} ^{[0]}−\mathbf{x} ^{[1]}||^2\), or the time step \(∆t\)</p>
<ul>
<li>Can take many iterations to, or never achieve <em>intersection-free</em>.</li>
<li>Easy solution is to reduce \(∆t\), but that increases total costs.</li>
</ul>
</li>
</ul>
<p><img src="./assets/09-28.png" alt="" /></p>
<p>P33</p>
<p><img src="./assets/09-26.png" alt="" /></p>
<p>Every pair gives new positions to the involved vertices.  We can combine them together in a Jacobi, or Gauss-Seidel fashion, just like position-based dynamics.</p>
<p>P34</p>
<h3 id="after-class-reading-cont"><a class="header" href="#after-class-reading-cont">After-Class Reading (Cont.)</a></h3>
<p>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact
and Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</p>
<p>Relative simple explicit integration of cloth dynamics</p>
<p>P38</p>
<h2 id="rigid-impact-zones"><a class="header" href="#rigid-impact-zones">Rigid Impact Zones</a></h2>
<p>The rigid impact zone method simply freezes vertices in collision from <strong>moving in their pre-collision state</strong>. It’s simple and safe, but has noticeable artifacts.</p>
<p><img src="./assets/09-29.png" alt="" /></p>
<blockquote>
<p>✅ 检测到碰撞，则把这个区域退回到上一帧。</p>
</blockquote>
<p>P39</p>
<h2 id="a-practical-system-summary"><a class="header" href="#a-practical-system-summary">A Practical System Summary</a></h2>
<p><img src="./assets/09-30.png" alt="" /></p>
<blockquote>
<p>✅ 有碰撞，先做 Impact Zone. 因为这个快、不能解决再用后面方法、计算量不允许则选择 Rigid Impact.</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="补充1-cross-product-as-a-matrix-product"><a class="header" href="#补充1-cross-product-as-a-matrix-product">补充1： Cross Product as a Matrix Product</a></h1>
<p>We can convert the cross product \(\mathbf{r}\times\) into a matrix product \(\mathbf{r}^*\).</p>
<p><img src="./assets/04-23.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{r}^*\) 是 \(\mathbf{r}\) 的 cross matrix.<br />
目的：用矩阵形式代替叉乘形式，方便公式化简</p>
</blockquote>
<h1 id="补充2极性分解"><a class="header" href="#补充2极性分解">补充2：极性分解</a></h1>
<h3 id="极性分解"><a class="header" href="#极性分解">极性分解</a></h3>
<p>Singular value decomposition says any matrix can be decomposed into: rotation,scaling and rotation: \(\mathbf{A = UDV} ^T\).</p>
<p><img src="./assets/04-29.png" alt="" /></p>
<p>We can rotate the object back before the final rotation: \(\mathbf{A}  = (\mathbf{UV} ^T)(\mathbf{VDV} ^T)\).</p>
<p><img src="./assets/04-31.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{A} = （\mathbf{UV}^T）(\mathbf{VDV}^T) =\mathbf{RS}\)<br />
\(\mathbf{R}\) 代表全局旋转，\(\mathbf{S}\)代表本地形变，扔掉S保留R。</p>
</blockquote>
<p><img src="./assets/04-32.png" alt="" /></p>
<p>$$
\mathbf{A=RS} 
$$</p>
<p>$$
\mathbf{A} ^T\mathbf{A}  = \mathbf{S} ^T\mathbf{S}  = \mathbf{S} ^2
$$</p>
<p>分解结果:unique</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P47</p>
<h1 id="a-summary-for-the-day"><a class="header" href="#a-summary-for-the-day">A Summary For the Day</a></h1>
<ul>
<li>
<p>Collision handling involves two steps: <em>collision detection</em> and <em>collision response</em>.</p>
</li>
<li>
<p>Collision detection contains two phases: <em>broad-phase culling</em> and <em>narrow-phase test</em>.</p>
</li>
<li>
<p>There are two types of collision detection tests: <em>discrete</em> and <em>continuous</em>.</p>
</li>
<li>
<p>Similarly, there are discrete and continuous collision responses.</p>
</li>
<li>
<p>For continuous collision responses, we must update the state to become collisionfree state. There are two approaches: <em>interior point method</em> and <em>impact zone optimization</em>. <strong>Rigid impact zone is also a method, but it’s problematic</strong>.</p>
</li>
<li>
<p>For discrete collision responses, we allow intersections to stay and hope to remove them in long turn. <strong>Cloth-cloth intersections are difficult to handle</strong>.</p>
</li>
</ul>
<blockquote>
<p>✅ 如果考虑摩擦，通常把摩擦做为后处理，但这样结果不精确。如果同时处理摩擦和碰撞、会很复杂。<br />
✅Impulse方法的碰撞检测通常用SDF．但很多形变体无法使用SDF.<br />
✅Impulse响应方式是离散响应方式，无法处理穿透问题。<br />
✅碰撞问题通常不使用物理方法，因为使用物理方法需要小步长，效率非常低。<br />
✅碰撞开源代码：bullet. physics X</p>
</blockquote>
<p>[TODO]调整章节顺序</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="topics-for-the-day-1"><a class="header" href="#topics-for-the-day-1">Topics for the Day</a></h1>
<ul>
<li>A Mass-Spring System
<ul>
<li>Explicit Integration</li>
<li>Implicit Integration</li>
</ul>
</li>
<li>Bending and Locking Issues</li>
<li>Shape matching</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="弹簧结构"><a class="header" href="#弹簧结构">弹簧结构</a></h1>
<h2 id="an-ideal-spring"><a class="header" href="#an-ideal-spring">An Ideal Spring</a></h2>
<p>An ideal spring satisfies Hooke’s law: the spring force tries to restore the rest length.</p>
<p><img src="./assets/05-1.png" alt="" /> </p>
<p><img src="./assets/05-2.png" alt="" /></p>
<p>\(E(\mathbf{x})=\frac{1}{2}k (||\mathbf{x}_i −\mathbf{x}_j||−\mathbf{L} )^2\)</p>
<p>\(\mathbf{f} _i(\mathbf{x} )=−∇_i\mathbf{E} =−k(||\mathbf{x}_i −\mathbf{x}_j||−L)\frac{\mathbf{x}_i −\mathbf{x}_j}{||\mathbf{x}_i −\mathbf{x}_j ||}\)</p>
<p>\(\mathbf{f} _j(\mathbf{x})=−∇_jE=−k (||\mathbf{x}_j −\mathbf{x}_i ||−L)\frac {\mathbf{x}_j −\mathbf{x}_i}{||\mathbf{x}_j −\mathbf{x}_i||}\)</p>
<p>P5</p>
<h2 id="multiple-springs"><a class="header" href="#multiple-springs">Multiple Springs</a></h2>
<p>When there are many springs, the energies and the forces can be simply summed up.</p>
<p><img src="./assets/05-3.png" alt="" /></p>
<p>$$
E= {\textstyle \sum_{e=0}^{3}}E_e= {\textstyle \sum_{e=0}^{3}} (\frac{1}{2} k(||\mathbf{x} _i −\mathbf{x}_e ||−L_e)^2)
$$</p>
<p>$$
f_i=−\nabla_iE = \textstyle \sum_{e=0}^{3}(−k(||\mathbf{x}_i−\mathbf{x}_e||−L_e)\frac{\mathbf{x}_i−\mathbf{x}_e}{||\mathbf{x}_i−\mathbf{x}_e||})
$$</p>
<blockquote>
<p>✅ 能量和力都是可以叠加的</p>
</blockquote>
<p>P6</p>
<h2 id="structured-spring-networks"><a class="header" href="#structured-spring-networks">Structured Spring Networks</a></h2>
<p><img src="./assets/05-4.png" alt="" /></p>
<blockquote>
<p>✅ 绿线：防止斜方向的拉伸。蓝线：防止翻折。</p>
</blockquote>
<p>P7</p>
<h2 id="unstructured-spring-networks"><a class="header" href="#unstructured-spring-networks">Unstructured Spring Networks</a></h2>
<p>We can also turn an unstructured triangle mesh into a spring network for simulation.</p>
<p><img src="./assets/05-5.png" alt="" /></p>
<blockquote>
<p>✅ 蓝线：抵抗弯曲。对每条内部边，加这样一根弹簧。</p>
</blockquote>
<p>P8</p>
<h3 id="怎样基于三角形mesh增加蓝线弹簧"><a class="header" href="#怎样基于三角形mesh增加蓝线弹簧">怎样基于三角形Mesh增加蓝线弹簧</a></h3>
<p>The basic representation of a triangle mesh uses vertex and triangle lists. </p>
<p><img src="./assets/05-6.png" alt="" /></p>
<blockquote>
<p>✅ 已知边的信息，需找出内部边，例如\(\mathbf{x}_0\mathbf{x}_3\)，因此要基于此构造边：\(\mathbf{x}_1x 4\)<br />
✅ Each triangle has three edges. But there are repeated ones. Repeated edges就是内部边。<br />
✅ 1. 找出内部边。2. 找出内部边所属于的两个三角形。3.  找出两个三角形上不在这条内部边上的点。4. 连续一根弹簧。</p>
</blockquote>
<p>Vertex list: {\(\mathbf{x} _0, \mathbf{x}_1, \mathbf{x}_2, \mathbf{x}_3, \mathbf{x}_4\)}    (3D vectors)</p>
<p>Triangle list: {1, 2, 3, 0, 1, 3, 0, 3, 4}    (index triples)</p>
<p>The key to topological construction is to sort triangle edge triples.</p>
<p>Each triple contains: edge vertex index 0, edge vertex index 1 and triangle index (index 0&lt;index). </p>
<p><img src="./assets/05-8.png" alt="" /></p>
<blockquote>
<p>✅ 排序：基于边排序，排序后相同边会靠在一起</p>
</blockquote>
<p>P11</p>
<h1 id="积分系统"><a class="header" href="#积分系统">积分系统</a></h1>
<h2 id="explicit-integration-of-a-mass-spring-system"><a class="header" href="#explicit-integration-of-a-mass-spring-system">Explicit Integration of A Mass-Spring System</a></h2>
<p><img src="./assets/05-9.png" alt="" /></p>
<blockquote>
<p>✅ 整体流程跟刚体运动很像，只是力变得复杂，每个弹簧端点上受到的力都要考虑，但没有了旋转。<br />
✅ \( E [e] [0] ：e\)代表弹簧 ID:0或1代表弹簧两个端点<br />
❗ 图画得不对，先提前把所有的力都算出来，再遍历所有顶点</p>
</blockquote>
<p>P12</p>
<p>Explicit integration suffers from <strong>numerical instability</strong> caused by <u>overshooting</U>, when the stiffness \(k\) and/or the time step \(∆t\) is too large.</p>
<blockquote>
<p>✅ Explicit：当前力 → 当前速度 → 当前位置<br />
根据公式\(FΔt≈mv，vΔt≈Δx\)，如果\(Δt\)太大，会导致\(Δx\)太大，而导致overshooting。</p>
</blockquote>
<p><img src="./assets/05-10.png" alt="" /></p>
<p>A naive solution is to use a small \(∆t\) . But that slows down the simulation.</p>
<blockquote>
<p>✅ 解决方法：减小\(\Delta t\)。但这个方法不解决本质问题，且会降低整个模拟系统的效率<br />
✅ 本质上是\(Δt\)太大导致积分近似的结果与实际积分的结果有很大误差，\(k\)太大或\(Δt\)只是让这个问题更明显，减小\(k\)或\(Δt\)问题仍然存在。</p>
</blockquote>
<p>P13</p>
<h2 id="implicit-integration"><a class="header" href="#implicit-integration">Implicit Integration</a></h2>
<p>Implicit integration is a better solution to numerical instability.  The idea is to integrate both <strong>x</strong> and <strong>v</strong> implicitly.</p>
<blockquote>
<p>✅Explicit和Implicit都是用某个时刻的力代表整个\(Δt\)时间的力，就都会出现上述误差。<br />
区别在于，Explicit用当前力，往往使结果变大，产生爆炸，Implicit用未来力，往往使结果变小，产生消失。<br />
✅ 消失只是结果不对。但爆炸会让结果崩溃，这是最不可接受的问题。因此用隐式代替显式。</p>
</blockquote>
<h4 id="积分公式"><a class="header" href="#积分公式">积分公式</a></h4>
<p><img src="./assets/05-11.png" alt="" /></p>
<blockquote>
<p>✅ 下面公式1通过把上面公式1代入公式2得到。下面公式2通过把上面公式写反推得到。 </p>
</blockquote>
<p>消元得：<br />
<img src="./assets/05-12.png" alt="" /></p>
<p>Assuming that \(\mathbf{f}\) is <em>holonomic</em>, i.e., depending on \(\mathbf{x}\) only, our question is how to solve:<br />
$$
\mathbf{x} ^{[1]}=\mathbf{x}^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f} (\mathbf{x}^{[1]})
$$</p>
<blockquote>
<p>✅ holonomic：力的大小和方向只跟位置有关，跟速度无关。例如重力，弹力。那么 \(f\)可以写成关于位置的函数\(f(x)\)。<br />
✅ 但\(f(x)\)不一定是线性的。因此最后转化为解非线性方程的问题。未知量为\({x} ^{[1]}\)</p>
</blockquote>
<h4 id="积分求解转为优化问题"><a class="header" href="#积分求解转为优化问题">积分求解转为优化问题</a></h4>
<p>P14</p>
<p>\(\mathbf{x} ^{[1]} =\) argmin \(F(\mathbf{x})\quad\)  for   \(\quad F(\mathbf{x}) = \frac{1}{2∆t^2}||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_M^2+E(\mathbf{x} )\)</p>
<blockquote>
<p>✅ 前面方程解\({x} ^{[1]}\)等价于F(x)函数极小点。等价转换的推导在<strong>补充1</strong>。非线性方程问题为转化为优化问题。<br />
其中：\(\mathbf{M}\)对角矩阵，描述质量，\(3N \times 3N\)。\(\mathbf{x}\)为 \(3N\times 1\)矢量,描述顶点信息。\(E\) 为所有的力的能量。\(\mathbf{||x||_M^2=x^TMx} \)。<br />
✅ 只有保守力能用能量描述、非保守力（例如摩擦力）则不行。</p>
</blockquote>
<p>P18</p>
<h4 id="simulation-by-newtons-method"><a class="header" href="#simulation-by-newtons-method">Simulation by Newton’s Method</a></h4>
<blockquote>
<p>🔎 Newton-Raphson Method见补充2. 这里直接开始Newton方向本当前场景的应用。</p>
</blockquote>
<p>Specifically to simulation, we have:</p>
<p>$$
F (\mathbf{x} )=\frac{1}{2∆t^2}||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_\mathbf{M} ^2+\mathbf{E} (\mathbf{x} )
$$</p>
<p>$$
∇F(\mathbf{x}^{(k)})=\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})−\mathbf{f}(\mathbf{x}^{(k)})
$$</p>
<p>$$
\frac{∂^2F (\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} =\frac{1}{∆t^2} \mathbf{M} +\mathbf{H} (x^{(k)})
$$</p>
<p><img src="./assets/05-28.png" alt="" /></p>
<blockquote>
<p>❓ 每一个 step 都包含一次迭代优化、能做到实时？<br />
✅ 本节课所讲的套路：分析力 → 隐式积分 → 优化问题 → 更新，对弹簧系统、有限元、弹性体等各种物理模拟同样适用<br />
✅ 早期的方式不是用优化来做的，而是近似成线性问题后直接解方程组。这种方法相当于每一个Step做了一次牛顿法。</p>
</blockquote>
<p>P19</p>
<h4 id="solve-spring-hessian"><a class="header" href="#solve-spring-hessian">Solve Spring Hessian</a></h4>
<p>According to Lecture 2, Page 48,</p>
<blockquote>
<p>✅ 弹簧系统的H是由所有弹簧的H构成的。</p>
</blockquote>
<p><img src="./assets/05-17.png" alt="" /></p>
<blockquote>
<p>✅ \(H(x)\)的维度是\(3N \times 3N\)，N 是弹簧数。每个\(H_e\)的维度是\(3 \times 3\)。<br />
✅ 课后答疑：质点的质量可以不同吗？<br />
答：可以不同。先根据三角形的面积计算三角的质量，再把质量分配到各个顶点上。</p>
</blockquote>
<h2 id="positive-definiteness-of-hessian"><a class="header" href="#positive-definiteness-of-hessian">Positive Definiteness of Hessian</a></h2>
<blockquote>
<p>✅ \(H(x)\)的正定性由\(H_e\)的正定性决定。</p>
</blockquote>
<p>下面分析\(H_e\)的正定性：<br />
For any \(\mathbf{x} _{ij}, \mathbf{v} ≠0\),</p>
<p>$$
\mathbf{V}^\mathbf{T}\frac{{\mathbf{x} _{ij}\mathbf{x} _{ij}}^\mathbf{T} }{||\mathbf{x} _{ij}||^2}\mathbf{V}=||\frac{{\mathbf{x} _{ij}}^\mathbf{T} \mathbf{v} }{||\mathbf{x} _{ij}||}||^2&gt; 0
$$</p>
<p>$$
\mathbf{V} ^\mathbf{T} (\mathbf{I} -\frac{{\mathbf{x} _{ij}\mathbf{x} _{ij}}^\mathbf{T} }{||\mathbf{x} _{ij}||^2}) \mathbf{V} =\frac{||\mathbf{x} _{ij}||^2||\mathbf{v} ||^2-||{\mathbf{x} _{ij}}^\mathbf{T} \mathbf{v} ||^2}{||\mathbf{x} _{ij}||^2}\ge 0 
$$</p>
<blockquote>
<p>✅  \( \mathbf{x}_ {ij}\) 代表顶点\( \mathbf{x}_ {i}\)和顶点\( \mathbf{x}_ {j}\)的位置的差。<br />
✅ 最后一个公式分子满足柯西不等式<br />
✅ 结论：\(||x_{ij}||&lt; Le\). 代表弹簧处于压缩状态。此时 He 有可能非正定，但拉伸时一定正定。<br />
He 正定则\(H(x)\)半正定，此时弹簧系统有唯一解。</p>
</blockquote>
<p>P20<br />
When a spring is stretched, \(\mathbf{H} _e\) is s.p.d.; but when it’s compressed, \(\mathbf{H} _e\) may not be s.p.d.</p>
<p>As a result, \(\mathbf{H}(\mathbf{x})\) may not be s.p.d. (Lecture 2, Page 36).</p>
<p>\(\mathbf{A}\) may not be s.p.d. either.</p>
<p><img src="./assets/05-18.png" alt="" /></p>
<blockquote>
<p>✅ \(\Delta t\)越小，A越容易正定、弹簧系统越稳定。<br />
✅为什么要讨论\(H\)矩阵是否正定？答：\(H\)矩阵相当于二阶导，正定代表开口向上，有唯一最小值。<br />
✅ 但是A不正定，不代表没有唯一解。</p>
</blockquote>
<p>P22 </p>
<p>When a spring is compressed, the spring Hessian may not be positive definite. This means there can be multiple local minima (outcomes).</p>
<p><img src="./assets/05-19.png" alt="" /></p>
<table><thead><tr><th>Note: This issue occurs only in 2D and 3D. In 1D, \(E(x)=\frac{1}{2} k(x−L)^2\) and \({E}''(x)=k&gt;0\).</th></tr></thead><tbody>
</tbody></table>
<p>P23</p>
<h2 id="enforcement-of-positive-definiteness"><a class="header" href="#enforcement-of-positive-definiteness">Enforcement of Positive Definiteness</a></h2>
<ul>
<li>Nevertheless, some linear solvers can fail to work if the matrix \(\mathbf{A}\) in \(\mathbf{A}\Delta \mathbf{x}=\mathbf{b}\) is not positive definite.</li>
</ul>
<blockquote>
<p>✅ 不正定最大的问题不是解不唯一，因为解出任意一个解都能让模拟系统进行下去。<br />
非正定的主要问题，是数学计算上的不稳定，可能导致解不出来； </p>
</blockquote>
<ul>
<li>One solution is to simply drop the ending term, when \({\color{Orange}{ ||\mathbf{x} _{ij}||&lt;\mathbf{L} _e}}:\)</li>
</ul>
<p><img src="./assets/05-20.png" alt="" /></p>
<blockquote>
<p>✅ 简单粗爆的解决方法就是把后面这项删掉。</p>
</blockquote>
<ul>
<li>Other solutions exist. For example,</li>
</ul>
<blockquote>
<p>🔎 Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH)</p>
</blockquote>
<p>P24</p>
<h2 id="linear-solvers"><a class="header" href="#linear-solvers">Linear Solvers</a></h2>
<h3 id="the-jacobi-method"><a class="header" href="#the-jacobi-method">The Jacobi Method</a></h3>
<p>We can use the Jacobi method to solve \(\mathbf{A}∆\mathbf{x}  = \mathbf{b} \).</p>
<p><img src="./assets/05-21.png" alt="" /></p>
<p>The vanilla Jacobi method (\(α\) = 1) has a tight convergence requirement on \(\mathbf{A}\), i.e., being diagonal dominant.</p>
<p>The use of \(α\) allows the method to converget even when \(\mathbf{A}\) is positive definite only.</p>
<p>P25</p>
<h3 id="an-incomplete-summary"><a class="header" href="#an-incomplete-summary">An Incomplete Summary</a></h3>
<ul>
<li>Direct Solvers (LU, LDLT, Cholesky, …)
<ul>
<li>One shot, expensive but worthy if you need exact solutions.</li>
<li>Little restriction on \(\mathbf{A}\)</li>
<li>Mostly suitable on CPUs</li>
</ul>
</li>
</ul>
<blockquote>
<p>🔎  Intel MKL PARDISO</p>
</blockquote>
<ul>
<li>Iterative Solvers
<ul>
<li>Expensive to solve exactly, but controllable</li>
<li>Convergence restriction on \(\mathbf{A}\), typically positive definiteness</li>
<li>Suitable on both CPUs and GPUs</li>
<li>Easy to implement</li>
<li>Accelerable: Chebyshev, Nesterov, <u>Conjugate Gradient</u>…</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 课后答疑<br />
问题二：怎么加速？<br />
答：用 Jacobian 可以在 GPU 上加速、直接法比迭代法慢。<br />
问题三：共轭梯度<br />
共轭梯度的效率很大程度上取决于 precondition,但在GPU上能使用的precondition 比较受限、 CPU 上一般选择 Incomplete LU 分解。<br />
问题四：支持的维度<br />
直接法比较占内存，因此支持的维度不如迭代法大。</p>
</blockquote>
<p>P26</p>
<h3 id="the-jacobi-method-with-chebyshev-acceleration"><a class="header" href="#the-jacobi-method-with-chebyshev-acceleration">The Jacobi Method with Chebyshev Acceleration</a></h3>
<p>We can use the accelerated Jacobi method to solve \(\mathbf{A}∆\mathbf{x} =\mathbf{b} \).</p>
<blockquote>
<p>The Accelerated Jacobi Method<br />
\(∆\mathbf{x}  \longleftarrow \mathbf{0} \)<br />
last_\(∆\mathbf{x}  \longleftarrow \mathbf{0}\)<br />
For \(k=0\dots \mathbf{K}\)<br />
\(\mathbf{r}  \longleftarrow \mathbf{b} −\mathbf{A} ∆\mathbf{x}\)<br />
If \(||\mathbf{r} ||&lt;\omega \quad\)	break<br />
If  \(k=0	\quad\quad\quad \omega =1\)<br />
Else If \( k=1 \quad \quad\quad\omega =2/(2-\rho^2)\)<br />
Else \(\quad\quad\quad\omega =4/(4-\rho ^2\omega )\)<br />
old_\(∆ \mathbf{x} \longleftarrow ∆ \mathbf{x}\)<br />
\(∆\mathbf{x} ⟵∆\mathbf{x} +\mathbf{αD} ^{−1}\mathbf{r}\)<br />
\(∆\mathbf{x} \longleftarrow \omega ∆ \mathbf{x} +(1−\omega)\)last_∆\(\mathbf{x} <br>\)<br />
last_\(∆\mathbf{x} \longleftarrow \) old_\(∆\mathbf{x}\)</p>
</blockquote>
<table><thead><tr><th>\(\rho  (\rho &lt;1)\) is the estimated spectral radius of the iterative matrix.</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 这一页老师没讲</p>
</blockquote>
<p>P27</p>
<h1 id="after-class-reading-3"><a class="header" href="#after-class-reading-3">After-Class Reading</a></h1>
<p>Baraff and Witkin. 1998. Large Step in Cloth Simulation. SIGGRAPH.</p>
<p>One of the first papers using implicit integration.</p>
<p>The paper proposes to <strong>use only one Newton iteration</strong>, i.e., solving only one linear system. This practice is fast, but can fail to converge.</p>
<blockquote>
<p>✅这篇论文是衣服模拟的经典论文，第一个用隐式积分做衣服模型的论文。<br />
论文没有用弹簧系统，而是另一套模型。<br />
没有做非线性优化或解非线性方程，而是把非线性方程线性化，等价于做一次牛顿迭代。</p>
</blockquote>
<h1 id="补充1非线性方程求解"><a class="header" href="#补充1非线性方程求解">补充1：非线性方程求解</a></h1>
<p>求解的非线性方程如下，其中\({x} ^{[1]}\)是未知量。<br />
$$
\mathbf{x} ^{[1]}=\mathbf{x}^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f} (\mathbf{x}^{[1]})
$$</p>
<p>P14</p>
<p>$$
\mathbf{||x||_M^2=x^TMx} 
$$</p>
<blockquote>
<p>✅ Note that this is applicable to every system, not just a mass-spring system.</p>
</blockquote>
<p>把公式处理一下得，<br />
$$
x^{[0]}+Δtv^{[0]}+Δt^2M^{-1}f(x^{[1]})-x^{[1]}=0
$$
左右两边同时乘以\(\frac{M}{Δt^2}\)得<br />
$$
\frac{1}{Δt^2} M(x^{[1]}-x^{[0]}-Δtv^{[0]})-f(x^{[1]})=0
$$<br />
这里面唯一的未知量是\(x^{[1]}\)，定义函数
$$
y=\frac{1}{Δt^2} M(x-x^{[0]}-Δtv^{[0]})-f(x)
$$<br />
当\(x = x^{[1]}\) 时，\(y = 0\), 即 \(y(x^{[1]}) = 0\)<br />
从另一个角度讲， 
$$
\begin{eqnarray}
x^{[1]} &amp; =  \mathrm{argmin}&amp; F(x)\Rightarrow {F}' (x^{[1]}) &amp; = &amp; 0
\end{eqnarray}
$$<br />
因此, \({F}' (x) = y. \quad F(x) = \int ydx \)</p>
<h1 id="补充2newton-raphson-method"><a class="header" href="#补充2newton-raphson-method">补充2：Newton-Raphson Method</a></h1>
<h2 id="x是值的fx函数"><a class="header" href="#x是值的fx函数">x是值的F(x)函数</a></h2>
<p>The Newton-Raphson method, commonly known as Newton’s method, solves the optimization problem: \(x^{[1]}\) = argmin \(F(x)\).</p>
<p><img src="./assets/05-13.png" alt="" /></p>
<p>Given a current \(x^{(k)}\), we approximate our goal by: </p>
<p>$$
0={F}' (x)≈{F}'(x^{(k)})+{F}'' (x^{(k)})(x−x^{(k)})
$$</p>
<blockquote>
<p>✅ \(a = \min F(x)⇒ F'(a)= 0\)，\({F}' (x)\) 是非线性函数，直接解\({F}' (x)=0\) 很难解<br />
✅ 对\({F}'(x)\) 做一阶泰勒展开，保留到二阶项。<br />
假设\(x^{[k]}\)为任意已知值，就变成了解线性方程，很容易解出\(x\).<br />
因为\({F}'(x)\) 是一个近似的，\(x\) 也是一个近似解。但\(x^{[k]}\) 越接近真实解，\(x\) 也会越接近真实解。因此，选代是\(x^{[k]}\)和\(x\) 都不断逼近真实解的过程。<br />
✅ 普通的梯度下降是把\({F}' (x)\) 近似到一阶，牛顿法是近似到二阶，因此下降更快。</p>
</blockquote>
<p><img src="./assets/05-14.png" alt="" /></p>
<blockquote>
<p>✅ Overshooting 的本质：误差会积累和放大</p>
</blockquote>
<p>P16<br />
Newton’s method finds an extremum, but it can be a minimum or maximum.</p>
<p><img src="./assets/05-15.png" alt="" /></p>
<ul>
<li>At a minimum \(x^∗, {F}'' (x^∗)&gt;0\).</li>
<li>At a maximum \(x^∗, {F}''(x^∗)&lt;0\). </li>
<li>If \({F}''(x)&gt;0\) is everywhere, \(F(x)\) has no maximum.  \(=&gt; F(x)\) has only one minimum.</li>
</ul>
<blockquote>
<p>✅ \(F'(a)= 0,a\)  有可能是最大值或最小值，因此要判定解是否合理。判定方法： \({F}''(x)\)</p>
</blockquote>
<p>P17</p>
<h2 id="x是向量的fx函数"><a class="header" href="#x是向量的fx函数">x是向量的F(x)函数</a></h2>
<p>Now we can apply Newton’s method to: \(x^{[1]} \)= argmin \(F(x)\).
Given a current \(x^{(k)}\), we approximate our goal by: </p>
<p>$$
0=\nabla F( \mathbf{x}) ≈\nabla F (\mathbf{x} ^{(k)})+\frac{∂F ^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} (\mathbf{x−x} ^{(k)}) 
$$</p>
<p><img src="./assets/05-16.png" alt="" /></p>
<blockquote>
<p>✅ 按照 \(\Delta x\) 的更新公式，只需要用到\(F'(x)\) 和 \({F}''(x)\)， 不需要知道 \(F(x)\).<br />
✅ 此处\(x\)是向量，因此\(F'(x)\)是向量，\({F}''(x)\)是 Hession 矩阵</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P29</p>
<h1 id="the-bending-spring-issue"><a class="header" href="#the-bending-spring-issue">The Bending Spring Issue</a></h1>
<p>A <strong>bending</strong> spring offers <strong>little resistance</strong> when cloth is nearly planar, since its length barely changes.</p>
<p><img src="./assets/05-22.png" alt="" /></p>
<blockquote>
<p>✅黑线为三角形面片，每条边一根弹簧，并增加一根蓝线弹簧，构成弯曲弹簧，阻止两个面片弯折。<br />
存在的问题：小的弯折，弹簧长度几乎不变，抵抗弯曲的力量非常弱。（不适用于类似于纸的弯折效果）。</p>
</blockquote>
<p>P30</p>
<h2 id="a-dihedral-angle-model"><a class="header" href="#a-dihedral-angle-model">A Dihedral Angle Model</a></h2>
<p>A dihedral angle model defines bending forces as a function of \(\theta : \mathbf{f} _i=f (\theta )\mathbf{u} _i\).</p>
<blockquote>
<p>✅ Dihedarl Angel:二面角<br />
✅ 把弯曲的力写成关于二面角的函数</p>
</blockquote>
<p><img src="./assets/05-23.png" alt="" /></p>
<blockquote>
<p>✅ \(x_1, x_2, x_3, x_4\) 都会受到 bending force. 力的大小相同但方向不同，但都是关于二面角的函数。<br />
✅\(u_i\)：描述力的方向，与\(\theta\)大小无关。\(f(\theta)\)：描述力的大小，是关于\(\theta\)的函数。</p>
</blockquote>
<ul>
<li>
<p>First, \(\mathbf{u}_1\) and \(\mathbf{u}_2\) should be in the normal directions \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
<li>
<p>Second, bending <strong>doesn’t stretch the edge</strong>, so \(\mathbf{u}_4\)−\(\mathbf{u}_3\) should be orthogonal to the edge, i.e., in the span of \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
<li>
<p>Finally, \(\mathbf{u}_1+\mathbf{u}_2+\mathbf{u}_3+\mathbf{u}_4=\mathbf{0}\), which means \(\mathbf{u}_3\) and \(\mathbf{u}_4\) are in the span of \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
</ul>
<blockquote>
<p>✅ 合力为0。</p>
</blockquote>
<p>P31<br />
Conclusion:</p>
<p><img src="./assets/05-24.png" alt="" /></p>
<blockquote>
<p>✅ N是未归一化的 normal. N 的方向与 normal 相同。大小为三角形的面积。<br />
✅ 重要的不是结果，而是根据观察进行合理假设的思考过程。</p>
</blockquote>
<p>P32</p>
<p>Planar case:</p>
<p>$$
\mathbf{f} _i=k\frac{||\mathbf{E}||^2}{||\mathbf{N}_1||+||\mathbf{N}_2||} \sin(\frac{π−\theta}{2})\mathbf{u} _i
$$</p>
<p>Non-planar case:</p>
<p>$$
\mathbf{f} _i=k\frac{||\mathbf{E} ||^2}{||\mathbf{N} _1||+||\mathbf{N} _2||}(\sin(\frac{π−\theta}{2})-\sin(\frac{π−\theta_0}{2}))\mathbf{u}_i
$$</p>
<blockquote>
<p>✅ Non-planar case：不是指弯曲时的力，而是指静止状态(reference state)为非平面的场景下，弯曲为\(\theta\)时的力。\(\theta_0\)表示 reference state. 
✅ 老师没解释公式怎么来的<br />
🔎  Bridson et al. 2003. <em>Simulation of Clothing with Folds and Wrinkles</em>. SCA.<br />
✅ 此论文适合读完。除了弯曲模型，还有一些有意思的设计。</p>
</blockquote>
<p>Explicit integration.<br />
Derivative is difficult to compute.</p>
<blockquote>
<p>✅ 由于完全基于力而不考虑能量，适合用显式积分。</p>
</blockquote>
<p>P34</p>
<h2 id="a-quadratic-bending-model"><a class="header" href="#a-quadratic-bending-model">A Quadratic Bending Model</a></h2>
<blockquote>
<p>✅二面角方法是纯分析力的方法，比较复杂。此处是Bending issue的另一个方法。</p>
</blockquote>
<p>A quadratic bending model has two assumptions: 1) planar case; 2) little stretching.</p>
<p><img src="./assets/05-25.png" alt="" /></p>
<p>$$
E(\mathbf{x} )=\frac{1}{2} \begin{bmatrix}
\mathbf{x}_0 &amp; \mathbf{x}_1 &amp; \mathbf{x}_2 &amp; \mathbf{x}_3
\end{bmatrix}\mathbf{Q} \begin{bmatrix}
\mathbf{x}_0 \\
\mathbf{x}_1 \\
\mathbf{x}_2\\
\mathbf{x}_3
\end{bmatrix}
$$</p>
<p>$$
\mathbf{Q} =\frac{3}{\mathbf{A} _0+\mathbf{A} _1}\mathbf{qq^T}
$$</p>
<blockquote>
<p>✅ \({\mathbf{A} _0}\)和\({\mathbf{A} _1}\)是两个三角形在reference状态下的面积。</p>
</blockquote>
<p>$$
\mathbf{q} = \begin{bmatrix}
(\cot\theta _1+ \cot\theta _3)\mathbf{I} \\
(\cot\theta _0+ \cot\theta _2)\mathbf{I} \\
(-\cot\theta _0- \cot\theta _1)\mathbf{I} \\
(-\cot\theta _2- \cot\theta _3)\mathbf{I}
\end{bmatrix}
$$</p>
<p>\(\mathbf{I}\) is 3-by-3 identity.</p>
<blockquote>
<p>✅ \(\mathbf{Q}\)只与\(\mathbf{\theta}\)有关，因此是一个定值。</p>
</blockquote>
<p>It’s not hard to see that: \(E (\mathbf{x} )=\frac{3||\mathbf{q} ^\mathbf{T}\mathbf{x} ||^2}{2(A_0+A_1)}\).  Also, \(E (\mathbf{x} )=0\) when the triangles are flat.</p>
<blockquote>
<p>✅ \(\mathbf{q^T}\mathbf{x}\)在估算两个三角形的拉普拉斯，即两个三角的曲率、当两个三角形共面时， \(E(\mathbf{x})=0\)<br />
🔎 离散曲面的拉普拉斯，见GAMES102<br />
✅ \(E(\mathbf{x})\) 来自数学上曲率的推导，而不是来自物理意义的推导。<br />
✅ 问题：能量的思想能用在刚体上吗？<br />
答：这里的能量是弹性能量、刚体无弹性，因此也无所谓能量。</p>
</blockquote>
<h3 id="pros-of-the-quadratic-bending-model"><a class="header" href="#pros-of-the-quadratic-bending-model">Pros of The Quadratic Bending Model</a></h3>
<ul>
<li>Easy to implement:</li>
</ul>
<blockquote>
<p>✅ \(E(\mathbf{x})\)是关于\(\mathbf{x}\)的二次函数，很容易计算\(E(\mathbf{x})\)的一阶导（力）和二阶导\(\mathbf{H} \)</p>
</blockquote>
<p>$$
\mathbf{f} (\mathbf{x} )=−\nabla \mathbf{E} (x)= −\mathbf{Q} \begin{bmatrix}
\mathbf{x} _0\\
\mathbf{x} _1\\
\mathbf{x} _2 \\
\mathbf{x} _3
\end{bmatrix}
$$</p>
<p>$$
\mathbf{H} (\mathbf{x} )=\frac{∂^2E(\mathbf{x} )}{∂\mathbf{x} ^2}=\mathbf{Q} 
$$</p>
<ul>
<li>Compatible with implicit integration.</li>
</ul>
<h3 id="cons-of-the-quadratic-bending-model"><a class="header" href="#cons-of-the-quadratic-bending-model">Cons of The Quadratic Bending Model</a></h3>
<ul>
<li>No longer valid if cloth stretches much.</li>
</ul>
<blockquote>
<p>✅方法假设面料拉伸比较小，当面料拉伸太大，\(\mathbf{\theta}\)就会改变，\(\mathbf{Q}\)就不准了。</p>
</blockquote>
<ul>
<li>Not suitable if the rest configuration is not planar.
<ul>
<li>Cubic shell model.</li>
<li>Projective dynamics model.</li>
</ul>
</li>
</ul>
<h3 id="after-class-reading-4"><a class="header" href="#after-class-reading-4">After Class Reading</a></h3>
<blockquote>
<p>🔎 Bergou et al. 2006. <em>A Quadratic Bending Model for Inextensible Surfaces</em>. SCA.<br />
✅ 这篇论文是在本算法上的进一步工作。</p>
</blockquote>
<p>P37</p>
<h1 id="the-locking-issue"><a class="header" href="#the-locking-issue">The Locking Issue</a></h1>
<p>So far we talked about the mass-spring model and other bending models, <strong>assuming cloth planar deformation and cloth bending deformation are independent</strong>.</p>
<p>Is it true? Think about a zero bending case. Can a simulator fold cloth freely?</p>
<blockquote>
<p>✅ 正常来讲拉伸和弯曲是两件独立的事情。但在弹簧模型系统中，把它们耦合了。<br />
例如纸这种无弹性的面料，会把它的弹性系数调得很大，达到无弹性的效果。但导致了它无法弯折的artifacts。<br />
✅ 在K很大或网格分辨率低时， locking issue 会特别明显。</p>
</blockquote>
<p>P38</p>
<p>The fundamental reason is due to a short of degrees of freedoms (DoFs).<br />
For a <u>manifold</u> mesh, Euler’s formula says:#edges=3#vertices-3-#boundary_edges.<br />
So if edges are all hard constraints, the DoFs are only: 3+ #boundary_edges.</p>
<blockquote>
<p>✅ 自由度 = 变量数 - 约束数。<br />
每个顶点有3个自由度、每条边是一个约束，因此单纯加点不会改善，但让点变密可以改善<br />
✅ 实操套路：1. 弹簧压缩时让k比较小；2. 假设弹簧在一定长度范围内可自由活动，不受力，以上方法都不解决根本问题；3. 把自由度定义在边上不­是顶点上，但把问题搞得更复杂了。</p>
</blockquote>
<p>P43</p>
<h1 id="a-summary-for-the-day-1"><a class="header" href="#a-summary-for-the-day-1">A Summary For the Day</a></h1>
<ul>
<li>
<p>A mass-spring system</p>
<ul>
<li>Planar springs against stretching/compression	\(\quad\)- replaceable by co-rotational model</li>
<li>Bending springs				\(\quad\)- replaceable by dihedral or quadratic bending</li>
<li>Regardless of the models, as long as we have \(E (\mathbf{x})\), we can calculate force \(\mathbf{f} (\mathbf{x} )=−∇ \mathbf{E} (\mathbf{x})\) and Hessian \(\mathbf{H} (\mathbf{x} )=∂E^2(\mathbf{x} )/∂\mathbf{x} ^2\).  Forces and Hessians are stackable.</li>
</ul>
</li>
<li>
<p>Two integration approaches</p>
<ul>
<li>Explicit integration, just need force.  Instability</li>
<li>Implicit integration, as a nonlinear optimization problem</li>
<li>One way is to use Newton’s method, which solves a linear system in every iteration:</li>
</ul>
</li>
</ul>
<p>$$
(\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} (\mathbf{x} ^{(k)}))∆\mathbf{x} =− \frac{1}{∆t^2} \mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})
$$</p>
<ul>
<li>There are a variety of linear solvers (beyond the scope of this class).</li>
<li>Some simulators choose to solve only one Newton iteration, i.e., one linear system per time step.</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P39</p>
<h1 id="shape-matching-1"><a class="header" href="#shape-matching-1">Shape Matching</a></h1>
<blockquote>
<p>✅ Shape Matching 跳过了。</p>
</blockquote>
<p>P40</p>
<h2 id="shape-matching-2"><a class="header" href="#shape-matching-2">Shape Matching</a></h2>
<p>The basic idea is to define a quadratic energy based on the rotated reference element. To do so, we split transformation into deformation + rotation.</p>
<p><img src="./assets/05-26.png" alt="" /></p>
<p>P41</p>
<h2 id="shape-matching-3"><a class="header" href="#shape-matching-3">Shape Matching</a></h2>
<p>The basic idea is to define a quadratic energy based on the rotated reference element. To do so, we split transformation into deformation + rotation.</p>
<p><img src="./assets/05-27.png" alt="" /></p>
<p>P42</p>
<h2 id="shape-matching-4"><a class="header" href="#shape-matching-4">Shape Matching</a></h2>
<p>We can then define the quadratic energy as:</p>
<p>$$
E (\mathbf{x} )=\frac{1}{2}||\mathbf{F−R} ||^2
$$</p>
<p>(\(\mathbf{R}\) is the rotation inside of \(\mathbf{F}\).  This energy tries to penalize the existence of \(\mathbf{S}\)).</p>
<p>Assuming that \(\mathbf{R}\) is constant, this \(E(\mathbf{x})\) becomes a quadratic function.  We can then derive the force and the Hessian.</p>
<p>$$
E(\mathbf{x} ) =\frac{1}{2} ||\begin{bmatrix}
\mathbf{x} _1-\mathbf{x} _0 &amp;\mathbf{x} _2-\mathbf{x} _0
\end{bmatrix}\begin{bmatrix}
\mathbf{r} _1-\mathbf{r} _0 &amp;\mathbf{r} _2-\mathbf{r} _0
\end{bmatrix}^{−1}−\mathbf{R}||^2
$$</p>
<p>P43</p>
<h1 id="a-summary-for-the-day-2"><a class="header" href="#a-summary-for-the-day-2">A Summary For the Day</a></h1>
<ul>
<li>
<p>A mass-spring system</p>
<ul>
<li>Planar springs against stretching/compression	\(\quad\)- replaceable by co-rotational model</li>
<li>Bending springs				\(\quad\)- replaceable by dihedral or quadratic bending</li>
<li>Regardless of the models, as long as we have \(E (\mathbf{x})\), we can calculate force \(\mathbf{f} (\mathbf{x} )=−∇ \mathbf{E} (\mathbf{x})\) and Hessian \(\mathbf{H} (\mathbf{x} )=∂E^2(\mathbf{x} )/∂\mathbf{x} ^2\).  Forces and Hessians are stackable.</li>
</ul>
</li>
<li>
<p>Two integration approaches</p>
<ul>
<li>Explicit integration, just need force.  Instability</li>
<li>Implicit integration, as a nonlinear optimization problem</li>
<li>One way is to use Newton’s method, which solves a linear system in every iteration:</li>
</ul>
</li>
</ul>
<p>$$
(\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} (\mathbf{x} ^{(k)}))∆\mathbf{x} =− \frac{1}{∆t^2} \mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})
$$</p>
<ul>
<li>There are a variety of linear solvers (beyond the scope of this class).</li>
<li>Some simulators choose to solve only one Newton iteration, i.e., one linear system per time step.</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="topics-for-the-day-2"><a class="header" href="#topics-for-the-day-2">Topics for the Day</a></h1>
<ul>
<li>Strain Limiting and Position Based Dynamics</li>
<li>Projective Dynamics</li>
<li>Constrained Dynamics</li>
</ul>
<p>P4</p>
<h1 id="the-stiffness-issue"><a class="header" href="#the-stiffness-issue">The Stiffness Issue</a></h1>
<ul>
<li>
<p>Real-world fabrics resist strongly to stretching, once they stretch beyond certain limits.</p>
</li>
<li>
<p>But, increasing the stiffness can cause problems.</p>
<ul>
<li>Explicit integrators will be <em>unstable</em>
<ul>
<li>Solution: smaller time steps and more <strong>computational time</strong>.</li>
</ul>
</li>
<li>The linear systems involved in Implicit integrators will be <em>ill-conditioned</em>.
<ul>
<li>Solution: more iterations and <strong>computational time</strong>.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Can we achieve high stiffness, with a low computational cost?</p>
</li>
</ul>
<blockquote>
<p>✅当弹簧系数大的情况下，仍能保证系统稳定。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="投影函数-projection-function"><a class="header" href="#投影函数-projection-function">投影函数 Projection Function</a></h1>
<p>P5</p>
<h2 id="a-single-spring"><a class="header" href="#a-single-spring">A Single Spring</a></h2>
<p>If a spring is infinitely stiff, we can treat the length as a constraint and define a projection function.</p>
<p><img src="./assets/06-1.png" alt="" /></p>
<p>\(\mathbf{ϕ} (\mathbf{x} )=||\mathbf{x} _i− \mathbf{x} _j||−L=0\)</p>
<blockquote>
<p>✅ projection function.投影函数、会移动端点使弹簧满足约束。</p>
</blockquote>
<p><img src="./assets/06-2.png" alt="" /></p>
<p>P6</p>
<p><img src="./assets/06-3.png" alt="" /></p>
<blockquote>
<p>✅ 把\(\mathbf{x}_ i\)和\(\mathbf{x}_ j\)拼成6维空间中的点\(\mathbf{x}\)，满足约束的\(\mathbf{x}\)构成6D空间中的一块区域；</p>
</blockquote>
<p>{\(\mathbf{x} _i^{\mathbf{new}},\mathbf{x} _j^{\mathbf{new} }\)}= argmin \( \frac{1}{2}\){\(m_i||\mathbf{x} _i^{\mathbf{new} }−\mathbf{x} _i||^2+m_j||\mathbf{x} _j^{\mathbf{new}} −\mathbf{x} _j||^2\)}</p>
<p>such that  \(\mathbf{ϕ} (\mathbf{x} )=0\)</p>
<blockquote>
<p>✅ 投影函数的目标：(1)把\(\mathbf{x}\)移到区域内。 (2)移动距离最短，因此构成优化问题。<br />
✅优化问题，但不是通过选代解决，而是数值求解，直接算出最优的\(\mathbf{x}_i\)和\(\mathbf{x}_j\).</p>
</blockquote>
<p>P7</p>
<p>$$
\mathbf{x} ^{\mathbf{new} } \longleftarrow  \mathrm{Projection} (\mathbf{x})
$$</p>
<p>$$
\mathbf{x} _i^{\mathbf{new} }\longleftarrow \mathbf{x} _i−\frac{m_j}{m_i+m_j} (||\mathbf{x} _i−\mathbf{x} _j||−L)\frac{\mathbf{x} _i−\mathbf{x}_j}{||\mathbf{x} _i−\mathbf{x} _j||} 
$$</p>
<p>$$
\mathbf{x} _j^{\mathbf{new} }\longleftarrow \mathbf{x} _j+\frac{m_i}{m_i+m_j} (||\mathbf{x} _i−\mathbf{x} _j||−L)\frac{\mathbf{x} _i−\mathbf{x}_j}{||\mathbf{x} _i−\mathbf{x} _j||} 
$$</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{ϕ} (\mathbf{x} ^{\mathbf{new} })=||\mathbf{x} _i^{\mathbf{new} }− \mathbf{x} _j^{\mathrm{new} }||−L=||\mathbf{x} _i−\mathbf{x} _j−\mathbf{x} _i+\mathbf{x} _j+L||−L=0
$$</p>
<blockquote>
<p>✅ 对推导结果的合理性解释：(1) 移到前后质心不变。(2) 移到方向为沿着或远离质心。(3) 移到距离与自身重量有关。</p>
</blockquote>
<p>By default, \(m_i=m_j\), but we can also set \(m_i=\infty\) for stationary nodes.</p>
<blockquote>
<p>✅ 对于固定点，不更新就好了。</p>
</blockquote>
<p>P8</p>
<h2 id="multiple-springs--a-gauss-seidel-approach"><a class="header" href="#multiple-springs--a-gauss-seidel-approach">Multiple Springs – A Gauss-Seidel Approach</a></h2>
<p>What about multiple springs? The Gauss-Seidel approach <strong>projects each spring sequentially in a certain order</strong>. Imagine two springs with unit rest lengths…</p>
<p><img src="./assets/06-4.png" alt="" /></p>
<p>P9</p>
<p><img src="./assets/06-22.png" alt="" /></p>
<ul>
<li>
<p>We cannot ensure the satisfaction of every constraint. But the more iterations we use, the better those constraints are satisfied.</p>
</li>
<li>
<p>Although the name is related to Gauss-Seidel, it differs from Gauss-Seidel. It is more relevant to stochastic gradient descent (in machine learning).</p>
</li>
<li>
<p>The order matters. The order can cause bias and affect convergence behavior.</p>
</li>
</ul>
<blockquote>
<p>✅顺序影响结果的偏向性和收敛速度。</p>
</blockquote>
<p>P10</p>
<h2 id="multiple-springs--a-jacobi-approach"><a class="header" href="#multiple-springs--a-jacobi-approach">Multiple Springs – A Jacobi Approach</a></h2>
<ul>
<li>
<p>To avoid bias, the Jacobi approach projects all of the edges <strong>simultaneously</strong> and then linearly blend the results.</p>
</li>
<li>
<p>The problem is an even lower convergence rate. </p>
</li>
<li>
<p>Again, the more iterations it uses, the better the constraints are enforced.</p>
<p><img src="./assets/06-23.png" alt="" /></p>
</li>
</ul>
<blockquote>
<p>✅ 基于每条边计算\(\mathbf{x}\)的更新但不真的更新、每个点会得到多种更新方案，最后取更新方案的均值。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="position-based-dynamics-pbd"><a class="header" href="#position-based-dynamics-pbd">Position Based Dynamics (PBD)</a></h1>
<h2 id="算法过程-1"><a class="header" href="#算法过程-1">算法过程</a></h2>
<p>Position based dynamics (PBD) is based on the projection function.</p>
<ul>
<li>
<p>The stiffness behavior, i.e., how tightly constraints are enforced, is subject to <strong>non-physical</strong> factors. </p>
<ul>
<li>The number of iterations </li>
<li>The mesh resolution</li>
</ul>
</li>
<li>
<p>The velocity update following projection is important to dynamic effects. </p>
</li>
<li>
<p>This method is applicable to other constraints as well, including triangle constraints, volume constraints, and collision constraints. </p>
<ul>
<li>To implement these constraints, simply define their
projection functions.</li>
</ul>
</li>
</ul>
<p>A PBD Simulator<br />
//Do Simulation, update \(\mathbf{x}\) and \(\mathbf{v}\)<br />
$$
\mathbf{v}\longleftarrow\dots
$$</p>
<p>$$
\mathbf{x}\longleftarrow\dots<br />
$$</p>
<blockquote>
<p>✅ 第一步：不考虑约束，基于粒子运动方法更新 \(\mathbf{v}\) 和 \(\mathbf{x}\)；</p>
</blockquote>
<p>//Now PBD starts.</p>
<p>$$
\mathbf{x} ^{\mathbf{new} } \longleftarrow \mathrm{Projection} (\mathbf{x} )
$$</p>
<p>$$
\mathbf{v}\longleftarrow \mathbf{v} +(\mathbf{x} ^{\mathbf{new} }−\mathbf{x})/∆t
$$</p>
<p>$$
\mathbf{x}\longleftarrow \mathbf{x} ^{\mathbf{new}}
$$</p>
<blockquote>
<p>✅ 第二步：基于约束和投影函数更新 \(\mathbf{v}\) 和 \(t\).<br />
✅第二步中速度更新很重要，会影响dynamic模拟的效果。<br />
✅\(\mathbf{v}\)的更新不是直接覆盖，而是叠加。</p>
</blockquote>
<p>P12</p>
<h2 id="pros-and-cons-of-pbd"><a class="header" href="#pros-and-cons-of-pbd">Pros and Cons of PBD</a></h2>
<ul>
<li>Pros
<ul>
<li>Parallelable on GPUs (PhysX)</li>
<li>Easy to implement</li>
<li>Fast in low resolutions</li>
<li>Generic, can handle other coupling and constraints, including fluids</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 一般来说，少于1000个点时能实时，多于1000个点时效率明显下降<br />
✅ PBD 适用于低分辨率场景、常见的低精度实时模拟的套路。<br />
❗ 模拟真正的时间开销不在计算 (虽然有很多计算公式) 而是在内存的访问上。<br />
PBD 的优点是内存访问少、因为它没有太多物理变量。<br />
因此，<strong>对追求效率的场景，主要优化内存访问而不是计算。</strong></p>
</blockquote>
<ul>
<li>Cons
<ul>
<li>Not physically correct</li>
<li>Low performance in high resolutions
<ul>
<li>Hierarchical approaches (can cause oscillation and other issues…)</li>
<li>Acceleration approaches, like Chebyshev</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 问：PBD 非物理方法，怎么体现出弹性效果？<br />
答：迭代数多则弹性差、网格顶点少则弹性差。<br />
✅ 弹性表现受网格数量影响(难以控制)、没有所谓的精确解，哪怕迭代数足够多、迭代数过多会导致locking issue.</p>
</blockquote>
<p>P13</p>
<h2 id="after-class-reading-5"><a class="header" href="#after-class-reading-5">After-Class Reading</a></h2>
<p>Muller. 2008. <em>Hierarchical Position Based Dynamics</em>. VRIPHYS.</p>
<blockquote>
<p>✅ NVIDIA的很多物理引擎都是基于PBD的</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P14</p>
<h1 id="strain-limiting"><a class="header" href="#strain-limiting">Strain Limiting</a></h1>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<p>Strain limiting aims at using the projection function for <strong>correction</strong> only. </p>
<p><img src="./assets/06-5.png" alt="" /></p>
<blockquote>
<p>✅ 投影函数作为模拟过程的后处理，防止模拟后产生大的形变，使模拟结果更稳定。</p>
</blockquote>
<table><thead><tr><th></th><th>PBD</th><th>Strain Limiting</th></tr></thead><tbody>
<tr><td>第一步</td><td>只考虑粒子运动，不考虑约束</td><td>模拟粒子运动、同时考虑约束</td></tr>
<tr><td>第二步</td><td>使粒子状态满足约束</td><td>校正，但约束较宽</td></tr>
</tbody></table>
<p>P15</p>
<h2 id="例一-spring-strain-limit"><a class="header" href="#例一-spring-strain-limit">例一： Spring Strain Limit</a></h2>
<p>We can set the spring strain, i.e., the stretching ratio σ, to be within a limit.</p>
<blockquote>
<p>✅ 这一页以弹簧为例子说明 Strain Limit<br />
✅ Strain：物理上描述形变的量，即本页的\(\sigma \)</p>
</blockquote>
<p><img src="./assets/06-6.png" alt="" /></p>
<p>$$
\sigma ^\mathrm{{min}}≤\frac{1}{L}||\mathbf{x} _i− \mathbf{x} _j||≤\sigma^\mathrm{{max}}
$$</p>
<blockquote>
<p>✅ 仅要求弹簧长度满足某不比例，不要求一定到达某个位置。</p>
</blockquote>
<p>Constraint</p>
<p><img src="./assets/06-7.png" alt="" /></p>
<p>P16</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{x}^{\mathbf{new}}\longleftarrow \mathrm{Projection}  (\mathbf{x} )
$$</p>
<p>$$
\sigma\longleftarrow \frac{1}{L}||\mathbf{x}_i− \mathbf{x}_j||
$$</p>
<blockquote>
<p>✅ 计算当前拉伸比</p>
</blockquote>
<p>$$
\sigma _0\longleftarrow \mathrm{min} (\mathrm{max} (\sigma,\sigma^{\mathrm{min} }),\sigma^{\mathrm{max} })
$$</p>
<blockquote>
<p>✅ 计算期望的拉伸比</p>
</blockquote>
<p>$$
\mathbf{x} _i^{\mathrm {new} }⟵\mathbf{x} _i−\frac{m_j}{m_i+m_j}(||\mathbf{x} _i− \mathbf{x} _j||−σ_0L)\frac{\mathbf{x} _i− \mathbf{x} _j}{||\mathbf{x} _i− \mathbf{x} _j||}
$$</p>
<p>$$
\mathbf{x} _j^{\mathrm {new} }⟵\mathbf{x} _j+\frac{m_j}{m_i+m_j}(||\mathbf{x} _i− \mathbf{x} _j||−σ_0L)\frac{\mathbf{x} _i− \mathbf{x} _j}{||\mathbf{x} _i− \mathbf{x} _j||}
$$</p>
<blockquote>
<p>✅ 用\(\sigma _0L\)代替原长\(L\)．</p>
</blockquote>
<p>\(\mathrm{PBD}: \sigma _0≡1;\quad\quad\)</p>
<blockquote>
<p>✅ PBD可以看作是Strain Limit的特例。</p>
</blockquote>
<p>No limit: \(\sigma ^{\mathrm{min} } = 0, σ^{\mathrm{max} } = \infty\)</p>
<blockquote>
<p>✅ Strain Limit 的应用场景：(1) 模拟布料：“拉伸到一定范围后变得非常 stiff” 的效果 (2) 防止“形变大发生数值不稳定”。</p>
</blockquote>
<p>P17</p>
<h2 id="例二triangle-area-limit"><a class="header" href="#例二triangle-area-limit">例二：Triangle Area Limit</a></h2>
<p>We can limit the triangle area as well. To do so, we define a scaling factor.</p>
<blockquote>
<p>✅这是另一个例子。希望顶点移动尽量少，因此定义约束：三角形面积变化在一定范围内。</p>
</blockquote>
<p>{\(\mathbf{x}_i^{\mathrm{new} },\mathbf{x}_i^{\mathrm{new} },\mathbf{x}_k^{\mathrm{new} }\)}  = \(\mathrm{argmin} \frac{1}{2} \){\(m_i||\mathbf{x}_i^{\mathrm{new} }−\mathbf{x}_i||^2+m_j||\mathbf{x}_j^{\mathrm{new} }−\mathbf{x}_j||^2+m_j||\mathbf{x}_k^{\mathrm{new} }−\mathbf{x}_k||^2\)} </p>
<p>such that the constraint is satisfied.</p>
<p><img src="./assets/06-8.png" alt="" /></p>
<blockquote>
<p>✅ strain s为面积的缩放量</p>
</blockquote>
<p>P18</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{x} ^{\mathbf{new}} ⟵\mathrm{Projection} (\mathbf{x} )
$$</p>
<p>$$
\mathbf{A}\longleftarrow \frac{1}{2} ||(\mathbf{x} _j− \mathbf{x} _i)\mathbf{×} (\mathbf{x}_k− \mathbf{x} _i)||
$$</p>
<blockquote>
<p>✅ 计算当前三角形的面积</p>
</blockquote>
<p>$$
\mathbf{s} \longleftarrow \sqrt{\mathrm{\mathrm{min}} (\mathrm{\mathrm{max}} (A,A^{\mathrm{min}}),A^{\mathrm{max}})/A}
$$</p>
<blockquote>
<p>✅ 计算期望的面积缩放比</p>
</blockquote>
<p>$$
\mathbf{c} \longleftarrow \frac{1}{m_i+m_j+m_k} (m_i\mathbf{x} _i+m_j\mathbf{x} _j+m_k\mathbf{x} _k)
$$</p>
<blockquote>
<p>✅ C为质心，要求缩放前后质心不变。数学上、质心不变，点的移动最少；物理上，质心变了代表物体运动了，scale 不应该导致物理运动。</p>
</blockquote>
<p>$$
\mathbf{x} _i^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _i−\mathbf{c} )
$$</p>
<p>$$
\mathbf{x} _j^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _j−\mathbf{c} )
$$</p>
<p>$$
\mathbf{x} _k^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _k−\mathbf{c} )
$$</p>
<blockquote>
<p>✅ 通过对顶点到质心的距离的缩放，得到顶点的新的位置</p>
</blockquote>
<p>P19</p>
<h2 id="strain-limiting在simulation中的作用"><a class="header" href="#strain-limiting在simulation中的作用">Strain Limiting在Simulation中的作用</a></h2>
<ul>
<li>
<p>Strain limiting is widely used in physics- based simulation, typically for avoiding instability and artifacts due to large deformation.</p>
</li>
<li>
<p>Strain limiting is useful for nonlinear effects, in a biphasic way.</p>
</li>
</ul>
<p><img src="./assets/06-9.png" alt="" /></p>
<blockquote>
<p>✅ 例如布料一般一开始抵抗比较小，拉到一定程度后抵抗迅速变大。对这种非线性的表现，可以把模拟分布两个阶段，前面用普通模拟，后面用strain limiting。</p>
</blockquote>
<ul>
<li>Strain limiting also helps address the <strong>locking issue</strong>.</li>
</ul>
<blockquote>
<p>✅两个阶段有不同的算法，针对两个阶段的不同特点，可以分别解决两个阶段的问题。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P22</p>
<h1 id="投影动力学-projective-dynamics"><a class="header" href="#投影动力学-projective-dynamics">投影动力学 (Projective Dynamics)</a></h1>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<blockquote>
<p>✅ PBD方法直接拿约束来修复顶点位置，没有物理含义。而Projective Dynatics把projection方法跟物拟模拟结合起来。<br />
✅ Projective Dynamics与PBD的差别主要体现在用约束来做什么。</p>
</blockquote>
<p>Projective Dynamics<strong>将约束转化为能量</strong>，通过最小化能量函数来求解系统的状态。因此是一种基于优化的物理仿真方法</p>
<h2 id="能量和力"><a class="header" href="#能量和力">能量和力</a></h2>
<p><img src="./assets/06-10.png" alt="" /></p>
<p>\(E(\mathbf{x} ) = {\textstyle \sum_{e = (i,j)}}\frac{1}{2} ||(\mathbf{x} _i−\mathbf{x} _j)−(\mathbf{x} _{e,i}^{\mathrm{new} }−\mathbf{x} _{e,j}^{\mathrm{new} })||^2\)</p>
<p>{\(\mathbf{x} _{e,i}^{\mathrm{new} },\mathbf{x} _{e,j}^{\mathrm{new} }\)} = \(\mathrm{Projection} _e(\mathbf{x}_i,\mathbf{x}_j)\) for every edge \(e\)</p>
<blockquote>
<p>✅ 本文基于约束定义能量。{\(\mathbf{x} _{e,i}^{\mathrm{new} },\mathbf{x} _{e,j}^{\mathrm{new} }\)}为期望的顶点位置。不直接把顶点从当前位置移到期望位置。而是把当前位置和期望位置的距离转化为能量，通过能量推动顶点从当前位置移到目标位置。</p>
</blockquote>
<p>$$
E(\mathbf{x})=\sum _{e=(i,j)}\frac{k}{2}(||\mathbf{x}_i-\mathbf{x}_j||-L_e)^2 
$$</p>
<p>$$
\mathbf{f} _i=−\nabla_iE(\mathbf{x} )=−{\textstyle \sum _{e:i\in e}}(\mathbf{x} _i−\mathbf{x} _j)−(\mathbf{x} _{e,i}^{\mathrm{new}} −\mathbf{x} _{e,j}^{\mathrm{new} })
$$</p>
<blockquote>
<p>✅ 基于 \(E(\mathbf{x})、\mathbf{x}_i^{\mathrm{new} } 、\mathbf{x}_j^{\mathrm{new} }\) 计算力，此时假设\(\mathbf{x}_i^{\mathrm{new} }\)和 \(\mathbf{x}_j^{\mathrm{new} }\)都是定值，\(\mathbf{x}_i\)和 \(\mathbf{x}_j\)是变量。<br />
✅ 本文基于约束定义能量和力，得到的结果与基于弹簧能量计算的能量和力相同。<br />
✅ 既然 \(E\) 和 \(F\) 是一样的，何必多此一举? 答：H不同。</p>
</blockquote>
<p>P23</p>
<h2 id="hessian-矩阵"><a class="header" href="#hessian-矩阵">Hessian 矩阵</a></h2>
<p>Instead of blending projections in a Jacobi or Gauss-Seidel fashion as in PBD, <u>projective</u> dynamics uses projection to define a <u>quadratic</u> energy.</p>
<p><img src="./assets/06-11.png" alt="" /></p>
<p><img src="./assets/06-12.png" alt="" /></p>
<blockquote>
<p>✅ 同一个顶点在三个不同边上的投影是不同的。<br />
✅ <strong>可以直接根据Mesh的拓扑关系构造H矩阵。</strong><br />
✅ 为什么能简化\(\mathbf{H}\)的计算？答：在计算某一个端点时，假设另一个端点不动（常量），那么能量就是只关于这个端点的二次函数</p>
</blockquote>
<p>P24</p>
<h2 id="shape-matching-5"><a class="header" href="#shape-matching-5">Shape Matching</a></h2>
<p>Shape matching is also projective dynamics, if we view rotation as projection:</p>
<p>|
<img src="./assets/06-15.png" alt="" /></p>
<table><thead><tr><th><strong>The 2D Space</strong></th><th><strong>The 3D Space</strong></th></tr></thead><tbody>
<tr><td><img src="./assets/06-013.png" alt="" /></td><td><img src="./assets/06-014.png" alt="" /></td></tr>
</tbody></table>
<p>Assuming that \(\mathbf{{\color{Orange} R} }\) is constant,<br />
$$
\begin{matrix}
\mathbf{f} _0=−\nabla_0E(\mathbf{x} )\\
\mathbf{f} _1=−\nabla_1E(\mathbf{x} ) \\
\mathbf{f} _2=−\nabla_2E(\mathbf{x} )\\
\mathbf{H} =\frac{∂E^2(\mathbf{x} )}{∂x^2} \quad \text{is  a constant !}<br />
\end{matrix}
$$</p>
<p>P25</p>
<h2 id="simulation-by-projective-dynamics"><a class="header" href="#simulation-by-projective-dynamics">Simulation by Projective Dynamics</a></h2>
<ul>
<li>
<p>According to implicit integration and Newton’s method, a projective dynamics simulator looks as follows, with matrix \(\mathbf{A} =\frac{1}{∆t^2}\mathbf{M+}\mathbf{H} \) being constant.</p>
</li>
<li>
<p>We can use a direct solver with <strong>only one factorization of A</strong>.</p>
</li>
</ul>
<blockquote>
<p>✅ 解线性系统的主要耗时在LU分解，而这个算法中\(\mathrm{H}\)是常数矩阵，只需要做一次LU分解，简化了对\(\mathrm{H}\)分解的计算量。</p>
</blockquote>
<p>Initialize  \(\mathbf{x} ^{(0)}\), often as\( \mathbf{x} ^{[0]} \)or \(\mathbf{x} ^{[0]} +∆t\mathbf{v} ^{[0]} \)</p>
<p>For \(k=0\dots K\)<br />
\(\quad\) Recalculate projection</p>
<blockquote>
<p>✅ 对于弹簧系统，Recaculate projection 这一步实际上不需要，因为直接用弹簧系统的公式算力，得到的\(f\)是一样的。<br />
✅ 如果是做 shape matching, 还是需要这一步，用于算 \(f\)</p>
</blockquote>
<p>\(\quad\) Solve \((\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} )∆\mathbf{x} =−\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})\)</p>
<p>\(\quad\) \(\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} \)</p>
<p>\(\quad\) If \(||∆\mathbf{x}||\) is small	\(\quad\) then break</p>
<p>\(\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
<p>\(\mathbf{v} ^{[1]}\longleftarrow (\mathbf{x} ^{[1]}-\mathbf{x} ^{[0]})/∆t\)</p>
<p>“Newton’s Method”</p>
<p>P26</p>
<h2 id="preconditioned-steepest-descent"><a class="header" href="#preconditioned-steepest-descent">Preconditioned Steepest Descent</a></h2>
<ul>
<li>Mathematically, this approach is preconditioned steepest descent, in which:</li>
</ul>
<p><img src="./assets/06-16.png" alt="" /></p>
<p>$$
F(\mathbf{x} )=\frac{1}{2∆t^2} ||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_\mathbf{M} ^2+E(\mathbf{x} )
$$</p>
<p>The performance depends on how well \(\mathbf{{\color{Orange} H} }\) approximates the real Hessian.</p>
<blockquote>
<p>✅\(\mathrm{H}\)不需要很精确，一个近似的正定的矩阵，就能让结果收敛。</p>
</blockquote>
<p>P27</p>
<h2 id="pros-and-cons-of-projective-dynamics"><a class="header" href="#pros-and-cons-of-projective-dynamics">Pros and Cons of Projective Dynamics</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>By building constraints into energy, the simulation now has a theoretical <u>solution</u> with <strong>physical</strong> meaning.</li>
<li><strong>Fast on CPUs</strong> with a direct solver. No more factorization!</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<blockquote>
<p>✅ Fast on CPU,因为它只作一次\(\mathbf{LU}\)分解。</p>
</blockquote>
<ul>
<li>Fast convergence in the first few iterations.</li>
<li><strong>Slow on GPUs</strong>. (GPUs don’t support direct solver wells.)</li>
</ul>
<blockquote>
<p>✅ Slow on GPU，因为\(\mathbf{LU}\)分解不适用于 \(\mathbf{GPU}\)</p>
</blockquote>
<ul>
<li>Slow convergence over time, as it fails to consider Hessian caused by projection.
<ul>
<li>Still suffering from high stiffness</li>
</ul>
</li>
<li>Cannot easily handle <strong>constraint changes</strong>.</li>
</ul>
<blockquote>
<p>✅ constraint changes: 网格关系改变导至弹簧结构改变，原来的\(\mathbf{H}\)将不再适用。<br />
- Contacts<br />
- Remeshing due to fracture, etc.</p>
</blockquote>
<blockquote>
<p>✅ 课后答疑：<br />
能量优化的方法很少用于刚体，主要是有限元、弹性体、衣服模拟。</p>
</blockquote>
<p>P28</p>
<h2 id="after-class-reading-6"><a class="header" href="#after-class-reading-6">After-Class Reading</a></h2>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2014</td><td>Projective Dynamics: Fusing Constraint Projections for Fast Simulation</td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P30</p>
<h1 id="constrained-dynamics"><a class="header" href="#constrained-dynamics">Constrained Dynamics</a></h1>
<h2 id="要解决的问题"><a class="header" href="#要解决的问题">要解决的问题</a></h2>
<p>A critical problem exists: what if constraints/forces are <strong>very very stiff</strong>? Or infinitely stiff?</p>
<blockquote>
<p>✅ 此算法用于处理 very very stiff 的场景即约束必须严格满足，而前面算法需要做很多次迭代才能产生这种效果（计算量大）。<br />
✅ 此算法常用于衣服、刚体、人体。比如人体的关节联结，是一种非常stiff的约束。</p>
</blockquote>
<h2 id="根据约束建立模型"><a class="header" href="#根据约束建立模型">根据约束建立模型</a></h2>
<p><img src="./assets/06-17.png" alt="" /></p>
<p>Compliant constraint</p>
<p>$$
\mathbf{ϕ} _e(\mathbf{x} )=||\mathbf{x} _{ei}− \mathbf{x} _{ej}||−L_e
$$</p>
<p>$$
E(\mathbf{x} )={\textstyle \sum_e}\frac{1}{2} k(||\mathbf{x} _{ei} −\mathbf{x} _{ej}||−L_e)^2=\frac{1}{2} \mathbf{\mathbf{ϕ}^T(x)C} ^{−1}\mathbf{ϕ} (\mathbf{x} )
$$</p>
<blockquote>
<p>✅ \(E(X)=\sum _ {e} \frac{1}{2}k( \phi _ e(x))^2\)</p>
</blockquote>
<p>$$
\mathbf{f} (\mathbf{x} )=−∇E=-\begin{pmatrix}
\frac{∂E}{∂\mathbf{ϕ}}  &amp; \frac{∂\mathbf{ϕ}}{∂x}
\end{pmatrix}^\mathbf{T} =−\mathbf{J^TC} ^{−1}\mathbf{ϕ} =\mathbf{J^Tλ} 
$$</p>
<p>Let \(N\) be the number of vertices and E be the number of constraints,</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>约束</td><td>$$ \phi (\mathbf{x} )\in \mathbf{R} ^E $$</td><td>✅ \( \phi_e = \begin{bmatrix} \phi _ 0\\ \phi _ 1 \\ \vdots  \\ \phi _ E  \end{bmatrix}\)</td></tr>
<tr><td>Compliant matrix</td><td>$$ \mathbf{C} =\begin{bmatrix} 1/k &amp; \Box  &amp; \Box\\ \Box &amp; 1/k &amp; \Box \\ \Box  &amp; \Box &amp;\ddots \end{bmatrix}\in \mathbf{R} ^{E×E} $$</td><td>✅ C称为软度矩阵、 stiffness:挺度，compliant:软度</td></tr>
<tr><td>Jacobian</td><td>\(\mathbf{J} =\frac{∂\phi}{∂\mathbf{x} } \in \mathbf{R} ^{E×3N}\)</td><td></td></tr>
<tr><td>Dual variables (Lagrangian multipliers)</td><td>\(\mathbf{λ} =−\mathbf{C} ^{−1}\phi \in \mathbf{R} ^E\)</td><td>✅ \(\lambda \) 是人为引入的变量，称为拉格朗日算子。</td></tr>
</tbody></table>
<blockquote>
<p>✅ \(E\) 和 \(f\) 变成了关于两个变量\((x、\lambda )\)的函数。<br />
✅把能量写成约束的形式<br />
$$
E(x)=\frac{1}{2}\phi ^T (x)C^{-1}\lambda 
\\
f(x)=J^T \lambda<br />
$$
根据\(E(x)\)和\(f(x)\)做隐式积分</p>
</blockquote>
<h2 id="转化为隐式积分问题"><a class="header" href="#转化为隐式积分问题">转化为隐式积分问题</a></h2>
<p>P31</p>
<p>By implicit integration, we get:</p>
<p>$$
\mathbf{Mv} ^{\mathrm{new} }−∆t\mathbf{J^Tλ} ^{\mathrm{new} }=\mathbf{Mv} 
$$</p>
<blockquote>
<p>✅ 动量守衡公式：\(Mv'- Mv = Ft = \)冲量<br />
✅ 此处新 \(\lambda^{\mathrm{new}} \)来计算 F. 说明是 Implicit</p>
</blockquote>
<p>Meanwhile,
$$
\mathbf{Cλ} ^{\mathrm{new} }=−\mathbf{ϕ} ^{\mathrm{new} }≈−\mathbf{ϕ} −\mathbf{J} (\mathbf{x} ^{\mathrm{new} }−\mathbf{x} )≈−\mathbf{ϕ} −∆t\mathbf{Jv} ^{\mathrm{new} }
$$</p>
<blockquote>
<p>✅ 对\(-\phi ^{\mathrm{new}}\) 的泰勒展开<br />
✅\(J\)是上页中的Jacobian.</p>
</blockquote>
<p>$$
\begin{bmatrix}
\mathbf{M}  &amp; −∆t\mathbf{J^T} \\
∆t\mathbf{J}  &amp; \mathbf{C} 
\end{bmatrix}\begin{bmatrix}
\mathbf{v} ^{\mathrm{new} } \\
\mathbf{λ} ^{\mathrm{new} }
\end{bmatrix}\begin{bmatrix}
\mathbf{Mv}  \\
-\mathbf{ϕ} 
\end{bmatrix}
$$</p>
<blockquote>
<p>✅ 最后的矩阵公式由上面两个公式整理合并得到。<br />
\(x ^{\mathrm{new}}-x =\bigtriangleup t\cdot v \)</p>
</blockquote>
<h2 id="解隐式积分"><a class="header" href="#解隐式积分">解隐式积分</a></h2>
<p>P32<br />
Now we have a system with two sets of variables: the primal variable \(\mathbf {x}\) (or \(\mathbf {v=x}\) ̇) and the dual variable \(\mathbf {λ}\).</p>
<blockquote>
<p>✅ 之前的隐式积分只有一个变量，此处的隐式积分有两个变量。需要同时解出两个变量。</p>
</blockquote>
<ul>
<li>Method 1: We can solve the two variables by a <strong>direct solver</strong> together, in a <u>primal-dual</u> fashion:</li>
</ul>
<p>$$
\begin{bmatrix}
\mathbf{M}  &amp; −∆t\mathbf{J^T} \\
∆t\mathbf{J}  &amp; \mathbf{C} 
\end{bmatrix}\begin{bmatrix}
\mathbf{v} ^{\mathrm{new} } \\
\mathbf{λ} ^{\mathrm{new} }
\end{bmatrix} = \begin{bmatrix}
\mathbf{Mv}  \\
-\mathbf{ϕ} 
\end{bmatrix}
$$ </p>
<blockquote>
<p>✅ 注意：Method 1 中的矩阵有可能不正定、因此很多数学方法用不了。 </p>
</blockquote>
<ul>
<li>Method 2: We can <strong>reduce the system</strong> by Schur complement and solve \(\mathbf {λ}^{\mathrm{new} }\) first.</li>
</ul>
<blockquote>
<p>✅ Method 2 的消元过程不容易构造、尤其是当矩阵比较复杂时。</p>
</blockquote>
<p>$$
(∆t^2\mathbf{JM} ^{−1}\mathbf{J} ^\mathbf{T} +\mathbf{C} )\mathbf{λ} ^{\mathrm{new} } =−\mathbf{ϕ} −∆t\mathbf{Jv} 
$$</p>
<p>$$
\mathbf{v} ^{\mathrm{new}}\longleftarrow \mathbf{v} +−∆t\mathbf{M} ^{−1}\mathbf{J^Tλ} ^{\mathrm{new}}
$$</p>
<blockquote>
<p>✅ 用哪种方法取决于应用场景</p>
</blockquote>
<h2 id="优点"><a class="header" href="#优点">优点</a></h2>
<p>Infinite stiffness? \(\mathbf{C \longrightarrow 0}\).</p>
<blockquote>
<p>✅ 此方法将软硬度量解耦出来，并用矩阵C来表示，使得可以方便控制软硬度，例如让\(c=0\) 来表示 infinite stiffness.</p>
</blockquote>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>Articulated Rigid Bodies (ragdoll animation)</p>
<p>P34</p>
<h1 id="stable-constrained-dynamics"><a class="header" href="#stable-constrained-dynamics">Stable Constrained Dynamics</a></h1>
<blockquote>
<p>✅ 没有展开讲，见after reading中的论文</p>
</blockquote>
<p>From a mass-spring system, we know spring Hessian (tangent stiffness) is:</p>
<p>$$
\mathbf{H} (\mathbf{x} )=∑_{e=(i,j)}\begin{bmatrix}
\Box  &amp; \Box  &amp; \Box  &amp; \Box  \\
\Box  &amp; \mathbf{H} _e &amp; -\mathbf{H} _e &amp; \Box   \\
\Box &amp; -\mathbf{H} _e &amp;\mathbf{H} _e  &amp; \Box   \\
\Box &amp;  \Box &amp; \Box  &amp; \Box<br />
\end{bmatrix}
$$</p>
<p><img src="./assets/06-18.png" alt="" /></p>
<p>According to constrained dynamics:\(\mathbf{f} (\mathbf{x} )=\mathbf{J^Tλ}\)  and \(\mathbf{λ} =−\mathbf{C} ^{−1}\mathbf{ϕ} \), so: </p>
<p><img src="./assets/06-19.png" alt="" /></p>
<p>$$
\mathbf{J}_e=\frac{∂\phi _e}{∂\mathbf{x} }=\begin{bmatrix}
\frac{\mathbf{x} _{ij}^\mathbf{T} }{||\mathbf{x} _{ij}||}   &amp; -\frac{\mathbf{x} _{ij}^\mathbf{T} }{||\mathbf{x} _{ij}||}
\end{bmatrix}
$$</p>
<p>P35</p>
<h2 id="stable-constrained-dynamics-1"><a class="header" href="#stable-constrained-dynamics-1">Stable Constrained Dynamics</a></h2>
<p>According Lecture 5, Page 16, implicit integration is:</p>
<p>$$
(\frac{1}{∆t^2}\mathbf{M+H} (\mathbf{x} ^{[0]}))∆\mathbf{x} = \frac{1}{∆t^2}\mathbf{M} (∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{[0]})
$$</p>
<p>$$
\Downarrow 
$$</p>
<p>$$
(\mathbf{M} +∆t^2\mathbf{H} (\mathbf{x} ^{[0]}))\mathbf{v} ^{\mathrm{new} }= \mathbf{Mv} ^{[0]}+∆t\mathbf{f} (\mathbf{x} ^{[0]})
$$</p>
<p><img src="./assets/06-20.png" alt="" /></p>
<p>Missing geometric stiffness matrix here…</p>
<p>P36</p>
<h2 id="after-class-reading-optional"><a class="header" href="#after-class-reading-optional">After-Class Reading (optional)</a></h2>
<p><img src="./assets/06-21.png" alt="" /></p>
<p>Tournier et al. 2015. <em>Stable Constrained Dynamics. TOG (SIGGRAPH)</em>.</p>
<blockquote>
<p>✅ Method 2 Gauss 消元，如果把\(\lambda\)消掉，会得到一个基本上与隐式积分相似的公式，唯一的区别是\(\mathbf{H}\)上略有不同 —— 隐式积分多了一项。如果把用这一项加回去，会使constrain dynamic 变得稳定。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P37</p>
<h1 id="a-summary-for-the-day-3"><a class="header" href="#a-summary-for-the-day-3">A Summary For the Day</a></h1>
<ul>
<li>Position-based dynamics and strain limiting
<ul>
<li>The key is to build a projection function for every constraint.</li>
<li>Two approaches for integration: Jacobi and Gauss-Seidel.</li>
<li>Fast in low resolutions, but problematic in high resolutions.</li>
<li>Not physically correct.</li>
</ul>
</li>
<li>Projective Dynamics
<ul>
<li>Also uses projection functions, but they are now built into energies.</li>
<li>In every iteration, projections are first updated, and then treated as constants in implicit formulation.</li>
<li>The matrix in the system becomes constant, can be pre-factorized for fast simulation.</li>
<li>Converges fast only in the first few iterations, slow afterwards. CPU friendly.</li>
</ul>
</li>
<li>Constrained Dynamics
<ul>
<li>Focused on very stiff constraints. Introduces dual variables.</li>
<li>Also built upon implicit integration. Two methods: primal-dual, pure dual.</li>
<li>Restrictions on the solvers.</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="topics-for-the-day-3"><a class="header" href="#topics-for-the-day-3">Topics for the Day</a></h1>
<ul>
<li>The linear finite element method (FEM)</li>
<li>The finite volume method (FVM)</li>
<li>Hyperelastic models</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="linear-finite-element-method"><a class="header" href="#linear-finite-element-method">Linear Finite Element Method</a></h1>
<p>P4</p>
<h2 id="the-linear-fem-assumption"><a class="header" href="#the-linear-fem-assumption">The Linear FEM Assumption</a></h2>
<blockquote>
<p>✅ 假设：三角形的形变是均匀的</p>
</blockquote>
<p>In a nutshell, linear FEM assumes that for any point \(\mathbf{X}\) in the reference triangle, its deformed correspondence is: \(\mathbf{x=FX+c}\).</p>
<blockquote>
<p>✅ reference triangle：三角形处于没有发生形变的静止的状态。<br />
✅ \(\mathbf{X}\)和\(\mathbf{x}\)可以分别是 reference 和 deformed 三角形的顶点或内部点，公式都同样适用。</p>
</blockquote>
<p><img src="./assets/07-1.png" alt="" /></p>
<p>For any vector between two points, we can use F to convert it from reference to deformed:<br />
$$
\mathbf{x} _{ba}=\mathbf{x} _b−\mathbf{x} _a=\mathbf{FX} _b+\mathbf{c} −\mathbf{FX} _a−\mathbf{c} =\mathbf{FX} _{ba}.
$$</p>
<p>P5</p>
<h2 id="计算deformation-gradient"><a class="header" href="#计算deformation-gradient">计算Deformation Gradient</a></h2>
<p>Therefore, we can calculate the deformation gradient by edge vectors.</p>
<p><img src="./assets/07-2.png" alt="" /></p>
<p><strong>Problem:</strong> \(\mathbf{F}\) <strong>is related to deformation, but it contains rotation</strong>.</p>
<blockquote>
<p>✅ 期望\(\mathbf{F}\)只包含形变量、不包含平移和旋转、因为刚体运动不应该有形变，所以要把形变提取出来。<br />
✅平移已经在\(\mathbf{c}\)里面了，所以只需考虑旋转。</p>
</blockquote>
<p>P6</p>
<h2 id="从f中去除旋转"><a class="header" href="#从f中去除旋转">从F中去除旋转</a></h2>
<h3 id="回顾svd分解"><a class="header" href="#回顾svd分解">回顾SVD分解</a></h3>
<p>Ideally, we need a tensor to describe shape deformation only.  Recall that SVD gives \(\mathbf{F=UDV^T}\), where only \(\mathbf{V^T}\) and \(\mathbf{D}\) are relevant to deformation.</p>
<p><img src="./assets/07-3.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{V^T}\) 看上去是旋转、实际上是为了确定形变的方向、 \(\mathbf{U}\) 才是真正的旋转<br />
✅ 目的：把\(\mathbf{F}\)中的\(\mathbf{U}\)去掉、可以先做 \(\mathbf{SVD}\) 分解再把\(\mathbf{U}\)去掉。但本文使用了更简单的方法</p>
</blockquote>
<h3 id="green-strain"><a class="header" href="#green-strain">Green Strain</a></h3>
<p>So we get rid of \(\mathbf{U}\) as: \(\mathbf{G} =\frac{1}{2} (\mathbf{F^TF−I} )=\frac{1}{2} (\mathbf{VD} ^2\mathbf{V} ^\mathbf{T} −\mathbf{I} )=\begin{bmatrix}
\varepsilon _{uu} &amp; \varepsilon _{uv}\\
\varepsilon _{uv} &amp; \varepsilon _{vv}
\end{bmatrix}\), <em>Green strain</em>.</p>
<blockquote>
<p>✅ \(\mathbf{G}\) 是一个描述物体形变的有无和大小矩阵，且与关旋转</p>
</blockquote>
<ul>
<li>If no deformation, \(\mathbf{G=0}\); if deformation increases,  ||\(\mathbf{G}\)|| increases.</li>
<li>Three deformation modes: \(\varepsilon _{uu}\), \(\varepsilon _{vv}\) and \(\varepsilon _{uv}\).</li>
<li>\(\mathbf{G}\) is <u>rotation invariant</u>: if additional rotation \(\mathbf{R}\), then deformation gradient is \(\mathbf{RF}\) but green strain is the same: \(\mathbf{G} =\frac{1}{2} (\mathbf{F^TR^TRF−I} )=\frac{1}{2} (\mathbf{VD} ^2\mathbf{V} ^\mathbf{T} −\mathbf{I} )\).</li>
</ul>
<p>P7</p>
<h2 id="计算能量"><a class="header" href="#计算能量">计算能量</a></h2>
<p>Let \(\mathbf{G}\) be the the green strain describing deformation. We consider the <strong>energy density</strong> per reference area as: \(W (\mathbf{G})\).</p>
<p><img src="./assets/07-4.png" alt="" /></p>
<p><img src="./assets/07-5.png" alt="" /></p>
<blockquote>
<p>✅用形变程度来定义能量。\(W\)代表单位面积上的能量，因此称为能量密度。总能量为单位能量\(\mathbf{X}\)面积.<br />
✅  \(A^{ref}\) 为 reference status 下三角形的面积<br />
✅  StVK是一种经典的能量密度函数（Strain Energy Density Function）， 在力学中不常用，但在图形学中很常用、原因是简单</p>
</blockquote>
<p><img src="./assets/07-6.png" alt="" /></p>
<blockquote>
<p>✅  S 是一个与力有关的物理量。会在FVM内容中进一步解释。<br />
✅  能量对位移求导是力。形变是一种位移。能量密度对位移求导是一种类似于力的密度的量。</p>
</blockquote>
<p>P8</p>
<h2 id="计算forces"><a class="header" href="#计算forces">计算Forces</a></h2>
<p>Given everything we have, we can now calculate the forces.</p>
<blockquote>
<p>✅ 力是形变施加到顶点上的力</p>
</blockquote>
<p><img src="./assets/07-7.png" alt="" /></p>
<blockquote>
<p>✅ 绿色部分是上一页S中的内容、灰色部分将在下一页推导。</p>
</blockquote>
<p>P9</p>
<h3 id="方法一"><a class="header" href="#方法一">方法一</a></h3>
<p>Recall that,</p>
<p><img src="./assets/07-8.png" alt="" /></p>
<blockquote>
<p>❗ \(\mathbf{F}\)不是力，是deformation gradient．<br />
✅ 假设a,b,c,d是形变后的顶点。</p>
</blockquote>
<p>By definition,<br />
$$
\mathbf{G} =\frac{1}{2} (\mathbf{F^TF−I} )=\begin{bmatrix}
\frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (a\mathbf{x} _{10}+c\mathbf{x} _{20})−\frac{1}{2}  &amp; \frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})\\
\frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})  &amp; \frac{1}{2}(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})−\frac{1}{2}
\end{bmatrix}
$$</p>
<p>So:</p>
<p>$$
\frac{∂\varepsilon _{uu}}{∂\mathbf{x} _1}=a(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{vv}}{∂\mathbf{x} _1}=b(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{uv}}{∂\mathbf{x} _1}=\frac{1}{2} a(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} +\frac{1}{2}  b(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
$$</p>
<p>$$
\frac{∂\varepsilon _{uu}}{∂\mathbf{x} _2}=c(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{vv}}{∂\mathbf{x} _2}=d(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{uv}}{∂\mathbf{x} _2}=\frac{1}{2} c(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} +\frac{1}{2}  d(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
$$</p>
<blockquote>
<p>✅ \(\mathbf{x}\)为current边的矩阵，\(\mathbf{r}\)为reference边的矩阵。</p>
</blockquote>
<p>P10</p>
<h3 id="方法二"><a class="header" href="#方法二">方法二</a></h3>
<p><img src="./assets/07-9.png" alt="" /></p>
<blockquote>
<p>✅ 把 P9 代入 P8 得到 P10<br />
✅ 上一页推导方法从定义出来，过程简单，但很容易出错。这里用矩阵来简化计算，得到同样的结果。</p>
</blockquote>
<p>P11</p>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<p>In conclusion, we have:</p>
<p>$$
\mathbf{f} _1=−A^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
a\\
b
\end{bmatrix}  \quad\quad \mathbf{f} _2=−A^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
c\\
d
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{f} _1 &amp;\mathbf{f} _2
\end{bmatrix}= − A ^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20}
\end{bmatrix}^\mathbf{−T} 
$$</p>
<blockquote>
<p>✅ \(f_0=-f_1-f_2\)</p>
</blockquote>
<p>P12</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<blockquote>
<p>🔎 Volino et al. 2009. <em>A simple approach to nonlinear tensile stiffness for accurate cloth simulation</em>. TOG</p>
</blockquote>
<p>Only talks about cloth (2D reference -&gt; 3D deformation)</p>
<ul>
<li>What about tetrahedron (3D reference -&gt; 3D deformation)?
<ul>
<li>Same idea, but everything is now in 3D.</li>
<li>Deformation gradient \(\mathbf{F} \in \mathbf{R} ^{3×3}\)</li>
<li>Green strain \(\mathbf{G} \in \mathbf{R} ^{3×3}\)</li>
<li>Stress tensor \(\mathbf{S} \in \mathbf{R} ^{3×3}\)</li>
<li>Forces \(\mathbf{F}_i \in \mathbf{R} ^3\)</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P13</p>
<h1 id="finite-volume-method"><a class="header" href="#finite-volume-method">Finite Volume Method</a></h1>
<blockquote>
<p>✅ FEM求导，FVM积分。在线性场景下，FEM和FVM本质上等价的。<br />
✅ FVM基于力从何而来的思想。</p>
</blockquote>
<h2 id="符号定义"><a class="header" href="#符号定义">符号定义</a></h2>
<p>P14</p>
<h3 id="traction"><a class="header" href="#traction">Traction</a></h3>
<p>First, let’s consider traction <strong>t</strong>: the internal force per unit length (area).</p>
<p><img src="./assets/07-10.png" alt="" /></p>
<blockquote>
<p>✅ 两个弹性体被界面 \(L\) 分开、求 \(L\) 上的力、</p>
</blockquote>
<p>Total interface force:</p>
<p>$$
f\mathbf{} =\oint _L \mathbf{t} dl
$$</p>
<blockquote>
<p>✅ \(\mathbf{t}\)是\(L\) 上的单位面积/长度上的力。那么总的力是t的积分。</p>
</blockquote>
<h3 id="stress"><a class="header" href="#stress">Stress</a></h3>
<p>Stress tensor \(\mathbf{σ} \) (interface normal -&gt; traction):</p>
<p>$$
\mathbf{t=σn} 
$$</p>
<p>So,</p>
<p>$$
\mathbf{f} =\oint_{L}  \mathbf{σn} dl
$$</p>
<blockquote>
<p>✅ \(\mathbf{σ}\) 一个矩阵</p>
</blockquote>
<p>P15</p>
<h2 id="计算fvm中的力"><a class="header" href="#计算fvm中的力">计算FVM中的力</a></h2>
<h3 id="2d"><a class="header" href="#2d">2D</a></h3>
<p>FVM considers force calculation in an integration perspective, not a differentiation perspective.</p>
<p><img src="./assets/07-11.png" alt="" /></p>
<blockquote>
<p>✅  \(\mathbf{X}_0\)是顶点\(\mathbf{X}_0\)附近邻域面积上的力。</p>
</blockquote>
<p>Force contributed by an element:</p>
<p>$$
\mathbf{f}_0 =\oint _L \mathbf{σn} dl
$$</p>
<blockquote>
<p>✅  \(\mathbf{X}_0\)上的力是邻域面边界\(L\)上的力的积分、不考虑边界内部的力，因为认为内力为0。<br />
✅  仅看其中一个三角形、假设曲线经过 \(\mathbf{X}_0\mathbf{X}_1\)和 \(\mathbf{X}_0\mathbf{X}_2\)的中点。因为三角形的力对三个顶点是平均的。</p>
</blockquote>
<p>Since \(\mathbf{σ}\) is constant within the element,</p>
<p>$$
\oint_L \mathbf{σn} dl + \oint_{L_{20}} \mathbf{σn} dl+\oint_{L_{10}}\mathbf{σn} dl=0
$$</p>
<blockquote>
<p>✅  对于封闭曲线L+L10+L20做积分，\(\int _n=0\)，因此 \(\sigma \int _n=0\)</p>
</blockquote>
<p>(Divergence Theorem)</p>
<p>We know the force is:</p>
<p>$$
\mathbf{f}_0 = - \oint _ {L _{20}} \mathbf{σn} _ {20} dl -  \oint _ {L _{10}} \mathbf{σn} _ {10} dl = - \mathbf{σ}(\frac{||\mathbf{X} _ {20}||}{2}\mathbf{n} _ {20}+ \frac{||\mathbf{X} _ {20}||}{2}\mathbf{n} _ {10})
$$</p>
<p>P16</p>
<h3 id="3d"><a class="header" href="#3d">3D</a></h3>
<blockquote>
<p>✅  三维场景是对四面体的四个面积分。<br />
✅  每个三角形的 stress 都不同、同一个三角形内部 stress 是常数。</p>
</blockquote>
<p>In 3D, FVM works in the same way.</p>
<p><img src="./assets/07-12.png" alt="" /></p>
<p>Force:</p>
<p>$$
\begin{array}{l} 
\mathbf{f} _ 0 = −\oint _ Ω \mathbf{σn} dA=−\mathbf{σ} (\frac{A _ {012}}{3}\mathbf{n} _ {012} + \frac{A _ {023}}{3}\mathbf{n} _ {023} + \frac{A _ {031}}{3}\mathbf{n} _ {031})\\
=−\frac{σ}{3}(\frac{||\mathbf{x} _ {10} \times \mathbf{x} _ {20}||}{2} \frac{\mathbf{x} _ {10} × \mathbf{x} _ {20}}{||\mathbf{x} _ {10} × \mathbf{x} _ {20}||} + \frac{||\mathbf{x} _ {20} × \mathbf{x} _ {30}||}{2}\frac{\mathbf{x} _ {20} × \mathbf{x} _ {30}}{||\mathbf{x} _ {20} × \mathbf{x} _ {30}||}
+\frac{||\mathbf{x} _ {30} × \mathbf{x} _ {10}||}{2}\frac{\mathbf{x} _ {30} × \mathbf{x} _ {10}}{||\mathbf{x} _ {30} × \mathbf{x} _ {10}||})\\
=−\frac{\mathbf{σ}}{6} (\mathbf{x} _ {10} × \mathbf{x} _ {20} + \mathbf{x} _ {20} × \mathbf{x} _ {30} + \mathbf{x} _ {30} × \mathbf{x} _ {10})
\end{array}
$$</p>
<blockquote>
<p>❓  遗留问题， stress 如何计算？</p>
</blockquote>
<blockquote>
<p>✅\(f_0\)是\(\sigma n\)在绿色体截面上的积分。<br />
✅类似于上一页合力为零的原理，\( \oint 截面＋\oint 表面=0\)<br />
✅“面积／3”是因为面上的贡献均匀地分布到三个点上。</p>
</blockquote>
<p>P17</p>
<h2 id="计算fvm中的stress"><a class="header" href="#计算fvm中的stress">计算FVM中的stress</a></h2>
<p>Although the use of stress tensor is the same: <strong>mapping from the interface normal to the traction</strong>, it can be defined by different configurations.</p>
<table><thead><tr><th><img src="./assets/07-13.png" alt="" /></th><th><img src="./assets/07-14.png" alt="" /></th></tr></thead><tbody>
<tr><td>In FEM, we define the energy density \(W\) in the <strong>reference</strong> state.  Therefore, this stress \(\mathbf{S}\)  is a mapping from the normal \(\mathbf{N}\) to the traction \(\mathbf{T}\), both in the <strong>reference</strong> state.</td><td>In FVM, we need \(\mathbf{σ}\) to convert the normal into \(\mathbf{t}\) for force calculation. Therefore, this stress assumes the normal \(\mathbf{n}\) and the traction \(\mathbf{t}\) are in the <strong>deformed</strong> state.</td></tr>
</tbody></table>
<blockquote>
<p>✅  在 reference 状态下有 normal. traction 和 stress.在形变状态下也有 normal traction 和 stress.FEM 使用的是 reference 空间下的量。</p>
</blockquote>
<p>P18</p>
<h3 id="different-stresses"><a class="header" href="#different-stresses">Different Stresses</a></h3>
<p>We can now have different stresses, serving the same purpose but in different forms.</p>
<p><img src="./assets/07-15.png" alt="" /></p>
<blockquote>
<p>✅  FVM 需要的是 Cauchy Stress.（\(\sigma \)）、上节课讲了(S)的 计算方法，需要根据(S)求(\(\sigma \)).<br />
\(P → \sigma \) 的过程没有展开讲，结论在P21</p>
</blockquote>
<p>P19</p>
<h3 id="p与sigma-的关系area-weighted-normals"><a class="header" href="#p与sigma-的关系area-weighted-normals">P与\(\sigma \)的关系：Area Weighted Normals</a></h3>
<p><img src="./assets/07-16.png" alt="" /></p>
<p>Now let’s figure out the relationship between \(A^{\mathrm{ref} }\mathbf{N}\) and \(A\mathbf{n}\), the two area weighted normals.</p>
<p>$$
2A^{\mathrm{ref} }\mathbf{N} =\mathbf{X} _ {a0}×\mathbf{X} _ {b0}
$$</p>
<p>$$
\begin{array}{l} 
2A\mathbf{n} =\mathbf{x} _ {a0}×\mathbf{x} _ {b0}=\mathbf{FX} _{a0} × \mathbf{FX} _ {b0} = (\mathbf{UDV^TX} _ {a0}) × (\mathbf{UDV^TX} _ {b0}) \\
\quad\quad=\mathbf{U} ((\mathbf{DV^TX} _ {a0}) × (\mathbf{DV^TX} _ {b0})) \\
\quad\quad=\mathbf{U} \begin{bmatrix}
d_1d_2&amp; \Box  &amp; \Box \\
\Box  &amp; d_0d_2 &amp; \Box \\
\Box &amp; \Box  &amp;d_0d_1
\end{bmatrix} ((\mathbf{V^TX} _ {a0})×(\mathbf{V^TX} _ {b0}))\\
\quad\quad=\mathbf{U} \begin{bmatrix}
d_1d_2&amp; \Box  &amp; \Box \\
\Box  &amp; d_0d_2 &amp; \Box \\
\Box &amp; \Box  &amp;d_0d_1
\end{bmatrix} \mathbf{V^T} (\mathbf{X} _ {a0} × \mathbf{X} _ {b0})\quad=d_0d_1d_2\mathbf{U} \begin{bmatrix}
1/d_0&amp; \Box  &amp; \Box  \\
\Box  &amp; 1/d_1 &amp; \Box  \\
\Box &amp; \Box  &amp;1/d_2
\end{bmatrix} \mathbf{V^T} (\mathbf{X} _ {a0}×\mathbf{X} _ {b0}) \\
\quad\quad=\mathrm{det} (\mathbf{F} )\mathbf{F} ^{−\mathbf{T}}(\mathbf{X} _ {a0}×\mathbf{X} _ {b0})=\mathrm{det} (\mathbf{F} )\mathbf{F} ^{−\mathbf{T}}(2A^\mathrm{ref}\mathbf{N})
\end{array}
$$</p>
<p>P20</p>
<p>Now we know: \(A\mathbf{n} =\mathrm{det} (\mathbf{F})\mathbf{F^{−T}} (A^{\mathrm{ref}}\mathbf{N} )\).</p>
<p>We also know the force can be calculated using two different stresses:</p>
<p>$$
\mathbf{f} =−\frac{1}{3}  {\textstyle \sum {A^{\mathrm{ref} }}}\mathbf{PN} =−\frac{1}{3}\sum A\mathbf{σn} 
$$</p>
<p>Therefore, we get:</p>
<p>$$
\mathbf{P} (A^{\mathrm{ref} }\mathbf{N} )=\mathbf{σ} \mathrm{det} (\mathbf{F} )\mathbf{F^{−T}} (A^{\mathrm{ref} }\mathbf{N} )
$$</p>
<p>$$
\mathrm{det} ^{−1}(\mathbf{F} )\mathbf{PF^T=σ} 
$$</p>
<p>P21</p>
<h3 id="结论-1"><a class="header" href="#结论-1">结论</a></h3>
<p>We can now have different stresses, serving the same purpose but in different forms.</p>
<p><img src="./assets/07-17.png" alt="" /></p>
<p>P22 </p>
<h2 id="根据stress算出力"><a class="header" href="#根据stress算出力">根据stress算出力</a></h2>
<p>The previous analysis suggests we can use reference normals instead.</p>
<p><img src="./assets/07-18.png" alt="" /></p>
<p>Second Piola–Kirchhoff stress:<br />
\(\mathbf{S} =\frac{∂W}{∂\mathbf{G}}\), as in previous FEM formulation</p>
<blockquote>
<p>✅ 第一行公式：用 deformed position 计算 deformed position. 第二行公式：用 ref position 计算 deformed position, 因此直接把\(\sigma \)换成 \(\mathbf{P} \) 就可以。<br />
✅ 好处：ref position 是常数，可以做预计算、并存储为\(b_1\).<br />
✅ F：deformation gradient.见P5<br />
✅ 用三种不同定义的 stress 来算力、目的是得到计­算最友好的公式<br />
✅ 此处内容涉及材料力学、</p>
</blockquote>
<p>P23</p>
<h2 id="关于b1"><a class="header" href="#关于b1">关于b1</a></h2>
<p><img src="./assets/07-19-01.png" alt="" /></p>
<blockquote>
<p>✅ 问：  \(\mathbf{X}_ {20}^\mathbf{T} b_1\)的计算公式中、绿色的\(\mathbf{X}_ {01}×\mathbf{X} _ {21}\)怎么变成了\(\mathbf{X}_ {20}\times \mathbf{X}_ {10}\)？下面的\(\mathbf{X}_ {30}^\mathbf{T} b_1\),也一样。<br />
答：因为\(\mathbf{X}_o，\mathbf{X}_1，\mathbf{X}_2\)是同一个三角形上的顶点，任意两条边做cross都是一样的，处理好正负就好了。<br />
也可以用cross的乘法分配律得出相同的结论</p>
</blockquote>
<p>P24<br />
Therefore, We get:</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _1=\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T}(\mathbf{X} _{01}×\mathbf{X} _{21}+\mathbf{X} _{21}×\mathbf{X} _{31}+\mathbf{X} _{31}×\mathbf{X} _{01})=\begin{bmatrix}
6Vol\\
0\\
0
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _2=\begin{bmatrix}
0\\
6Vol\\
0
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _3=\begin{bmatrix}
0\\
0\\
6Vol
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{b} _{1} &amp; \mathbf{b} _{2} &amp;\mathbf{b} _{3}
\end{bmatrix}^\mathbf{T} =6Vol\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-\mathbf{T}}\\
\quad\quad=\frac{1}{\mathrm{det}( \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-1})} \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-\mathbf{T}}
$$</p>
<p>P25</p>
<h2 id="a-quick-summary"><a class="header" href="#a-quick-summary">A Quick Summary</a></h2>
<p><img src="./assets/07-20.png" alt="" /></p>
<blockquote>
<p>✅reference 状态下，\(F＝I,G=0,P=0,f=0\)</p>
</blockquote>
<p>P26</p>
<h2 id="after-class-reading-7"><a class="header" href="#after-class-reading-7">After-Class Reading</a></h2>
<h3 id="重点推荐"><a class="header" href="#重点推荐">重点推荐：</a></h3>
<p>Teran et al. 2003. <em>Finite Volume Methods for the
Simulation of Skeleton Muscles</em>. SCA.</p>
<blockquote>
<p>✅ 这篇论文重点推荐，但论文中的公式与 PPT 中的不完全一样. PPT 上的又进一步简化。</p>
</blockquote>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<p>Volino et al. 2009. <em>A Simple Approach to Nonlinear Tensile
Stiffness for Accurate Cloth Simulation</em>. TOG.</p>
<blockquote>
<p>✅2D有限元</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P28</p>
<h1 id="hyperelastic-models"><a class="header" href="#hyperelastic-models">Hyperelastic Models</a></h1>
<blockquote>
<p>✅ 前面的内容，都假设使用 StVK 材料、优点是简单；缺点是无法处理反转。因此在材料力学中不常用。<br />
Hyperplasia 利用能量密度(W)、提供一个从 Strain (G) 到 Stress (S)的映射</p>
</blockquote>
<h2 id="跳过"><a class="header" href="#跳过">跳过</a></h2>
<p>P29</p>
<h3 id="first-piolakirchhoff-stress"><a class="header" href="#first-piolakirchhoff-stress">First Piola–Kirchhoff stress</a></h3>
<p>We treat the first Piola–Kirchhoff stress tensor \(\mathbf{P}\) as a function of deformation gradient \(\mathbf{F}\):</p>
<p>$$
\mathbf{f} _0= −\frac{\mathbf{P} (\mathbf{F} )}{6}(\mathbf{X} _{10}×\mathbf{X} _{20}+\mathbf{X} _{20}×\mathbf{X} _{30}+\mathbf{X} _{30}×\mathbf{X} _{10})
$$</p>
<p>It converts an interface normal \(\mathbf{N}\) in the reference state to a traction \(\mathbf{t}\) in the deformed state. </p>
<p>$$
\mathbf{t}=\mathbf{P} (\mathbf{UDV^T} )\mathbf{N} 
$$</p>
<p><img src="./assets/07-21.png" alt="" /></p>
<blockquote>
<p>✅   没讲，</p>
</blockquote>
<p>P30</p>
<h3 id="rotation-invariance"><a class="header" href="#rotation-invariance">Rotation-Invariance</a></h3>
<p>The stress tensor \(\mathbf{P}\) is rotation-invariant to \(\mathbf{U}\):</p>
<p><img src="./assets/07-22.png" alt="" /></p>
<p>$$
\mathbf{P} (\mathbf{UDV^T} )=\mathbf{UP} (\mathbf{DV^T} )
$$</p>
<blockquote>
<p>✅   没讲，</p>
</blockquote>
<p>P31</p>
<h3 id="isotropic-materials"><a class="header" href="#isotropic-materials">Isotropic Materials</a></h3>
<p>The stress tensor \(\mathbf{P}\) is rotation-invariant to \(\mathbf{U}\):</p>
<p><img src="./assets/07-23.png" alt="" /></p>
<p>$$
\mathbf{P} (\mathbf{DV^T} )=\mathbf{P} \mathbf{(D)V^T} 
$$</p>
<blockquote>
<p>✅   没讲，</p>
</blockquote>
<p>P32</p>
<h2 id="isotropic-materials-1"><a class="header" href="#isotropic-materials-1">Isotropic Materials</a></h2>
<blockquote>
<p>Isotropic Materials：各向同性材料</p>
</blockquote>
<p><img src="./assets/07-24.png" alt="" /></p>
<blockquote>
<p>✅ 符号解释：\(\mathbf{P}\)：First Piola Stress、 \(\mathbf{F}\)：Deformation Gradient<br />
✅ 各向同性公式认为：\(\mathbf{P}\) 是关于 \(\mathbf{F}\) 的函数<br />
✅ 对F做 \(\mathbf{SVD}\) 分解可得到 \(\mathbf{UDV^T}\)，其中\(D\)是对角矩阵、其对角元素描述了三个方向的拉伸的量、把公式中的旋转分量剔除掉、 \(\mathbf{P}\) 只与 Principal stretches 有关。</p>
</blockquote>
<p>In many literatures, people parameterize \(\mathbf{P} (I_\mathbf{C},II_\mathbf{C},III_\mathbf{C} )\) by principal invariants, for:</p>
<p>$$
I_\mathbf{C} =\mathrm{trace} (\mathbf{C} )=λ_0^2+λ_1^2+λ_2^2
$$</p>
<p>$$
III_\mathbf{C} =\mathrm{det} (\mathbf{C} ^2)=λ_0^4+λ_1^4+λ_2^4
$$</p>
<p>$$
II_\mathbf{C} =\frac{1}{2} (\mathrm{trace} ^2(\mathbf{C} )−\mathrm{trace} (\mathbf{C} ^2))=λ_0^2λ_1^2+λ_0^2λ_2^2+λ_1^2λ_2^2
$$</p>
<p>\(\mathbf{C=U^TU}\) is the right Cauchy-Green deformation tensor.</p>
<blockquote>
<p>✅ \(I_c、 II_c、 III_c\) 的定义是基于材料学、数学的先验知识</p>
</blockquote>
<p>P33</p>
<h2 id="isotropic-models"><a class="header" href="#isotropic-models">Isotropic Models</a></h2>
<p><img src="./assets/07-25.png" alt="" /></p>
<blockquote>
<p>✅ 材料力学中更常用 neo-Hookean<br />
✅Fung常用来模拟人体组织。</p>
</blockquote>
<p>P34</p>
<h2 id="计算p"><a class="header" href="#计算p">计算P</a></h2>
<p>Anyway, we still use the principal stretches for computation:</p>
<p>$$
\mathbf{P} (λ_0,λ_1,λ_2)=\begin{bmatrix}
\frac{∂W}{∂λ_0}  &amp; \Box  &amp;\Box  \\
\Box  &amp; \frac{∂W}{∂λ_1}  &amp; \Box \\
\Box  &amp; \Box  &amp;\frac{∂W}{∂λ_2} 
\end{bmatrix}
$$</p>
<p>And we compute the first Piola-Kirchhoff stress as:</p>
<p>$$
\mathbf{P} = \mathbf{UP} (λ_0,λ_1,λ_2)\mathbf{V} ^\mathbf{T} 
$$</p>
<p>P35</p>
<h2 id="a-quick-summary-1"><a class="header" href="#a-quick-summary-1">A Quick Summary</a></h2>
<p><img src="./assets/07-26.png" alt="" /></p>
<blockquote>
<p>✅ 主要是算P的方法不同</p>
</blockquote>
<p>P36</p>
<h2 id="the-limitation-of-stvk"><a class="header" href="#the-limitation-of-stvk">The Limitation of StVK</a></h2>
<p><img src="./assets/07-27.png" alt="" /></p>
<p>Irving et al. 2004. <em>Invertible Finite Elements For Robust Simulation of Large Deformation</em>. SCA</p>
<blockquote>
<p>✅ 纵轴是力、横轴长度为弹簧长度、参考长度是1， 因此横轴为1时纵轴为0. 横轴 &gt; 1 代表拉伸、拉伸越大代表力越大。但压缩时， \(StVK\) 表现出的力不对，且当弹簧（四面体）反转以后，力也会反转，这种表现也不对，因为最后会停在横轴-1的状态上。</p>
</blockquote>
<p>P37</p>
<p><img src="./assets/07-28.png" alt="" /></p>
<blockquote>
<p>✅ Poison Effect： 弹性体往上拉时两边会凹进去，本质原因是保体积。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P39</p>
<h1 id="a-summary-for-the-day-4"><a class="header" href="#a-summary-for-the-day-4">A Summary For the Day</a></h1>
<ul>
<li>
<p>FEM uses the <strong>derivates</strong> of the strain energy function to obtain the force.</p>
</li>
<li>
<p>FVM uses the <strong>integral</strong> of the interface traction to obtain the force.</p>
</li>
<li>
<p>The two approaches lead to the <strong>identical outcome</strong>, in <strong>different formulations</strong></p>
</li>
<li>
<p>Hyperelastic models define the strain energy function by principal stretches, i.e., the singular values of the deformation gradient.</p>
</li>
<li>
<p>For isotropic materials, we can calculate the stress through diagonalization.</p>
</li>
</ul>
<blockquote>
<p>✅ Level：1. 了解，会用；2. 理解、举一反三；3. 跳出图形学；<br />
✅ 图形学关注的不是数学模型，而是快。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="topics-for-the-day-4"><a class="header" href="#topics-for-the-day-4">Topics for the Day</a></h1>
<ul>
<li>
<p>Hessian of Elastic Energy</p>
</li>
<li>
<p>Implicit Integration</p>
</li>
<li>
<p>Nonlinear optimization.</p>
</li>
</ul>
<blockquote>
<p>✅ 隐式积分不讲了。推荐P12页的论文<br />
直接跳到 P18、非线性优化。</p>
</blockquote>
<p>P4</p>
<h1 id="hessian-of-elastic-energy"><a class="header" href="#hessian-of-elastic-energy">Hessian of Elastic Energy</a></h1>
<p>P5</p>
<h2 id="recall-that"><a class="header" href="#recall-that">Recall that…</a></h2>
<p><img src="./assets/08-2.png" alt="" /></p>
<p>P6</p>
<h2 id="energy-hessian"><a class="header" href="#energy-hessian">Energy Hessian:</a></h2>
<p><img src="./assets/08-3.png" alt="" /></p>
<p>P7</p>
<h2 id="svd-derivative"><a class="header" href="#svd-derivative">SVD Derivative</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\)is singular value decomposition \((\mathbf{Λ} =\mathrm{diag} (λ_0,λ_1,λ_2))\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =\mathbf{U^T} (\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}\mathbf{ΛV^T} +\mathbf{U}\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}\mathbf{V^T}+\mathbf{UΛ}\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}})\mathbf{V}
$$</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =(\mathbf{U^T} \frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}})\mathbf{Λ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+ \mathbf{Λ}(\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\mathbf{V})
$$</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} = \mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+ \mathbf{ΛB}
$$</p>
<p>P8</p>
<h2 id="skew-symmetric-matrix"><a class="header" href="#skew-symmetric-matrix">Skew-Symmetric Matrix</a></h2>
<p>Matrix \(\mathbf{A}\) is skew-symmetric (or anti-symmetric), if \(\mathbf{A=−A^T}\):</p>
<p>$$
\mathbf{A} =\begin{bmatrix}
0 &amp; a &amp; b \\
-a &amp; 0 &amp; c \\
-b  &amp; -c &amp; 0
\end{bmatrix}
$$</p>
<p>If \(\mathbf{D}\) is diagonal, then:</p>
<p>$$
\mathbf{AD} =\begin{bmatrix}
0 &amp; a &amp; b \\
-a &amp; 0 &amp; c \\
-b  &amp; -c &amp; 0
\end{bmatrix}\begin{bmatrix}
d &amp; 0 &amp;0 \\
0 &amp; e &amp; 0\\
0 &amp; 0 &amp;f
\end{bmatrix}=\begin{bmatrix}
0 &amp; ? &amp; ?\\
? &amp; 0 &amp;? \\
? &amp; ? &amp;0
\end{bmatrix} 
$$</p>
<p>$$ 
\mathbf{DA} = \begin{bmatrix}
d  &amp; 0 &amp; 0\\
0 &amp; e &amp; 0\\
0 &amp; 0 &amp;f
\end{bmatrix}\begin{bmatrix}
0  &amp; a &amp; b\\
-a &amp; 0 &amp;c \\
-b &amp; -c &amp;0
\end{bmatrix}=\begin{bmatrix}
0 &amp; ? &amp;? \\
? &amp;  0&amp; ?\\
? &amp; ? &amp;0
\end{bmatrix}
$$</p>
<p>When \(\mathbf{U}\) is orthogonal, we have:</p>
<p>$$
\mathbf{0} =\frac{∂(\mathbf{U^TU)}}{∂\mathbf{F} _{kl}} =\mathbf{U^T} \frac{ ∂\mathbf{U} }{∂\mathbf{F} _{kl}}+\frac{∂\mathbf{U^T}}{∂\mathbf{F} _{kl}}\mathbf{U} =\mathbf{U^T}\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}+(\mathbf{U^T} \frac{∂\mathbf{U}}{∂\mathbf{F} _{kl}})^\mathbf{T} 
$$</p>
<p>Therefore, \(\mathbf{A=U^T}\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}\) is skew-symmetric. So is \(\mathbf{B} =\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}} \mathbf{V}\).</p>
<p>P9</p>
<h2 id="svd-derivative-cont"><a class="header" href="#svd-derivative-cont">SVD Derivative (cont.)</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\) is singular value decomposition \(\mathbf{Λ} =\mathrm{diag} (λ_0,λ_1,λ_2)\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} = \mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+\mathbf{ΛB} 
$$</p>
<p>After expansion, we get:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F}}{∂\mathbf{F} _{kl}} \mathbf{V} =<br />
\begin{bmatrix}
0 &amp; a_0 &amp; a_1\\
-a_0 &amp; 0 &amp; a_2\\
-a_1&amp; -a_2 &amp;0
\end{bmatrix} \begin{bmatrix}
λ_0 &amp; \Box  &amp; \Box\\
\Box &amp; λ_1 &amp;\Box \\
\Box &amp; \Box &amp;λ_2
\end{bmatrix} \begin{bmatrix}
\frac{∂λ_0}{∂\mathbf{F} _{kl}} &amp; \Box &amp; \Box\\
\Box &amp; \frac{∂λ_1}{∂\mathbf{F} _{kl}} &amp; \Box\\
\Box &amp; \Box &amp;\frac{∂λ_2}{∂\mathbf{F} _{kl}}
\end{bmatrix} \begin{bmatrix}
λ_0  &amp; \Box  &amp; \Box \\
\Box  &amp; λ_1 &amp;\Box  \\
\Box &amp; \Box  &amp;λ_2
\end{bmatrix} \begin{bmatrix}
0 &amp;  b_0&amp; b_1\\
-b_0 &amp; 0 &amp;b_2 \\
-b_1 &amp; -b_2 &amp;0
\end{bmatrix}
$$</p>
<p>P10</p>
<h2 id="svd-derivative-cont-1"><a class="header" href="#svd-derivative-cont-1">SVD Derivative (cont.)</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\) is singular value decomposition \(\mathbf{Λ}=\mathrm{diag} (λ_0,λ_1,λ_2)\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =\mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+\mathbf{ΛB} 
$$</p>
<p>After expansion, we get:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F}}{∂\mathbf{F} _ {kl}}\mathbf{V}<br />
= \begin{bmatrix}
∂λ _ 0/∂\mathbf{F} _ {kl}  &amp; λ _ 1 a _ 0 + λ _ 0 b _ 0 &amp; λ _ 2 a_ 1 + λ _ 0 b _ 1 \\
−λ _ 0 a_ 0 − λ _ 1 b _ 0 &amp; ∂λ _ 1/∂ \mathbf{F} _ {kl} &amp; λ _ 2 a _ 2 + λ _ 1 b _ 2\\
−λ _ 0 a_ 1−λ_ 2b_ 1 &amp; −λ_ 1a_ 0a_ 2−λ_ 2b_ 2 &amp;∂λ_ 2/∂ \mathbf{F} _ {kl}
\end{bmatrix} 
$$</p>
<p>$$
\begin{bmatrix}
m_ {00} &amp; m_ {01} &amp; m_ {02} \\
m_ {10} &amp; m_ {11} &amp; m_ {12}  \\
m_ {20} &amp; m_ {21} &amp; m_ {22} 
\end{bmatrix} = \begin{bmatrix}
∂λ_0/∂\mathbf{F} _{kl}  &amp; λ_1a_0+λ_0b_0 &amp; λ_2a_1+λ_0b_1\\
−λ_0a_0−λ_1b_0 &amp; ∂λ_1/∂ \mathbf{F} _{kl} &amp; λ_2a_2+λ_1b_2\\
−λ_0a_1−λ_2b_1 &amp; −λ_1a_0a_2−λ_2b_2 &amp;∂λ_2/∂ \mathbf{F} _ {kl}
\end{bmatrix} 
$$</p>
<p>Eventually, we get: \(\mathbf{A=U^T} \frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}, \mathbf{B} = \frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\mathbf{V} \) and \(∂λ_0/∂\mathbf{F} _{kl}, ∂λ_1/∂\mathbf{F} _{kl}, ∂λ_2/∂\mathbf{F} _{kl}\).</p>
<p>P11</p>
<h2 id="a-quick-summary-2"><a class="header" href="#a-quick-summary-2">A Quick Summary</a></h2>
<ul>
<li>Step 1: By SVD derivatives, we get: \(\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}},\frac{∂λ_d}{∂\mathbf{F} _{kl}},\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\).</li>
</ul>
<p><img src="./assets/08-4.png" alt="" /></p>
<ul>
<li>Step 3: Finally, we reach our goal in Hessian matrix:</li>
</ul>
<p>$$
\frac{∂\mathbf{f} _i}{∂\mathbf{x} _j}=\sum _ {k,l}\frac{∂\mathbf{f} _i}{∂\mathbf{F} _{kl}} \frac{∂\mathbf{F} _{kl}}{∂\mathbf{x} _j}=\sum _ {k,l}
\frac{∂(\mathrm{Udiag} (\frac{∂W} {∂λ_0},\frac{∂W} {∂λ_1},\frac{∂W} {∂λ_2})\mathbf{V^T}) }{∂\mathbf{F} _{kl}}−V\mathbf{d} _i\frac{∂\mathbf{F} _{kl}}{∂\mathbf{x} _j}
$$</p>
<p>P12</p>
<h2 id="after-class-reading-8"><a class="header" href="#after-class-reading-8">After-Class Reading</a></h2>
<p>Xu et al. 2015. <em>Nonlinear Material Design Using Principal
Stretches</em>. TOG (SIGGRAPH).</p>
<p>Definitely read this paper if you decide to implement it.</p>
<p>P13</p>
<h2 id="implicit-integration-1"><a class="header" href="#implicit-integration-1">Implicit Integration</a></h2>
<p>P14</p>
<h1 id="implicit-integration-2"><a class="header" href="#implicit-integration-2">Implicit Integration</a></h1>
<p>Recall that we need implicit integration to avoid numerical instability (Class 5, page 13):</p>
<p>$$
\begin{cases} 
\mathbf{v} ^{[1]}=\mathbf{v} ^{[0]}+∆t\mathbf{M} ^{−1}\mathbf{f} ^{[1]} \\<br />
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[1]} 
\end{cases}
$$</p>
<p>$$\mathrm{or} $$</p>
<p>$$
\begin{cases} 
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f} ^{[1]}   \\<br />
\mathbf{v} ^{[1]}=(\mathbf{x} ^{[1]}−\mathbf{x} ^{[0]})/∆t<br />
\end{cases} 
$$</p>
<p>We also said that:</p>
<p>$$
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f}(\mathbf{x}^{[1]})
$$</p>
<p>$$
\Updownarrow
$$</p>
<p>$$
\mathbf{x} ^{[1]}=\mathrm{argmin } F (\mathbf{x} ) 	\quad  \mathrm{for} \quad\mathbf{F} (\mathbf{x} )=\frac{1}{2∆t^2}||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_M^2+E(\mathbf{x} )
$$</p>
<p>P15</p>
<h2 id="newton-raphson-method"><a class="header" href="#newton-raphson-method">Newton-Raphson Method</a></h2>
<p>The Newton-Raphson method, commonly known as Newton’s method, solves the optimization problem: \(x^{[1]}\)=argmin \(F(x)\).  	\(\quad\quad\)		\((F(x)\) is Lipschitz continuous.)</p>
<p>Given a current \(x^{(k)}\), we approximate our goal by:</p>
<p>$$
0={F}'(x)≈{F}'(x^{(k)})+{F}'' (x^{(k)})(x−x^{(k)})
$$</p>
<p><img src="./assets/08-6.png" alt="" /></p>
<p>P16</p>
<h3 id="newton-raphson-method-1"><a class="header" href="#newton-raphson-method-1">Newton-Raphson Method</a></h3>
<p>Now we can apply Newton’s method to: \(\mathbf{x} ^{[1]}\)= argmin \( F (\mathbf{x} )\).<br />
Given a current \(\mathbf{x}^{(k)}\), we approximate our goal by:</p>
<p>$$
\mathbf{0} =∇F(\mathbf{x} )≈∇F(\mathbf{x} ^{(k)})+\frac{∂F^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} (\mathbf{x} −\mathbf{x} ^{(k)}) 
$$</p>
<blockquote>
<p>Newton’s Method<br />
Initialize \(x^{(0)}\)<br />
For \(k=0…K\)<br />
$$
∆\mathbf{x} \longleftarrow −(\frac{∂F^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ^{(k)})
$$
$$
\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} 
$$
If \(||∆\mathbf{x}||\) is small	\(\quad\quad\)then break<br />
$$
\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}
$$</p>
</blockquote>
<p>P17</p>
<h3 id="simulation-by-newtons-method-1"><a class="header" href="#simulation-by-newtons-method-1">Simulation by Newton’s Method</a></h3>
<p>Specifically to simulation, we have:</p>
<p>$$
F (\mathbf{x} )=\frac{1}{2∆t^2} ||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_M^2+E(\mathbf{x} )
$$</p>
<p>$$
∇F(\mathbf{x} ^{(k)})=\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})−\mathbf{f} (\mathbf{x} ^{(k)})
$$</p>
<p>$$
\frac{∂^2F(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} =\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} (\mathbf{x} ^{(k)})
$$</p>
<blockquote>
<p>Initialize \(\mathbf{x}^{(0)}\), often as \(\mathbf{x} ^{[0]}\) or \(\mathbf{x} ^{[0]} +∆t\mathbf{v} ^{[0]}\)<br />
For \(k=0…K\)<br />
$$
\mathrm{Solve}\quad (\frac{1}{∆t^2} \mathbf{M+H} (\mathbf{x} ^{(k)}))∆\mathbf{x} =− \frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})
$$
$$
\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} 
$$
If ||\(∆\mathbf{x}\)|| is small \(\quad\quad\)	then break<br />
$$
\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}
$$
$$
\mathbf{v} ^{[1]}←(\mathbf{x} ^{[1]}−\mathbf{x} ^{[0]})/ ∆t
$$</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P18</p>
<h1 id="nonlinear-optimization"><a class="header" href="#nonlinear-optimization">Nonlinear Optimization</a></h1>
<p>P19</p>
<h2 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h2>
<p>Another way to solve \(\mathbf{x}^∗\)=argmin \(F(\mathbf{x})\) is the gradient descent method.</p>
<p><img src="./assets/08-7.png" alt="" /></p>
<p>How to find the optimal step size becomes a critical question.</p>
<p>P20</p>
<h3 id="step-size-adjustment"><a class="header" href="#step-size-adjustment">step size adjustment</a></h3>
<p><img src="./assets/08-8.png" alt="" /></p>
<p>优点：simple, Low overhead</p>
<p>P21</p>
<h3 id="descent-directions"><a class="header" href="#descent-directions">Descent Directions</a></h3>
<p>The direction \(\mathbf{d(x)}\) is descending, if a sufficiently small step size \(α\) exists for:</p>
<p>$$
F(\mathbf{x} )&gt;F(\mathbf{x} +α\mathbf{d} (\mathbf{x} ))
$$</p>
<p><img src="./assets/08-9.png" alt="" /></p>
<table><thead><tr><th>In other words, \(−∇F(\mathbf{x} )\cdot \mathbf{d} (\mathbf{x} )&gt;0\)</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅沿负梯度方向可以下降，但不一定是最好的方向。怎样判断一个方向是否可以下降？答：看与负梯度方向是否在同侧。</p>
</blockquote>
<p>P22<br />
With line search, we can use any search direction as long as it’s descending:</p>
<p>$$
F(\mathbf{x} ^{(0)})&gt;F(\mathbf{x} ^{(1)})&gt;F(\mathbf{x} ^{(2)})&gt;F(\mathbf{x} ^{(3)})&gt;…
$$</p>
<p><img src="./assets/08-10.png" alt="" /></p>
<p>P23</p>
<h2 id="descent-methods"><a class="header" href="#descent-methods">Descent Methods</a></h2>
<ul>
<li>Gradient descent is a descent method, since:</li>
</ul>
<p>$$
\mathbf{d} (\mathbf{x} )=−∇F(\mathbf{x} )\quad \Rightarrow  \quad −∇F(\mathbf{x} )\cdot (−∇F(\mathbf{x} ))&gt;0
$$</p>
<ul>
<li>Newton’s method is also a descent method, if the Hessian is always positive definite:</li>
</ul>
<p>$$
\mathbf{d} (\mathbf{x} )=−(\frac{∂^2F(\mathbf{x} )}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ) \quad \Rightarrow  \quad −∇F(\mathbf{x} )\cdot (−(\frac{∂^2F(\mathbf{x} )}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ))&gt;0
$$</p>
<blockquote>
<p>✅牛顿法不一定收敛，\(\mathbf{H}\)正定场景牛顿法一定收敛。</p>
</blockquote>
<ul>
<li><strong>Any method using a positive definite matrix P to modify the gradient</strong> yields a descent method:</li>
</ul>
<p>$$\mathbf{d} (\mathbf{x} )=−\mathbf{P} ^{−1}∇F(\mathbf{x} )
\quad \Rightarrow  \quad 
−∇F(\mathbf{x} )\cdot (−\mathbf{P} ^{−1}∇F(\mathbf{x} ))&gt;0
$$</p>
<p>P24</p>
<h2 id="a-unified-descent-framework"><a class="header" href="#a-unified-descent-framework">A unified descent framework</a></h2>
<p>A unified descent framework</p>
<p><img src="./assets/08-11-1.png" alt="" /></p>
<p><img src="./assets/08-11.png" alt="" /></p>
<p>P25<br />
<img src="./assets/08-12.png" alt="" /></p>
<blockquote>
<p>✅ 图形学中更关注 Total Cost. 让 P 更加接近 H，可以减少迭代数，让 P 更容易得到，减少迭代成本。<br />
Traction：物体表面上的力的密度，有点像压强</p>
</blockquote>
<p>P27</p>
<h3 id="after-class-reading-9"><a class="header" href="#after-class-reading-9">After-Class Reading</a></h3>
<p>Wang. 2016. Descent <em>Methods for Elastic Body Simulation
on the GPU</em>. TOG (SIGGRAPH Asia).</p>
<p>P28</p>
<h1 id="a-summary-for-the-day-5"><a class="header" href="#a-summary-for-the-day-5">A Summary For the Day</a></h1>
<ul>
<li>
<p>We can calculate the Hessian of the FEM elastic energy based on SVD derivatives.</p>
</li>
<li>
<p>The goal of doing this is for implicit time integration. </p>
</li>
<li>
<p>Fundamentally, the goal is to solve a nonlinear optimization.</p>
<ul>
<li>Gradient Descent, Newton’s method, and others can all be considered as descent methods.</li>
<li>The key question is the matrix for calculating the search direction.</li>
<li>We need both the per-iteration cost and the number of iterations to be small.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 模拟的公式通常都固定，很难有突破、瓶颈在于计算量、随着分辨率的提升，模拟的计算量几乎是无止境的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P41</p>
<h1 id="intersection-elimination"><a class="header" href="#intersection-elimination">Intersection Elimination</a></h1>
<ul>
<li>
<p>Let’s consider how to eliminate existing intersections, but without using any collision history.</p>
</li>
<li>
<p>Such a method is useful when there are already intersections in simulation, due to:</p>
<ul>
<li>Past collision handling failures</li>
<li>Intense user interaction</li>
</ul>
</li>
<li>
<p>In this case, we don’t require the simulation is to always <u>intersection-free</u>.</p>
</li>
</ul>
<p>P42</p>
<h2 id="对于有体积的物体"><a class="header" href="#对于有体积的物体">对于有体积的物体</a></h2>
<p>Eliminating cloth-volume and volume-volume intersections is straightforward: simply pushing vertices/edges in the volume out.</p>
<p><img src="./assets/09-32.png" alt="" /></p>
<p>P43</p>
<h2 id="对于没有体积的物体untangling-cloth问题"><a class="header" href="#对于没有体积的物体untangling-cloth问题">对于没有体积的物体，Untangling Cloth问题</a></h2>
<p>The situation is complicated in cloth-cloth intersection, since we don’t have a clear definition of inside and outside.</p>
<h2 id="方法一-1"><a class="header" href="#方法一-1">方法一</a></h2>
<h3 id="算法过程-2"><a class="header" href="#算法过程-2">算法过程</a></h3>
<p>Baraff et al. used flood-fill to segment cloth into regions and decided which region is in intersection. (<strong>Cannot handle boundary well</strong>.)</p>
<p><img src="./assets/09-33.png" alt="" /></p>
<p>Baraff et al. 2003. Untangling Cloth. TOG (SIGGRAPH)</p>
<blockquote>
<p>✅P42适用于有体积的物体，但布没有封闭体积，两根线没有里面外面之分，因此相交时不知道哪一段是正确的。<br />
✅ 方法：对布分段，根据分段区域决定谁在上谁在下，以此为依据推动顶点。<br />
✅ 此方法缺点：1. 无法处理边界；2. 难以在 GPU 上实 现；</p>
</blockquote>
<p>P44</p>
<h3 id="算法效果"><a class="header" href="#算法效果">算法效果</a></h3>
<p><img src="./assets/09-34-1.png" alt="" /></p>
<p>Baraff et al. 2003. Untangling Cloth. TOG (SIGGRAPH)</p>
<blockquote>
<p>✅缺点：1. 难以处理边界；2. 对整个面进行评估，难以用于GPU.</p>
</blockquote>
<p>P45</p>
<h2 id="方法二-1"><a class="header" href="#方法二-1">方法二</a></h2>
<p>Volino and Magnenat-Thalmann proposed to untangle cloth by reducing the
intersection contour.<br />
Their method can handle boundaries, but it doesn’t always work.</p>
<p><img src="./assets/09-35.png" alt="" /></p>
<blockquote>
<p>✅ 两个面相交会产生一条曲线，目标是让曲线变短。优点：可以处理边界；缺点：基于局部优化、可用于 GPU。<br />
✅可以处理边界情况，缩短边界也能解除相交。</p>
</blockquote>
<p>P46</p>
<h3 id="after-class-reading-10"><a class="header" href="#after-class-reading-10">After-Class Reading</a></h3>
<p>Volino and Magnenat-Thalmann et al. 2006. <em>Resolving
Surface Collisions through Intersection Contour
Minimization</em>. TOG (SIGGRAPH).</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="physics-based-animation-topics"><a class="header" href="#physics-based-animation-topics">Physics-Based Animation Topics</a></h2>
<p>P56</p>
<p><img src="./assets/01-15.png" alt="" /></p>
<blockquote>
<p>✅ </p>
</blockquote>
<blockquote>
<p>流体：烟通常使用粒子法或网格法。水波可以看作是整体，因此能用 mesh，用 mesh的好处是可以做到实时，Grid 的好处是更真实。Splashes(水花)的问题是多变，因此不能实时，通常使用粒子和网格。<br />
Hybrid 方法：MPM = Particle + Grid,兼容二者优点，常用于模拟雪或粘滞物体<br />
Coupling: 场景中同时有不同类别的物体，怎样模拟它们的交互。<br />
✅ SPA 与弹性体模拟结合，可用于模拟物体破碎， 粒子法与网格法相结合，称为 MPM. 用于模拟雪、沙子。 </p>
</blockquote>
<p>P59</p>
<h2 id="topics-in-this-class"><a class="header" href="#topics-in-this-class">Topics in This Class</a></h2>
<p><img src="./assets/1-16.png" alt="" /></p>
<blockquote>
<p>✅<br />
Fracture 有大量的 remesh。游戏引擎中的 Fracture 通常通过预计算而不是模拟得到。<br />
Rigid 还是Soft,看有没有形变。<br />
Mesh 定义在物体上， Grid 定义在场景上<br />
水波 Mesh 也会讲，图上漏掉了。 </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="fluid-effects"><a class="header" href="#fluid-effects">Fluid Effects</a></h1>
<p>Unlike other bodies, Fluids exhibit highly volatile behaviors. As a result, it’s difficult to come up with a single, efficient way for simulating all of fluid effects.</p>
<blockquote>
<p>✅ 流体的形态很多，例如水滴、水花、水浪，对应的模拟方法也不同。难以用通用的方法高效地模拟所有场景。</p>
</blockquote>
<p>P3</p>
<h1 id="two-types-of-simulation-approaches"><a class="header" href="#two-types-of-simulation-approaches">Two Types of Simulation Approaches</a></h1>
<table><thead><tr><th><img src="./assets/10-1.png" alt="" /></th><th><img src="./assets/10-2.png" alt="" /></th></tr></thead><tbody>
<tr><td>Lagrangian Approach <br>(dynamic particles or mesh)<br> Node movement carries physical quantities (mass, velocity, …).</td><td>Eulerian Approach <br> (static grid or mesh) <br> Grid/Mesh doesn’t move.  Stored physical quantities change.</td></tr>
<tr><td>✅ 左：无 Grid. 物理量附加在粒子上，粒子运动时更新自身物理量。</td><td>✅ 右：固定 Grid. 物理量固定在 Grid 上。粒子运动后统一新格子的物理量。</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="a-height-field-model"><a class="header" href="#a-height-field-model">A Height Field Model</a></h1>
<h2 id="高度场height-field和速度场"><a class="header" href="#高度场height-field和速度场">高度场（Height Field）和速度场</a></h2>
<p>P5</p>
<h3 id="高度场height-field和速度场的定义"><a class="header" href="#高度场height-field和速度场的定义">高度场（Height Field）和速度场的定义</a></h3>
<p><img src="./assets/10-3.png" alt="" /></p>
<blockquote>
<p>✅ 利用高度函数来表达波的平面，通过更新\(h(x)\)来表达水面随时间波动的效果。<br />
✅ 由于用函数表达，无法描述大海浪的效果，因为这种情况下一个位置对应多个高度。<br />
✅ 速度场描述水流的速度和方向， 速度&lt; 0 则右往左， &gt; 0 则左往右。</p>
</blockquote>
<p>P6</p>
<h3 id="高度场的更新"><a class="header" href="#高度场的更新">高度场的更新</a></h3>
<p><img src="./assets/10-4-1.png" alt="" /> </p>
<blockquote>
<p>✅ 高度场更新公式第一项：高度场随时间的变化。<br />
✅ 高度场更新公式第二项，根据微分的定义：<br />
\(h(x)u(x)\): 单位时间内流过x线的水量。<br />
\(d(h(x)u(x))\) ：单位时间内区域 \([x \quad x+dx]\) 的水量变化、<br />
\(d(h(x)u(x))1/dx\) ：单位时间内区域区 \([x \quad x+dx]\) 的水位高度变化</p>
</blockquote>
<p>P7</p>
<h3 id="速度场的更新"><a class="header" href="#速度场的更新">速度场的更新</a></h3>
<p>The velocity is also a function of \(x:u(x)\).</p>
<p><img src="./assets/10-5-1.png" alt="" /></p>
<blockquote>
<p>✅ 第一项：当水在流动时，速度应该跟水一起流动，下节课再讲。<br />
✅ 第三项：外力，当前也不考虑。</p>
</blockquote>
<p>P8</p>
<p>Ignoring advection and external acceleration, we get a simple form:</p>
<p>$$
\begin{matrix}
\frac{du(x)}{dt}=−\frac{1}{ρ} \frac{dP(x)}{dx} \quad \quad &amp; ρ: \text{density} \quad \quad &amp; P(x):\text{pressure}
\end{matrix}
$$</p>
<p><img src="./assets/10-6.png" alt="" /></p>
<blockquote>
<p>✅ 第二项： 在短时间内、速度变化由左右压强差决定。同样的压强下，密度大则难推，密度小则好推。</p>
</blockquote>
<p>P9</p>
<h2 id="shallow-wave-equation"><a class="header" href="#shallow-wave-equation">Shallow Wave Equation</a></h2>
<blockquote>
<p>✅ 为什么叫 Shallow Wave, 因为该算法假设水波很小，因此 \(dh / dx\) 可忽略不计。</p>
</blockquote>
<p>We now have two equations:</p>
<p><img src="./assets/10-7.png" alt="" /> </p>
<blockquote>
<p>✅ 公式化简的目的：不需要关心速度场\(u\)、仅关注高度场就可以。<br />
✅ 第一个公式：（1）对\(d(hu)\)展开（2）再求一次\(dt\)<br />
✅ 第二个公式：对\(x\)求导</p>
</blockquote>
<p>We can then eliminate \(u\) and formulate the shallow wave equation:</p>
<table><thead><tr><th>$$\frac{d^2ℎ}{dt^2} =\frac{ℎ}{ρ} \frac{d^2P}{dx^2} $$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 合并同类项，得到最终方程<br />
✅ 但引擎无法直接处理微分程，因此要离散化开求解。</p>
</blockquote>
<p>P10</p>
<h2 id="高度场离散化"><a class="header" href="#高度场离散化">高度场离散化</a></h2>
<p>We discretize a continuous height field into a discrete set of height columns.</p>
<p><img src="./assets/10-8.png" alt="" /></p>
<blockquote>
<p>✅ 高度场离散又化为多个水柱，微分算子也要离散化。</p>
</blockquote>
<p>P11</p>
<h2 id="微分算子离散化"><a class="header" href="#微分算子离散化">微分算子离散化</a></h2>
<h3 id="前向差分与后向差分"><a class="header" href="#前向差分与后向差分">前向差分与后向差分</a></h3>
<p>The idea of finite differencing is to use the difference to approximate the derivative.</p>
<p>$$
f(t_0+∆t)=f(t_0)+∆t\frac{df(t_0)}{dt} +\frac{∆t^2}{2} \frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Forward differencing (first-order)</p>
<table><thead><tr><th>$$\frac{df(t_0)}{dt} ≈\frac{f(t_0+∆t)−f(t_0)}{∆t}$$</th></tr></thead><tbody>
</tbody></table>
<p>$$
f(t_0−∆t)=f(t_0)−∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Backward differencing (first-order)</p>
<table><thead><tr><th>$$ \frac{df(t_0)}{dt}≈\frac{f(t_0)−f(t_0−∆t)}{∆t} $$</th></tr></thead><tbody>
</tbody></table>
<p>P12</p>
<h3 id="central-differencing"><a class="header" href="#central-differencing">Central Differencing</a></h3>
<p>The idea of finite differencing is to use the difference to approximate the derivative.</p>
<p>$$
f(t_0+∆t)=f(t_0)+∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>$$
f(t_0−∆t)=f(t_0)−∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Central differencing (second-order)</p>
<table><thead><tr><th>$$ \frac{df(t_0)}{dt}≈\frac{f(t_0+∆t)−f(t_0−∆t)}{2∆t} $$</th></tr></thead><tbody>
</tbody></table>
<p>P13</p>
<h2 id="二阶微分算子离散化"><a class="header" href="#二阶微分算子离散化">二阶微分算子离散化</a></h2>
<h3 id="高度"><a class="header" href="#高度">高度</a></h3>
<p>We apply central differencing twice to estimate \(d^2ℎ_i/dt^2\).</p>
<p>$$
\begin{matrix}
\frac{dℎ_i(t_0+0.5∆t)}{dt}≈\frac{ℎ_i(t_0+∆t)−ℎ_i(t_0)}{∆t}  \quad\quad&amp; \frac{dℎ_i(t_0−0.5∆t)}{dt}≈\frac{ℎ_i(t_0)−ℎ_i(t_0−∆t)}{∆t} 
\end{matrix}
$$</p>
<table><thead><tr><th>$$\frac{d^2ℎ_i(t_0)}{dt^2}≈\frac{\frac{dℎ_i(t_0+0.5∆t)}{dt}−\frac{dℎ_i(t_0−0.5∆t)}{dt} }{∆t} ≈\frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/10-12.png" alt="" /></p>
<blockquote>
<p>✅ 先用 central difference 求出两个中点的一阶导数，再基于此计算 \(t_0\) 处的二阶导。这种操作又称为一维Laplace 算子。</p>
</blockquote>
<p>P14</p>
<h3 id="压强"><a class="header" href="#压强">压强</a></h3>
<p>Similarly, we apply central differencing twice to estimate \(d^2P/dx^2\).</p>
<p>$$
\begin{matrix}
\frac{dP_{i+0.5}}{dt} ≈\frac{P_{i+1}−P_i}{∆x} \quad\quad &amp; \frac{dP_{i−0.5}}{dx} ≈\frac{P_i−P_{i−1}}{∆x} 
\end{matrix}
$$</p>
<table><thead><tr><th>$$\frac{d^2P_i}{dx^2}≈\frac{\frac{dP_{i+0.5}}{dx}−\frac{dP_{i−0.5}}{dx}}{∆x} ≈\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/10-13.png" alt="" /></p>
<blockquote>
<p>✅ 二维情况用周围4个元素，见 Games102 离散拉普拉斯算子。</p>
</blockquote>
<p>P15</p>
<h2 id="discretized-shallow-wave-equation"><a class="header" href="#discretized-shallow-wave-equation">Discretized Shallow Wave Equation</a></h2>
<p>We can now discretize the shallow wave equation \(\frac{d^2ℎ}{dt^2}=\frac{ℎ}{ρ}\frac{d^2P}{dx^2}\).</p>
<table><thead><tr><th>\(\begin{matrix}\ \frac{d^2ℎ_i(t_0)}{dt^2}≈\frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}\quad  &amp;\frac{d^2P_i}{dx^2 }≈\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2}\\\end{matrix}\)</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\Rightarrow \frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}=\frac{ℎ_i}{ρ} (\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2})\)</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\Rightarrow ℎ_i(t_0+∆t)=2ℎ_i(t_0)−ℎ_i(t_0−∆t)+\frac{∆t^2ℎ_i}{∆x^2ρ}(P_{i+1}+P_{i−1}−2P_i)\)</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 更新目标：下一个时刻的水柱的高度，即 \(h_i(t_0 + ∆t)\)<br />
✅ 但按此公式模拟可能出现水的体积变多或变少的问题。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P16</p>
<h1 id="volume-preservation"><a class="header" href="#volume-preservation">Volume Preservation</a></h1>
<p>We want the volume to stay the same. Suppose that \(\sum ℎ_i(t)=\sum ℎ_i(t−∆t)=V\). But,</p>
<p>$$
ℎ_i(t_0+∆t)=2ℎ_i(t_0)−ℎ_i(t_0−∆t)+\frac{∆t^2ℎ_i}{∆x^2ρ}(P_{i+1}+P_{i−1}−2P_i)
$$</p>
<p><img src="./assets/10-14.png" alt="" /></p>
<blockquote>
<p>✅ 体积会变大还是变小，取决于桔色项，但很难保证这一项是0.</p>
</blockquote>
<p>P17</p>
<h2 id="volume-preservation--solution-1"><a class="header" href="#volume-preservation--solution-1">Volume Preservation – Solution 1</a></h2>
<p><img src="./assets/10-15.png" alt="" /></p>
<blockquote>
<p>✅ 保证 \(h_i\) 和 \(h_{i+1}\)的交换的水量相等、因此保体积<br />
✅ 把\(h_{i-1}\)与\(h_i\)的交换和\(h_i\)与\(h_{i+1}\)的交换拆开。即：<br />
（1）把\((P_{i+1}+P_{i−1}−2P_i)\)拆成\(P_{i−1}−P_i\)和\(P_{i+1}−P_i\)<br />
（2）把\(h_i\)拆成\(\frac{h_{i-1}+h_i}{2}\)和\(\frac{h_{i+1}+h_i}{2}\)<br />
✅ 直观理解：对每个水柱而言，流入的量和流出的量是等价的。</p>
</blockquote>
<p>P18</p>
<blockquote>
<p>🔎 Kass and Miller. 1990. <em>Rapid, Stable Fluid Dynamics for Computer Graphics</em>. Computer Graphics.</p>
</blockquote>
<p>P19</p>
<h2 id="volume-preservation--solution-2"><a class="header" href="#volume-preservation--solution-2">Volume Preservation – Solution 2</a></h2>
<p>An easier way to preserve volume is to <strong>simply assume</strong> \(h_i\) in the right term is constant.</p>
<p><img src="./assets/10-16.png" alt="" /></p>
<p>P20</p>
<h1 id="pressure"><a class="header" href="#pressure">Pressure</a></h1>
<p><img src="./assets/10-17.png" alt="" /> </p>
<p>P21</p>
<h1 id="viscosity"><a class="header" href="#viscosity">Viscosity</a></h1>
<p>Like damping, viscosity tries to slow down the waves. </p>
<p><img src="./assets/10-18-1.png" alt="" /> </p>
<blockquote>
<p>✅ Viscosity: 粘滞，相当于流体的阻尼。</p>
</blockquote>
<p>P22</p>
<h1 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h1>
<p>$$\text{A Shallow Wave Simulator}$$
For every cell \(i\)
$$ℎ_i^{new}←ℎ_i+β(ℎ_i−ℎ_i^{old})\\
ℎ_i^{new}←ℎ_i^{new}+α(ℎ_{i−1}−ℎ_i)\\
ℎ_i^{new} ←ℎ_i^{new}+α(ℎ_{i+1}−ℎ_i)\\$$
For every cell \(i\)
$$ℎ_i^{old}←ℎ_i\\<br />
ℎ_i←ℎ_i^{new}$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P23</p>
<h1 id="boundary-conditions"><a class="header" href="#boundary-conditions">Boundary Conditions</a></h1>
<h2 id="dirichlet-boundary"><a class="header" href="#dirichlet-boundary">Dirichlet boundary</a></h2>
<p><img src="./assets/10-19-1.png" alt="" /> </p>
<p>A Dirichlet boundary assumes that the boundary height \(H_{i+1}\) is constant.  It’s considered as an open boundary.</p>
<p>$$
ℎ_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i=H_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i
$$</p>
<p><img src="./assets/10-19-2.png" alt="" /> </p>
<blockquote>
<p>✅ 这种方法用于模拟开放的水面，例如大海的区域、假设被模拟的区域外是静止的水面、高度为常数，(Dirichlet)<br />
✅ \(h\)为边界内，\(H\)为边界外。</p>
</blockquote>
<p>P25</p>
<h2 id="algorithm-with-neumann-boundaries"><a class="header" href="#algorithm-with-neumann-boundaries">Algorithm with Neumann Boundaries</a></h2>
<p>Extending the simulator to 3D is also straightforward.</p>
<p><img src="./assets/10-19-3.png" alt="" /> </p>
<h2 id="neumann-boundary"><a class="header" href="#neumann-boundary">Neumann boundary</a></h2>
<p>A Neumann boundary specifies the boundary derivatives.  For example, a zero-derivative boundary means \(ℎ_{i+1}≡ℎ_i\).  It’s considered as a closed boundary.</p>
<p>$$
ℎ_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i=ℎ_{i−1}−ℎ_i
$$</p>
<blockquote>
<p>✅ Neuman 用于模拟有边界水域，例如池堂、假设边界上没有水流交换。</p>
</blockquote>
<p>P24</p>
<p><img src="./assets/10-19-4.png" alt="" /> </p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P26</p>
<h2 id="two-way-coupling"><a class="header" href="#two-way-coupling">Two-Way Coupling</a></h2>
<blockquote>
<p>✅ 水和水中的物体相互作用，物体可以是刚体、弹性体能各种类型的物体。</p>
</blockquote>
<p>The coupling between a solid and a liquid should be two-way, i.e., liquid-&gt;solid and solid-&gt;liquid.</p>
<p><img src="./assets/10-20.png" alt="" /></p>
<blockquote>
<p>✅ 水 → 物体：浮力。物体 → 水，会把这个水柱的水排出去，此处只讲 “物体 → 水” 部分</p>
</blockquote>
<p>P27</p>
<h2 id="关键问题"><a class="header" href="#关键问题">关键问题</a></h2>
<p>The coupling between solid and water should be two-way, i.e., water&gt;solid and solid- &gt;water.</p>
<p>The key question is how to expel water out of the gray cell regions???</p>
<p><img src="./assets/10-21.png" alt="" /></p>
<p>P28</p>
<h2 id="virtual-height"><a class="header" href="#virtual-height">Virtual Height</a></h2>
<blockquote>
<p>✅ 在要排的水柱上面增加一个虚拟的高度，然后正常模拟，关键是求出要加多少虚拟高度，能正好达到排出那么多水的效果。</p>
</blockquote>
<p>The idea is to set up a virtual height \(v_i\), so that  \(ℎ_i^\text{real_new}=ℎ_i−e_i\).</p>
<p>$$
ℎ_i−e_i=ℎ_i+β(ℎ_i−ℎ_i^{old})+α(v_{i+1}+ℎ_{i+1}+ℎ_{i−1}−2v_i−2{ℎ_i})=ℎ_i^{new}+α(v_{i+1}−2v_i)
$$</p>
<blockquote>
<p>✅ \(ℎ_i^\text{real_new}=ℎ_i−e_i\)：下图左边格子的理想高度。</p>
</blockquote>
<p>$$
ℎ_{i+1}−e_{i+1}=ℎ_{i+1}+β(ℎ_{i+1}−ℎ_{i+1}^{old})+α(ℎ_{i+2}+v_i+ℎ_i−2v_{i+1}−2ℎ_{i+1})=ℎ_{i+1}^{new}+α(v_i−2v_{i+1})
$$</p>
<blockquote>
<p>✅ 公式2对应右边格子。</p>
</blockquote>
<p><img src="./assets/10-22.png" alt="" /></p>
<p>P29</p>
<h2 id="poissons-equation"><a class="header" href="#poissons-equation">Poisson’s Equation</a></h2>
<p>The outcome is Poisson’s equation, with \(v_i\) and \(v_{i+1}\) being unknowns.</p>
<p>$$
2v_i−v_{i+1}=\frac{1}{α}(ℎ_i^{new}−ℎ_i+e_i)=b_i
$$</p>
<p>$$
−v_i+2v_{i+1}=\frac{1}{α}(ℎ_{i+1}^{new}−ℎ_{i+1}+e_{i+1})=b_{i+1}
$$</p>
<blockquote>
<p>✅ 通过公式化简提取出其中的线性关系。</p>
</blockquote>
<p>P30</p>
<p>The outcome is Poisson’s equation, with \(v_i\) and \(v_{i+1}\) being unknowns.</p>
<p><img src="./assets/10-24-1.png" alt="" /></p>
<blockquote>
<p>✅ 由于木块位置会变，需要解的\(v_i\)也要改变。 为了让公式统一方便计算，把图左矩阵乘法写成右边形式。公式结果不变，只是工程实现上的简化。</p>
</blockquote>
<p>P31</p>
<h2 id="algorithm-with-coupling"><a class="header" href="#algorithm-with-coupling">Algorithm with Coupling</a></h2>
<p><img src="./assets/10-25.png" alt="" /></p>
<blockquote>
<p>✅ \(\gamma \) 的作用：本算法显式积分，不稳定、\(\gamma \) 会让水波小很多。</p>
</blockquote>
<p>P32</p>
<h2 id="rigid-body-update"><a class="header" href="#rigid-body-update">Rigid Body Update</a></h2>
<p>We estimate the floating force by the actual water expelled in every column.</p>
<p><img src="./assets/10-26.png" alt="" /></p>
<p>$$
f_i=ρg∆x(ℎ_i−ℎ_i^{new})
$$</p>
<p>Or in 3D,</p>
<p>$$
f_{i,j}=ρg∆A(ℎ_{i,j}−ℎ_{i,j}^{new})
$$</p>
<blockquote>
<p>✅ 阿基米得定律：物体受到的浮力 = 排出去的水的重力<br />
✅ 同时要考虑旋转和力矩。但目前旋转的效果不太好，可以考虑改进为隐式积分。<br />
✅ 流体对方块的效果。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P33</p>
<h2 id="a-summary-for-the-day-6"><a class="header" href="#a-summary-for-the-day-6">A Summary For the Day</a></h2>
<ul>
<li>
<p>The shallow wave model simulates waves over a height field.</p>
</li>
<li>
<p>It’s based on a lot of simplification. We will discuss what fluid dynamics really looks like without simplification.</p>
</li>
<li>
<p>The strength of the shallow wave model is its <strong>simplicity</strong> and <strong>efficiency</strong>. It can easily simulate water-solid coupling too.</p>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="topics-for-the-day-5"><a class="header" href="#topics-for-the-day-5">Topics for the Day</a></h1>
<ul>
<li>
<p>A Grid Representation and Finite Differencing</p>
</li>
<li>
<p>Incompressible, Viscous Navier Stokes’ equations</p>
</li>
</ul>
<blockquote>
<p>✅ Incompressible：粒子不可压缩<br />
✅ Viscous：有粘滞</p>
</blockquote>
<ul>
<li>Air and liquid</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="a-grid-representation-and-finite-differencing"><a class="header" href="#a-grid-representation-and-finite-differencing">A Grid Representation and Finite Differencing</a></h1>
<p>P4</p>
<h2 id="a-regular-grid-representation"><a class="header" href="#a-regular-grid-representation">A Regular Grid Representation</a></h2>
<p><img src="./assets/11-01.png" alt="" /></p>
<blockquote>
<p>✅ 把场定义在标准格子上的好处：(1)把物理量定义在格子的中心（2）计算导数或利用导数进行微分计算变得容易了。<br />
✅ 上节课grid用1D来表示2D，2D表示3D，不是真正的grid方法。<br />
🔎 Central Differencing：L10.</p>
</blockquote>
<p>P6</p>
<h2 id="finite-differencing-on-grid"><a class="header" href="#finite-differencing-on-grid">Finite Differencing on Grid</a></h2>
<h3 id="一阶层数"><a class="header" href="#一阶层数">一阶层数</a></h3>
<p>The grid is very friendly with central differencing.</p>
<p><img src="./assets/11-2.png" alt="" /></p>
<table><thead><tr><th>$$\frac{∂f_{i+0.5,j}}{∂x}≈\frac{f_{i+1,j}−f_{i,j}}{ℎ}$$</th></tr></thead><tbody>
</tbody></table>
<p>P7</p>
<h3 id="二阶导数"><a class="header" href="#二阶导数">二阶导数</a></h3>
<p>The grid is very friendly with central differencing.</p>
<p><img src="./assets/11-3.png" alt="" /></p>
<p>P8</p>
<h3 id="discretized-laplacian"><a class="header" href="#discretized-laplacian">Discretized Laplacian</a></h3>
<p>We can then obtain the discretized Laplacian operator on grid.</p>
<p><img src="./assets/11-4.png" alt="" /></p>
<p>$$
\frac{∂^2f_{i,j}}{∂x^2}≈\frac{\frac{∂f_{i−0.5,j}}{∂x}−\frac{∂f_{i+0.5,j}}{∂x}}{ℎ}≈\frac{f_{i−1,j}+f_{i+1,j}−2f_{i,j}}{ℎ^2}
$$</p>
<p>$$
\frac{∂^2f_{i,j}}{∂y^2}≈\frac{\frac{∂f_{i,j+0.5}}{∂y}−\frac{∂f_{i,j−0.5}}{∂y}}{ℎ} ≈\frac{f_{i,j−1}+f_{i,j+1}−2f_{i,j}}{ℎ^2} 
$$</p>
<table><thead><tr><th>$$∆f_{i,j}=\frac{∂^2f_{i,j}}{∂x^2}+\frac{∂^2f_{i,j}}{∂y^2}≈\frac{f_{i−1,j}+f_{i+1,j}+f_{i,j−1}+f_{i,j+1−4}f_{i,j}}{ℎ^2} $$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 网格上的Laplace算子。</p>
</blockquote>
<p>P9</p>
<h2 id="boundary-conditions-1"><a class="header" href="#boundary-conditions-1">Boundary Conditions</a></h2>
<p>The boundary condition specifies \(f_{i−1,j}\) if it’s outside.</p>
<p><img src="./assets/11-5.png" alt="" /></p>
<p>A <strong>Dirichlet</strong> boundary: \(f_{i−1,j}=C\)</p>
<table><thead><tr><th>$$ ∆f_{i,j}≈\frac{C+f_{i+1,j}+f_{i,j−1}+f_{i,j+1}−4f_{i,j}}{ℎ^2}$$</th></tr></thead><tbody>
</tbody></table>
<p>A <strong>Neumann</strong> boundary: \(f_{i−1,j}=f_{i,j}\)</p>
<table><thead><tr><th>$$∆f_ {i,j} ≈ \frac{f_ {i+1,j}+f_ {i,j−1}+f_ {i,j+1}−3f_{i,j}}{ℎ^2}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 至少有一个边界使用Dirithlet．否则会全部收缩为0．<br />
✅ Neumann是约束相对关系，没有绝对数值，会有无穷多解。</p>
</blockquote>
<p>P12</p>
<h3 id="diffusion"><a class="header" href="#diffusion">Diffusion</a></h3>
<p>The process of applying Laplacian smoothing is called <strong>diffusion</strong>.</p>
<blockquote>
<p>✅ Laplace的本质是与邻居做平均。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P13</p>
<h1 id="problem-with-central-differencing"><a class="header" href="#problem-with-central-differencing">Problem with Central Differencing</a></h1>
<p>Central differencing gives the derivative in the middle.</p>
<p><img src="./assets/11-6.png" alt="" /></p>
<ul>
<li>
<p>The cell doesn’t exist at (i+0.5, j).</p>
</li>
<li>
<p>To get \( \frac{∂f_ {i,j}}{∂x} \), we need \(f_{i−1,j}\) and \(f_{i+1,j}\).  But this is weird, because \(f_{i,j}\) is unused.</p>
</li>
</ul>
<blockquote>
<p>✅ 前面假设所有物理量定义在格子的中间。但此处算出来的一阶微分量不在格子中间。 </p>
</blockquote>
<p>P14</p>
<h2 id="solution-staggered-grid"><a class="header" href="#solution-staggered-grid">Solution: Staggered Grid</a></h2>
<blockquote>
<p>✅ 不规定所有物理量都定义在格子中间，也可以定义在墙上。</p>
</blockquote>
<p>We define some physical quantities on faces, specifically <strong>velocities</strong>.</p>
<p><img src="./assets/11-7.png" alt="" /></p>
<ul>
<li>
<p>The x-part of the velocity is defined on vertical faces.</p>
</li>
<li>
<p>The y-part of the velocity is defined on horizonal faces.</p>
</li>
</ul>
<blockquote>
<p>✅ 把速度定义在墙上的好处量，速度是矢量、可以用不同方向的墙表达不同方向上的速度、直观。</p>
</blockquote>
<ul>
<li><strong>Intuitively</strong>, they represent the flow speed between two cells. For example, we write the volume changing speed at cell (i,j) as:</li>
</ul>
<table><thead><tr><th>$$u_{i+1,j}+v_{i,j+1}−u_{i,j}−v_{i,j}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 通过四面墙上的速度计算当前格子的净流出（注意正负号）</p>
</blockquote>
<p>P15</p>
<h2 id="divergence-free-condition"><a class="header" href="#divergence-free-condition">Divergence-Free Condition</a></h2>
<p>No volume change is equal to say the fluid is incompressible. This can be formally written as a divergence-free velocity field.</p>
<p><img src="./assets/11-8-1.png" alt="" /></p>
<blockquote>
<p>❓ 这一页没听懂、净流入流出为0，水面还怎么动呢？<br />
✅ 由于格子不可压，每个格子的净流出（入）应该为0．<br />
✅ \(\nabla\)为散度符号，见前面课程。<br />
✅ 公式1为直观理解，公式2为数学推导，本质上是一致的。</p>
</blockquote>
<p>P16</p>
<h2 id="bilinear-interpolation"><a class="header" href="#bilinear-interpolation">Bilinear Interpolation</a></h2>
<blockquote>
<p>🔎 双线性插值：见GAMES 101</p>
</blockquote>
<p>P17</p>
<p>We use bilinear interpolation to interpolate staggered velocities as well.</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P18</p>
<h1 id="incompressible-viscous--navier-stokes-equations"><a class="header" href="#incompressible-viscous--navier-stokes-equations">Incompressible, Viscous  Navier-Stokes Equations</a></h1>
<p>P19</p>
<h2 id="equation-fomulation"><a class="header" href="#equation-fomulation">Equation Fomulation</a></h2>
<p><img src="./assets/11-9.png" alt="" /></p>
<blockquote>
<p>✅ 这是一个描述了速度场的公式，它可以告许你速度如何更新。公式1限制不可压，公式2 diffusion 的目的是粘滞。</p>
</blockquote>
<p>Method of Characteristics: solving a long partial differential equation (PDE) in steps</p>
<ul>
<li>Step 1: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=\mathbf{g}\)</li>
<li>Step 2: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−(\mathbf{u}\cdot ∇)\mathbf{u}\)</li>
<li>Step 3: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=υ∆\mathbf{u}\)</li>
<li>Step 4: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−∇\mathbf{p}\)</li>
</ul>
<blockquote>
<p>✅ 把偏微分方程分解几个小块，依次轮流优化每一小块。<br />
❓ 这种方法为什么可行？</p>
</blockquote>
<p>P20</p>
<h2 id="step-1-external-acceleration"><a class="header" href="#step-1-external-acceleration">Step 1: External Acceleration</a></h2>
<p>The Update of \(\mathbf{u}\) by \(∂\mathbf{u}∕∂t=\mathbf{g}\) is straightforward, just add acceleration to \(u\) and \(v\).</p>
<p><img src="./assets/11-10.png" alt="" /></p>
<blockquote>
<p>✅ \(v_{i,j}\)代表向下的速度，对所有格子更新\(v_{i,j}\).<br />
✅ 其它外部速度同理。</p>
</blockquote>
<p>P21</p>
<h2 id="step-2-advection"><a class="header" href="#step-2-advection">Step 2: Advection</a></h2>
<blockquote>
<p>✅  Advection,代表流动。即速度会跟着粒子移动，基于欧拉的方法才需要考虑这个问题。因为固定的格子无法描述水的流动。<br />
✅ 基于拉格朗日的方法，变量定义在粒子上，天然满足这个特点。</p>
</blockquote>
<h3 id="数学模型"><a class="header" href="#数学模型">数学模型</a></h3>
<p>Next we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−(\mathbf{u}\cdot ∇)\mathbf{u}\).</p>
<p><img src="./assets/11-11.png" alt="" /></p>
<table><thead><tr><th>$$(\mathbf{u} \cdot ∇)\mathbf{u} =u\cdot \frac{∂u}{∂x} +v\cdot \frac{∂v}{∂\mathbf{y}} $$</th></tr></thead><tbody>
</tbody></table>
<p>Solving this in an Eulerian way can be a source of instability.</p>
<blockquote>
<p>✅ Eulerian way： \(\mathbf{u}^{\mathrm{new} }=\frac{\partial u}{\partial t} ·Δt＋\mathbf{u}\) 不稳定</p>
</blockquote>
<p>To solve this problem, we come to realize that advection means to carry physical quantities by velocity.</p>
<p>P22</p>
<h3 id="solution-semi-lagrangian-method"><a class="header" href="#solution-semi-lagrangian-method">Solution: Semi-Lagrangian Method</a></h3>
<p>The solution is to trace a virtual particle backward over time.</p>
<blockquote>
<p>✅ 例如要求\(\mathbf{x}_0\)的速度，倒推哪个粒子会运动到\(\mathbf{x}_0\)处;因此找到\(\mathbf{x}_1\)，从\(\mathbf{x}_1\)的下一刻速度来更新\(\mathbf{x}_0\)的速度。</p>
</blockquote>
<p><img src="./assets/11-12.png" alt="" /></p>
<ul>
<li>Define \(\mathbf{x}_0←(i−0.5, j)\)</li>
<li>Compute \(\mathbf{u}(\mathbf{x}_0)\)</li>
<li>\(\mathbf{x}_1←\mathbf{x}_0−∆t \mathbf{u}(\mathbf{x}_0)\)</li>
</ul>
<blockquote>
<p>✅ 假设短时间内速度不变，根据当前速度猜测上一帧的位置。</p>
</blockquote>
<ul>
<li>Compute \(\mathbf{u}(\mathbf{x}_1)\)</li>
<li>\(u_{i,j}^{new}←u(\mathbf{x}_1)\)</li>
</ul>
<p>Note that if the velocities are staggered, we need to do staggered bilinear interpolation.</p>
<p>P23</p>
<blockquote>
<p>✅ 对每个墙上的速度都以相同的方式更新。</p>
</blockquote>
<p>P24</p>
<p>We could also subdivided the time step for better tracing.</p>
<p><img src="./assets/11-14.png" alt="" /></p>
<blockquote>
<p>✅ 反推找\(\mathbf{x}_1\)时 step 细一点，这样能找得准一点<br />
✅ 怎么计算每个\(\mathbf{x}\)的\(\mathbf{u}\)?答：双线性插值方法、<br />
✅ 做模拟通常更在乎稳定而不是误差，此方法更稳定，但会有模糊的 artifacts.</p>
</blockquote>
<p>P25</p>
<h2 id="step-3-diffusion"><a class="header" href="#step-3-diffusion">Step 3: Diffusion</a></h2>
<p>Next we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=\upsilon ∆\mathbf{u}\).</p>
<p><img src="./assets/11-15-1.png" alt="" /></p>
<blockquote>
<p>✅ 分别对\(u\)和 \(v\) 做 laplacian.<br />
✅ 注意公式中\(v\)和\(\nu \)的不同，后者为粘滞系数。</p>
</blockquote>
<p>We could also use even smaller sub-steps…</p>
<p>P27</p>
<h2 id="step-4-pressure-projection"><a class="header" href="#step-4-pressure-projection">Step 4: Pressure Projection</a></h2>
<p>Finally, we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−∇\mathbf{p}\). </p>
<p><img src="./assets/11-16.png" alt="" /></p>
<p>Staggering makes this very straightforward:</p>
<p>$$
u_{i,j}^{new}←u_{i,j}−\frac{∆t}{ℎ}(p_{i,j}−p_{i−1,j})
$$</p>
<p>$$
v_{i,j}^{new}←v_{i,j}−\frac{∆t}{ℎ}(p_{i,j}−p_{i,j−1})
$$</p>
<p>But what is \(\mathbf{p}\)?</p>
<blockquote>
<p>✅ 公式第二项离散化后在特定方向上的压强。<br />
✅ \(u\)和\(v\)分别为两个方向上的速度。</p>
</blockquote>
<p>P28</p>
<h3 id="压强的来源"><a class="header" href="#压强的来源">压强的来源</a></h3>
<p>The pressure is caused by incompressibility.</p>
<blockquote>
<p>✅ 压强的原因：由于流体不可压缩、对于流体的压力会传导到每个点上。<br />
✅ 每个点都有压强，虽然压强未知，但可以根据不可压条件构造方程组。<br />
✅ 不可压的表现为有压强，产生的效果是散度为0．</p>
</blockquote>
<p>In other words, after this update by pressure, we should achieve:</p>
<table><thead><tr><th>$$∇\cdot \mathbf{u}^{new}=0$$</th></tr></thead><tbody>
</tbody></table>
<p>which means</p>
<table><thead><tr><th>$$u_{i+,j}^{new}+v_{i,j+1}^{new}−u_{i,j}^{new}−v_{i,j}^{new}=0$$</th></tr></thead><tbody>
</tbody></table>
<p>$$
\Downarrow
$$</p>
<table><thead><tr><th>$$ \begin{matrix}u_{i+1,j}−\frac{(p_{i+1,j} − p_{i,j})}{ℎ}+v_{i,j+1}−\frac{(p_{i,j+1}−p_{i,j})}{ℎ} \\−u_{i,j}−\frac{(p_{i,j} − p_{i−1,j})}{ℎ} −v_{i,j}−\frac{(p_{i,j}−p_{i,j−1})}{ℎ}=0 \end{matrix}$$</th></tr></thead><tbody>
</tbody></table>
<p>P29</p>
<h3 id="压强的数学模型"><a class="header" href="#压强的数学模型">压强的数学模型</a></h3>
<p>The pressure is caused by incompressibility. Eventually, we get a Poisson equation:</p>
<p>Eventually, we get a Poisson equation:</p>
<p>$$
4p_{i,j}−p_{i−1,j}−p_{i+1,j}−p_{i,j−1}−p_{i,j+1}= \\
\\
ℎ(−u_{i+1,j}−v_{i,j+1}+u_{i,j}+v_{i,j})
$$</p>
<p>with boundary conditions:</p>
<p>$$ \text{Dirichlet boundary (open) } p_{i−1,j}=P \\
\text{Neumann boundary (close) } p_{i−1,j}=p_{i,j}$$</p>
<p>Once we solve \(\mathbf{p}\), we update \(\mathbf{u}\) and done.</p>
<p>P30</p>
<h2 id="after-class-reading-11"><a class="header" href="#after-class-reading-11">After-Class Reading</a></h2>
<p>Jos Stam. 1999. <em>Stable Fluids. TOG (SIGGRAPH)</em>.</p>
<blockquote>
<p>✅ 这篇论文主要讨论了step2，但也包含了全部过程</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P31</p>
<h1 id="air-and-smoke"><a class="header" href="#air-and-smoke">Air and Smoke</a></h1>
<blockquote>
<p>✅ 前面讲的是怎么更新速度；后面讲怎么利用速度做出效果。 </p>
</blockquote>
<p>P32</p>
<h2 id="air-simulation"><a class="header" href="#air-simulation">Air Simulation</a></h2>
<ul>
<li>Air simulation is done in two steps.</li>
<li>In Step 1, we update the flow (the velocity field) \(\mathbf{u}\).</li>
<li>In Step 2, we use semi-Lagrangian (page 22) advect all of the other physical quantities, i.e., density, temperature…</li>
<li>Typically we use Dirichlet boundaries for an open space (or Neumann boundaries for a container.)</li>
<li>We can use it to simulate underwater as well.</li>
</ul>
<p>P33</p>
<h2 id="water-simulation"><a class="header" href="#water-simulation">Water Simulation</a></h2>
<blockquote>
<p>✅ 要渲染的不是水，而是水与空气的接触面。但通常只模拟水不模拟空气。</p>
</blockquote>
<ul>
<li>Two representations
<ul>
<li>Volume-of-fluid (as the name suggests…)</li>
<li>A signed distance function defined over the grid.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 表示1：例如一个格子存储水的体积的百分化。用于早期，无法描述水的界面，因此不精准。</p>
</blockquote>
<ul>
<li>How to advect(更新)?
<ul>
<li>Semi-Lagrangian (volume loss)</li>
<li>Level set method (volume loss)</li>
<li>Needs corrections.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ advect 2：专用于更新 SDF 的方法。<br />
✅ 水变少是常见问题，两种advect都存在。</p>
</blockquote>
<p>P35</p>
<h2 id="after-class-reading-12"><a class="header" href="#after-class-reading-12">After-Class Reading</a></h2>
<p>Osher and Fedkiw.<br />
Level Set Methods and Dynamic Implicit Surfaces.</p>
<blockquote>
<p>✅ 介绍流体模拟的很好的书。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P36</p>
<h2 id="a-summary-for-the-day-7"><a class="header" href="#a-summary-for-the-day-7">A Summary For the Day</a></h2>
<ul>
<li>
<p>The <strong>Eulerian grid</strong> presentation is very friendly with finite <strong>differencing</strong>. This makes calculus a lot easier.</p>
</li>
<li>
<p>For <strong>velocity</strong> fields, we can use <strong>staggered grid</strong>.</p>
</li>
<li>
<p>For low-speed, incompressible, viscous flow, we need to solve the Navier-Stokes equations.</p>
</li>
<li>
<p>To solve the equations, we can do this in step-by-step (method of characteristics). </p>
</li>
<li>
<p>To simulate air and water, we need to advect some physical quantities.</p>
<ul>
<li>Smoke (density); water (volume-of-fluid, or signed distance  function)</li>
<li><strong>Volume loss</strong> issue in water (how to fix it?)</li>
<li>If you need to create a mesh from grid for rendering, you need something like <u>marching cube</u>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 用有限元方法也能模拟水，但难以模拟流动性。流动需要对四面体重新构造，成本很高。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="topics-for-the-day-6"><a class="header" href="#topics-for-the-day-6">Topics for the Day</a></h1>
<ul>
<li>A SPH model</li>
</ul>
<blockquote>
<p>✅ SPH = Smoothed Particle Hydrodynamics</p>
</blockquote>
<ul>
<li>SPH-based fluids</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-sph-model"><a class="header" href="#a-sph-model">A SPH Model</a></h1>
<blockquote>
<p>✅ 搞一个模型，能够用于计算偏微分，把微分向量应用到方程上进行求解。<br />
✅ SP:smooth particle</p>
</blockquote>
<p>P4</p>
<h2 id="a-sph-model-1"><a class="header" href="#a-sph-model-1">A SPH Model</a></h2>
<p>Consider a (<strong>Lagrangian</strong>) particle system: each water molecule is a particle with physical quantities attached, such as position \(\mathbf{x}_i\), velocity \(\mathbf{v}_i\), and mass \(m_i\).</p>
<p><img src="./assets/12-1.png" alt="" /></p>
<blockquote>
<p>✅ 用粒子来表达流体，物理变量附着在粒子上，粒子转化为三角网格再渲染，或直接渲染带透明贴图的粒子(游戏)。</p>
</blockquote>
<p>P5</p>
<h2 id="原理-2"><a class="header" href="#原理-2">原理</a></h2>
<ul>
<li>Suppose each particle j has a physical quantity \(A_j\).</li>
<li>The quantity can be: velocity, pressure, density, temperature….</li>
<li>How to estimate the quantity at a new location \(\mathbf{x}_i\)?</li>
</ul>
<blockquote>
<p>✅ 空间中有很多带有物理量的粒子，求任意位置上的物理量。这是插值问题，关键是要插值结果平滑。</p>
</blockquote>
<h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<h3 id="a-simple-model"><a class="header" href="#a-simple-model">A Simple Model</a></h3>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth}}=\frac{1}{n}\sum _jA_j &amp; \text{ For } ||\mathbf{x}_i−\mathbf{x}_j||&lt;R
\end{matrix}
$$</p>
<p><img src="./assets/12-2.png" alt="" /></p>
<h4 id="存在的问题"><a class="header" href="#存在的问题">存在的问题</a></h4>
<p><img src="./assets/12-3.png" alt="" /></p>
<blockquote>
<p>✅ 取平均的方式没有考虑粒子的分布。</p>
</blockquote>
<p>P7</p>
<h3 id="a-better-model"><a class="header" href="#a-better-model">A Better Model</a></h3>
<ul>
<li>Let us assume each one represents a volume \(V_j\).</li>
<li>So a better solution is:</li>
</ul>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth} }=\frac{1}{n}\sum_jV_jA_j  &amp; \text{  For }  ||\mathbf{x} _i−\mathbf{x} _j||&lt;R
\end{matrix}
$$</p>
<p><img src="./assets/12-4.png" alt="" /></p>
<blockquote>
<p>✅ 公式假设总球的体积是1，球内的粒子瓜分这些体积。所以\(\sum _jV_j=1\)</p>
</blockquote>
<p>P8</p>
<h4 id="存在的问题-1"><a class="header" href="#存在的问题-1">存在的问题</a></h4>
<ul>
<li>One problem of this solution:</li>
</ul>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth} }=\frac{1}{n}\sum_jV_jA_j  &amp; \text{  For }  ||\mathbf{x} _i−\mathbf{x} _j||&lt;R
\end{matrix}
$$</p>
<ul>
<li>Not smooth!  (7 -&gt; 9!)</li>
</ul>
<p><img src="./assets/12-5.png" alt="" /></p>
<blockquote>
<p>✅ 微小的移动，圆内多了两个点，导致结果突变。</p>
</blockquote>
<p>P9</p>
<h3 id="final-solution"><a class="header" href="#final-solution">Final Solution</a></h3>
<ul>
<li>Final solution:</li>
</ul>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth}}=\sum _ j V_jA_jW_{ij}  &amp; \text {  For } ||\mathbf{x} _ i− \mathbf{x} _j||&lt; R
\end{matrix}
$$</p>
<ul>
<li>\(W_{ij}\) is called smoothing kernel.</li>
<li>When \(||\mathbf{x} _ i − \mathbf{x} _ j||\) is large, \(W_{ij}\) is small.</li>
<li>When \(||\mathbf{x} _ i−\mathbf{x} _ j||\) is small, \(W_{ij}\) is large.</li>
</ul>
<p>P10</p>
<h2 id="particle-volume-estimation"><a class="header" href="#particle-volume-estimation">Particle Volume Estimation</a></h2>
<ul>
<li>But how do we get the volume of particle \(i\)?<br />
$$
V_i=\frac{m_i}{ρ_i}
$$</li>
</ul>
<p>$$
ρ_i^ \mathbf{smooth} =\sum _ j V_ j ρ_ j W _ {ij}= \sum _ jm_jW_{ij}
$$</p>
<table><thead><tr><th>$$V_i=\frac{m_i}{ρ_i^\mathbf{smooth} }=\frac{m_i}{∑_jm_jW_{ij}}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/12-7.png" alt="" /></p>
<blockquote>
<p>✅ 粒子在运动过程中，疏密会有变化，因此体积不是常数，要实时计算。<br />
✅ 公式中的\(\rho \)不是指水的密度，而是粒子分布的密度。<br />
✅ 把密度当作粒子的物理量。用同样的方法插出某个点的密度。</p>
</blockquote>
<p>P11</p>
<h3 id="smoothed-interpolation--final-solution"><a class="header" href="#smoothed-interpolation--final-solution">Smoothed Interpolation – Final Solution</a></h3>
<ul>
<li>So the actual solution is:</li>
</ul>
<p><img src="./assets/12-8.png" alt="" /></p>
<p>P12</p>
<h2 id="kernal函数"><a class="header" href="#kernal函数">Kernal函数</a></h2>
<h3 id="kernal函数的作用"><a class="header" href="#kernal函数的作用">Kernal函数的作用</a></h3>
<ul>
<li>
<p>We can easily compute its derivatives:</p>
<ul>
<li>Gradient</li>
</ul>
<p>$$ \begin{matrix}
A_i^ \mathbf{smooth} = \sum _ jV_jA_ jW_ {ij} \quad &amp; ∇A_i ^\mathbf{smooth} = \sum_jV_jA_j∇W_ {ij}
\end{matrix}
$$</p>
<ul>
<li>Laplacian</li>
</ul>
<p>$$
\begin{matrix}
A_i^ \mathbf{smooth} = \sum _ j V_ j A_ jW_ {ij} \quad &amp; ∇A_i^\mathbf{smooth} = \sum_ jV_ jA_ j∇W_ {ij}
\end{matrix}
$$</p>
</li>
</ul>
<blockquote>
<p>❓ 为什么认为体积是常数？答：假设一个点的运动不影向周围邻居的体积。<br />
✅ 对于当前点来说，周围粒子的物理量是常数，只有\(W_{ij}\)与当前点有关。<br />
✅ 而\(W_{ij}\)来自于已知的kernel函数，其derivative也是已知的。</p>
</blockquote>
<p>P13</p>
<h3 id="a-smoothing-kernel-example"><a class="header" href="#a-smoothing-kernel-example">A Smoothing Kernel Example</a></h3>
<p><img src="./assets/12-9.png" alt="" /></p>
<p>$$
W_{ij}=\frac{3}{2\pi h^3} 
\begin{cases}
\frac{2}{3}-q^2+\frac{1}{2} q^3  \quad &amp;  (0\le q&lt;1) \\
\frac{1}{6}(2-q)^3  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
q=\frac{||\mathbf{x} _i-\mathbf{x} _j||}{h} 
$$</p>
<p>\(h\) is called smoothing length</p>
<blockquote>
<p>✅ smooth Kernal 有很多种，这种最常见。</p>
</blockquote>
<p>P14</p>
<h3 id="kernel-derivatives"><a class="header" href="#kernel-derivatives">Kernel Derivatives</a></h3>
<ul>
<li>Gradient at particle i (a vector)</li>
</ul>
<p>$$
\nabla _ i W _ {ij} = \begin{bmatrix}
\frac{\partial W _ {ij}}{\partial x _ i} \\
\frac{\partial W _ {ij}}{\partial y _ i} \\
\frac{\partial W _ {ij}}{\partial z _ i} 
\end{bmatrix} = \frac{\partial W_ {ij}}{\partial q} \nabla _ iq= \frac{\partial W _ {ij}}{\partial q} \frac{\mathbf{x} _ i-\mathbf{x} _ j}{|| \mathbf{x} _ i - \mathbf{x} _ j||h} 
$$</p>
<p>$$
q=\frac{||\mathbf{x} _i-\mathbf{x} _j||}{h} 
$$</p>
<p>$$
W_{ij}=\frac{3}{2\pi h^3} 
\begin{cases}
\frac{2}{3}-q^2+\frac{1}{2} q^3  \quad &amp;  (0\le q&lt;1) \\
\frac{1}{6}(2-q)^3  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
\frac{\partial W_{ij}}{\partial q} =\frac{3}{2\pi h^3} 
\begin{cases}
-2q+\frac{3}{2}q^2  \quad &amp;  (0\le q&lt;1) \\
-\frac{1}{2}(2-q)^2  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>P15</p>
<h3 id="kernal-laplacian"><a class="header" href="#kernal-laplacian">Kernal Laplacian</a></h3>
<table><thead><tr><th>$$\Delta _i W _ {ij}= \frac{\partial^2 W _ {ij}}{\partial x_i^2}+ \frac{\partial^2 W _ {ij}}{\partial y_i^2} + \frac{\partial^2 W _ {ij}}{\partial z_i^2}= \frac{\partial^2 W _ {ij}}{\partial q^2}\frac{1}{h^2} + \frac{\partial W _ {ij}}{\partial q} \frac{2}{h} $$</th></tr></thead><tbody>
</tbody></table>
<p>$$
\frac{\partial W_{ij}}{\partial q} =\frac{3}{2\pi h^3} 
\begin{cases}
-2q+\frac{3}{2}q^2  \quad &amp;  (0\le q&lt;1) \\
-\frac{1}{2}(2-q)^2  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
\frac{\partial^2 W_{ij}}{\partial q^2} =\frac{3}{2\pi h^3} 
\begin{cases}
-2+3q  \quad &amp;  (0\le q&lt;1) \\
2-q \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P16</p>
<h1 id="sph-based-fluids"><a class="header" href="#sph-based-fluids">SPH-Based Fluids</a></h1>
<p>P17</p>
<h2 id="fluid-dynamics"><a class="header" href="#fluid-dynamics">Fluid Dynamics</a></h2>
<ul>
<li>We model fluid dynamics by applying three forces on particle i.
<ul>
<li>Gravity</li>
<li>Fluid Pressure</li>
<li>Fluid Viscosity</li>
</ul>
</li>
</ul>
<p>P18</p>
<h2 id="gravity-force"><a class="header" href="#gravity-force">Gravity Force</a></h2>
<ul>
<li>Gravity Force is:</li>
</ul>
<p>$$
\mathbf{F} _ \mathbf{i}^ \mathbf{gravity}  = m _i \mathbf{g} 
$$</p>
<p>P19</p>
<h2 id="pressure-force"><a class="header" href="#pressure-force">Pressure Force</a></h2>
<blockquote>
<p>✅ 要解决的问题：怎么计算压强？怎么把压强转化为力？</p>
</blockquote>
<h3 id="怎么计算压强"><a class="header" href="#怎么计算压强">怎么计算压强</a></h3>
<ul>
<li>
<p>Pressure is related to the density</p>
<ul>
<li>First compute the density of Particle i:</li>
</ul>
<p>$$
\rho _ i = \sum _ j m _ j W _ {ij}
$$</p>
<ul>
<li>Convert it into pressure (some empirical function):</li>
</ul>
<p>$$
P_i=k((\frac{\rho _i}{\rho _\mathrm{constant } } )^7-1)
$$</p>
</li>
</ul>
<blockquote>
<p>✅ 密度到压强的计算是一个经验公式。</p>
</blockquote>
<h3 id="压强转化为力"><a class="header" href="#压强转化为力">压强转化为力</a></h3>
<p>P20</p>
<ul>
<li>Pressure force depends on the <strong>difference</strong> of pressure:</li>
</ul>
<p><img src="./assets/12-10.png" alt="" /></p>
<p>P21</p>
<ul>
<li>Mathematically, the difference of pressure =&gt; Gradient of pressure.</li>
</ul>
<p>$$
\mathbf{F} _i^{pressure}=-V_i\nabla _iP^{smooth}
$$</p>
<blockquote>
<p>✅ 体积为粒子在空间中占有的体积，体积越大受到的压力越大、\(\nabla\)代表压强的差。</p>
</blockquote>
<ul>
<li>To compute this pressure gradient, we assume that the  pressure is also smoothly represented:</li>
</ul>
<p>$$
P_i^{smooth}=  \sum _ j V_jP_j W_{ij}
$$</p>
<blockquote>
<p>✅ 假设空间是一个压强场、粒子是空间中的采样。\(P^{smooth}\)是通过周粒子\(P\)的插值得到的采样点压强。</p>
</blockquote>
<ul>
<li>So:</li>
</ul>
<p>$$
\mathbf{F} _ i^{pressure} = - V _ i \sum _ j V _ j P _ j \nabla _ i W _ {ij}
$$</p>
<p>P22</p>
<h2 id="viscosity-force"><a class="header" href="#viscosity-force">Viscosity Force</a></h2>
<h3 id="粘滞所产生的效果"><a class="header" href="#粘滞所产生的效果">粘滞所产生的效果</a></h3>
<ul>
<li>Viscosity effect means: <em>particles should move together in the same velocity</em>.</li>
<li>In other words, minimize the difference between the particle velocity and the velocities of its neighbors.</li>
</ul>
<p><img src="./assets/12-11.png" alt="" /></p>
<blockquote>
<p>✅  Viscosity (粘滞)类似于 damping (阻尼)，但有些区别，后者的目标是让粒子的运动停下来，前者的目的是让所有粒子的运动整齐划一，即速度差趋于0. </p>
</blockquote>
<p>P23</p>
<h3 id="粘滞力-viscosity-force"><a class="header" href="#粘滞力-viscosity-force">粘滞力 Viscosity Force</a></h3>
<ul>
<li>Mathematically, it means:<br />
$$
\mathbf{F} _i^{vis \cos  ity}=-\nu m_i\Delta  _i\mathbf{V} ^{smooth}
$$ </li>
</ul>
<blockquote>
<p>✅ \(V\)：粘滞系数， \(\nabla V\)：速度的 Laplacian.注意速度是3D矢量。</p>
</blockquote>
<ul>
<li>To compute this Laplacian, we assume that the velocity is also smoothly represented:</li>
</ul>
<p>$$
\mathbf{V} _i^{smooth}= \sum_jV_j \mathbf{v} _ j W _ {ij}
$$ </p>
<ul>
<li>So:</li>
</ul>
<p>$$
\mathbf{F} _i^{vis \cos  ity}=-\nu m_i\sum _jV_j\mathbf{v} _j\Delta  _iW _{ij}
$$</p>
<blockquote>
<p>✅ smooth会产生粘滞的效果。</p>
</blockquote>
<p>P24</p>
<h2 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h2>
<ul>
<li>For every particle i
<ul>
<li>Compute its neighborhood set</li>
<li>Using the neighborhood, compute:
<ul>
<li>Force = 0</li>
<li>Force + = The gravity force</li>
<li>Force + = The pressure force</li>
<li>Force + = The viscosity force</li>
</ul>
</li>
</ul>
</li>
<li>Update \(v_i = v_i + t * \text{ Force } / m_i\);</li>
<li>Update \(x_i = x_i + t * v_i\);</li>
</ul>
<table><thead><tr><th>$$ \color{Red}{ \text{ What is the bottleneck of the performance here?}} $$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 性能瓶颈：计算邻居，因为总粒子数为百万级。</p>
</blockquote>
<h2 id="spatial-partition加速求最近邻"><a class="header" href="#spatial-partition加速求最近邻">Spatial Partition加速求最近邻</a></h2>
<p>P25</p>
<h3 id="exhaustive-neighborhood-search"><a class="header" href="#exhaustive-neighborhood-search">Exhaustive Neighborhood Search</a></h3>
<ul>
<li>Search over every particle pair? O(\(N^2\))</li>
<li>10M particles means: 100 Trillion pairs…</li>
</ul>
<p>P26</p>
<h3 id="solution-spatial-partition"><a class="header" href="#solution-spatial-partition">Solution: Spatial Partition</a></h3>
<ul>
<li>Separate the space into cells</li>
<li>Each cell stores the particles in it</li>
<li>To find the neighborhood of i, just look at the surrounding
cells</li>
</ul>
<p><img src="./assets/12-13.png" alt="" /></p>
<p>P27</p>
<h3 id="spatial-partition"><a class="header" href="#spatial-partition">Spatial Partition</a></h3>
<ul>
<li>What if particles are not uniformly distributed?</li>
</ul>
<blockquote>
<p>✅ 例如水花喷溅的效果，通常靠近水面的粒子小一点，更利于表现细节。</p>
</blockquote>
<ul>
<li><strong>Solution</strong>: Octree, Binary Spatial Partitioning tree…</li>
</ul>
<p><img src="./assets/12-14.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P28</p>
<h2 id="fluid-display"><a class="header" href="#fluid-display">Fluid Display</a></h2>
<p>• Need to reconstruct the water surface from particles!</p>
<p><img src="./assets/12-15.png" alt="" /></p>
<blockquote>
<p>✅ 点云转成三角面片用于渲染也是一个比较复杂的问题。<br />
✅（1）平滑方法：bias kemal（见GAMES 102）<br />
✅（2）把球转为SDF，SDF转为Mesh</p>
</blockquote>
<p>P29</p>
<h2 id="ongoing-research"><a class="header" href="#ongoing-research">Ongoing Research</a></h2>
<ul>
<li>
<p>How to make the simulation more efficient?</p>
</li>
<li>
<p>How to make fluids incompressible?</p>
</li>
<li>
<p>When simulating water, only use water particles, no air particles. So particles are sparse on the water-air boundary. How to avoid artifacts there?</p>
</li>
<li>
<p>Using AI, not physics, to predict particle movement?</p>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
