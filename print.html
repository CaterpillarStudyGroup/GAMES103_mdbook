<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GAMES103</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The note of GAMES103">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">BackGround</li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> 数学基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="2_math_vector.html"><strong aria-hidden="true">2.1.</strong> Vector</a></li><li class="chapter-item expanded "><a href="2_math_matrix.html"><strong aria-hidden="true">2.2.</strong> Matrix</a></li><li class="chapter-item expanded "><a href="2_math_calculus.html"><strong aria-hidden="true">2.3.</strong> Tensor Calculus</a></li><li class="chapter-item expanded "><a href="Math/LinearSolver.html"><strong aria-hidden="true">2.4.</strong> Linear Solver</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> 物理基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Physics/Force.html"><strong aria-hidden="true">3.1.</strong> 力</a></li><li class="chapter-item expanded "><a href="Physics/Torque.html"><strong aria-hidden="true">3.2.</strong> 力矩</a></li><li class="chapter-item expanded "><a href="Physics/Elasticity.html"><strong aria-hidden="true">3.3.</strong> 三维弹性力学</a></li><li class="chapter-item expanded "><a href="Physics/Fluid.html"><strong aria-hidden="true">3.4.</strong> 流体力学</a></li><li class="chapter-item expanded "><a href="Physics/Stability.html"><strong aria-hidden="true">3.5.</strong> 稳定性</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> 图形学基础</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Graphics/GraphicsPipeline.html"><strong aria-hidden="true">4.1.</strong> Graphics Pipeline</a></li><li class="chapter-item expanded "><a href="Graphics/Optimize.html"><strong aria-hidden="true">4.2.</strong> 非线性优化优化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Graphics/NewtonRaphson.html"><strong aria-hidden="true">4.2.1.</strong> Newton-Raphson Method</a></li><li class="chapter-item expanded "><a href="Graphics/GradientDescent.html"><strong aria-hidden="true">4.2.2.</strong> 梯度下降法</a></li><li class="chapter-item expanded "><a href="Graphics/Nonlinear_optimization.html"><strong aria-hidden="true">4.2.3.</strong> A unified descent framework</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">单个仿真代理的仿真</li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> 粒子</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Particle/Particle.html"><strong aria-hidden="true">5.1.</strong> 粒子</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Particle/SPHModel.html"><strong aria-hidden="true">5.1.1.</strong> SPH Model</a></li><li class="chapter-item expanded "><a href="Particle/SPH_Fluids.html"><strong aria-hidden="true">5.1.2.</strong> SPH应用 - 水(不可压)</a></li><li class="chapter-item expanded "><a href="Particle/PCISPH.html"><strong aria-hidden="true">5.1.3.</strong> Predictive-Corrective SPH</a></li><li class="chapter-item expanded "><a href="Particle/IISPH.html"><strong aria-hidden="true">5.1.4.</strong> Implicit Imcompressible SPH</a></li><li class="chapter-item expanded "><a href="Particle/DFSPH.html"><strong aria-hidden="true">5.1.5.</strong> Divergenc-Fre SPH</a></li><li class="chapter-item expanded "><a href="Particle/PBF.html"><strong aria-hidden="true">5.1.6.</strong> Positon Based Fluid (PBF)</a></li><li class="chapter-item expanded "><a href="Particle/TemporalAdaptivity.html"><strong aria-hidden="true">5.1.7.</strong> 时间自适应</a></li><li class="chapter-item expanded "><a href="Particle/SpatialAdaptivity.html"><strong aria-hidden="true">5.1.8.</strong> 空间自适应</a></li><li class="chapter-item expanded "><a href="Particle/More.html"><strong aria-hidden="true">5.1.9.</strong> More</a></li></ol></li><li class="chapter-item expanded "><a href="Particle/Rigid.html"><strong aria-hidden="true">5.2.</strong> 应用场景 - 刚体</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> 不可形变Mesh - 刚体</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rigid/Attribution.html"><strong aria-hidden="true">6.1.</strong> 刚体的属性</a></li><li class="chapter-item expanded "><a href="Rigid/Force.html"><strong aria-hidden="true">6.2.</strong> 刚体动力学</a></li></ol></li><li class="chapter-item expanded "><a href="Elastic/Elastic.html"><strong aria-hidden="true">7.</strong> 可形变Mesh - 弹性体</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Elastic/Attribution.html"><strong aria-hidden="true">7.1.</strong> 弹性体的属性</a></li><li class="chapter-item expanded "><a href="Elastic/MassSpringSystem.html"><strong aria-hidden="true">7.2.</strong> Mass Spring System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="5_cloth.html"><strong aria-hidden="true">7.2.1.</strong> 应用场景 - 布料</a></li><li class="chapter-item expanded "><a href="5_cloth_bending_blcoking.html"><strong aria-hidden="true">7.2.2.</strong> Bending and Locking Issues</a></li></ol></li><li class="chapter-item expanded "><a href="Elastic/PBD.html"><strong aria-hidden="true">7.3.</strong> 位置动力学（Position Based Dynamics)</a></li><li class="chapter-item expanded "><a href="Elastic/Projective_Dynamics.html"><strong aria-hidden="true">7.4.</strong> 投影动力学 (Projective Dynamics)</a></li><li class="chapter-item expanded "><a href="Elastic/ShapeMatching.html"><strong aria-hidden="true">7.5.</strong> Shape Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6_constraints_strain.html"><strong aria-hidden="true">7.5.1.</strong> Strain Limiting</a></li><li class="chapter-item expanded "><a href="6_constraints_summary.html"><strong aria-hidden="true">7.5.2.</strong> 总结</a></li></ol></li><li class="chapter-item expanded "><a href="Elastic/XPBD.html"><strong aria-hidden="true">7.6.</strong> XPBD</a></li><li class="chapter-item expanded "><a href="Elastic/Stable.html"><strong aria-hidden="true">7.7.</strong> Stable Constrained Dynamics</a></li><li class="chapter-item expanded "><a href="7_FEM_FEM.html"><strong aria-hidden="true">7.8.</strong> Linear Finite Element Method</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_FEM2.html"><strong aria-hidden="true">7.8.1.</strong> 08-FEM2</a></li><li class="chapter-item expanded "><a href="8_FEM2_Nonlinear_optimization.html"><strong aria-hidden="true">7.8.2.</strong> Nonlinear optimization</a></li><li class="chapter-item expanded "><a href="7_FEM_FVM.html"><strong aria-hidden="true">7.8.3.</strong> FVM</a></li><li class="chapter-item expanded "><a href="7_FEM_Hyperelastic.html"><strong aria-hidden="true">7.8.4.</strong> Hyperelastic Models</a></li><li class="chapter-item expanded "><a href="7_FEM_summary.html"><strong aria-hidden="true">7.8.5.</strong> Summary</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 2D Grid - 水</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> 高度场模型</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_wave_height_feild.html"><strong aria-hidden="true">8.1.1.</strong> 高度场模型</a></li><li class="chapter-item expanded "><a href="10_wave_volume.html"><strong aria-hidden="true">8.1.2.</strong> Volume Preservation</a></li><li class="chapter-item expanded "><a href="10_wave_boundary.html"><strong aria-hidden="true">8.1.3.</strong> Boundary Conditions</a></li><li class="chapter-item expanded "><a href="10_wave_summary.html"><strong aria-hidden="true">8.1.4.</strong> Summary</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> 3D Grid</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="11_EulerianFluids.html"><strong aria-hidden="true">9.1.</strong> 欧拉模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11_EulerianFluids_Grid.html"><strong aria-hidden="true">9.1.1.</strong> A Grid Representation and Finite Differencing</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Staggered.html"><strong aria-hidden="true">9.1.2.</strong> Staggered Grid</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Incompressible.html"><strong aria-hidden="true">9.1.3.</strong> Incompressible, Viscous  Navier-Stokes Equations</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Air_Smoke.html"><strong aria-hidden="true">9.1.4.</strong> Air and Smoke</a></li><li class="chapter-item expanded "><a href="11_EulerianFluids_Summary.html"><strong aria-hidden="true">9.1.5.</strong> Summary</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="SDF.html"><strong aria-hidden="true">10.</strong> SDF</a></li><li class="chapter-item expanded affix "><li class="part-title">混合仿真代理的仿真</li><li class="chapter-item expanded "><a href="ParticleGrid/ParticleGrid.html"><strong aria-hidden="true">11.</strong> 粒子 + Grid</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ParticleGrid/PIC.html"><strong aria-hidden="true">11.1.</strong> Particle in Cell</a></li><li class="chapter-item expanded "><a href="ParticleGrid/FLIP.html"><strong aria-hidden="true">11.2.</strong> Fluid Implicit Particle</a></li><li class="chapter-item expanded "><a href="ParticleGrid/MPM.html"><strong aria-hidden="true">11.3.</strong> Material Point Method</a></li><li class="chapter-item expanded "><a href="ParticleGrid/MLS.html"><strong aria-hidden="true">11.4.</strong> MLS-MPM</a></li><li class="chapter-item expanded "><a href="ParticleGrid/AIModel.html"><strong aria-hidden="true">11.5.</strong> AI方法</a></li><li class="chapter-item expanded "><a href="ParticleGrid/APIC.html"><strong aria-hidden="true">11.6.</strong> Affice PIC</a></li><li class="chapter-item expanded "><a href="ParticleGrid/Models.html"><strong aria-hidden="true">11.7.</strong> Constitutive Models</a></li><li class="chapter-item expanded "><a href="ParticleGrid/PolyPIC.html"><strong aria-hidden="true">11.8.</strong> PolyPIC</a></li><li class="chapter-item expanded "><a href="ParticleGrid/More.html"><strong aria-hidden="true">11.9.</strong> More</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">仿真代理之间的作用</li><li class="chapter-item expanded "><a href="ParticleSDF.html"><strong aria-hidden="true">12.</strong> 粒子 + SDF</a></li><li class="chapter-item expanded "><a href="ParticleMesh.html"><strong aria-hidden="true">13.</strong> 粒子 + Mesh</a></li><li class="chapter-item expanded "><a href="RigidSDF.html"><strong aria-hidden="true">14.</strong> 刚体 + SDF</a></li><li class="chapter-item expanded "><a href="RigidSystem/RigidSystem.html"><strong aria-hidden="true">15.</strong> 刚体系统</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="9_collision_detect.html"><strong aria-hidden="true">15.1.</strong> 刚体的碰撞检测 - Broad Phase</a></li><li class="chapter-item expanded "><a href="9_collision_GJK.html"><strong aria-hidden="true">15.2.</strong> 离散相交检测 - GJK</a></li><li class="chapter-item expanded "><a href="9_collision_detect_narrow.html"><strong aria-hidden="true">15.3.</strong> 刚体的碰撞检测 - Narrow Phase</a></li><li class="chapter-item expanded "><a href="9_collision_response.html"><strong aria-hidden="true">15.4.</strong> Constrain Based 刚体碰撞响应</a></li><li class="chapter-item expanded "><a href="Interior_Point_Methods.html"><strong aria-hidden="true">15.5.</strong> 内点法</a></li><li class="chapter-item expanded "><a href="Impact_Zone_Optimization.html"><strong aria-hidden="true">15.6.</strong> 优化法</a></li><li class="chapter-item expanded "><a href="Rigid_Impact_Zones.html"><strong aria-hidden="true">15.7.</strong> 刚性冲击区域</a></li><li class="chapter-item expanded "><a href="RigidSystem/IPC.html"><strong aria-hidden="true">15.8.</strong> Incremental Potential Contact</a></li><li class="chapter-item expanded "><a href="4_rigidcontact_supplementary.html"><strong aria-hidden="true">15.9.</strong> 补充</a></li></ol></li><li class="chapter-item expanded "><a href="RigidSoft.html"><strong aria-hidden="true">16.</strong> 刚体 + 软体</a></li><li class="chapter-item expanded "><a href="9_collision_untangling.html"><strong aria-hidden="true">17.</strong> Untangling Cloth</a></li><li class="chapter-item expanded "><a href="RigidGrid.html"><strong aria-hidden="true">18.</strong> 刚体 + Grid</a></li><li class="chapter-item expanded "><a href="RigidParticleCoupling.html"><strong aria-hidden="true">19.</strong> 刚体 + SPH</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GAMES103</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/CaterpillarStudyGroup/GAMES103_mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main><div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <p>本文以GAMES103课程为始，围绕图形学物理仿真话题，根据自己的理解重新排版、增删。如有侵权，请联系删除。</p>
<p><strong>仿真是指，根据仿真代理在当前时刻的力计算下一时刻仿真代理的状态。</strong> 把仿真的对象抽象成不同的代理，可以得到不同的仿真效果。不同的仿真代理，其状态特点、受力响应、擅长场景都各不相同。因此本文根据仿真代理来划分章节。对每一种仿真对象，分析</p>
<blockquote>
<p>✅ 这里涉及到时间步的概念。仿真的帧率不需要与渲染的帧率保持一致。通常一个渲染step会包含多个仿真step。</p>
</blockquote>
<ol>
<li>属性，包含固有属性、需要仿真的状态、可能产生的内力</li>
<li>对象在力的作用下如何响应，即更新状态</li>
<li>这种仿真对象的使用场景</li>
</ol>
<p><img src="./assets/1-16.png" alt="" /></p>
<blockquote>
<p>✅ Fracture 有大量的 remesh。游戏引擎中的 Fracture 通常通过预计算而不是模拟得到。<br />
✅ 流体的形态很多，例如水滴、水花、水浪，对应的模拟方法也不同。难以用通用的方法高效地模拟所有场景。<br />
✅ 流体、烟通常使用粒子法或网格法。水波可以看作是整体，因此能用 mesh，用 mesh的好处是可以做到实时，Grid 的好处是更真实。Splashes(水花)的问题是多变，因此不能实时，通常使用粒子和网格。<br />
✅ Hybrid 方法：MPM = Particle + Grid,兼容二者优点，常用于模拟雪或粘滞物体<br />
✅ SPA 与弹性体模拟结合，可用于模拟物体破碎， 粒子法与网格法相结合，称为 MPM. 用于模拟雪、沙子。 </p>
</blockquote>
<p>一个真实的场景中，肯定会包含多个仿真对象，每个对象都可能用的不同的仿真代理去仿真。除了单个仿真代理的仿真，还考虑仿真代理之间的相互作用。</p>
<blockquote>
<p>✅ Coupling: 场景中同时有不同类别的物体，怎样模拟它们的交互。</p>
</blockquote>
<pre class="mermaid">mindmap
物理仿真
    单个仿真代理的仿真
        Particle
            单个粒子的仿真
            粒子系统
        Mesh
            不可形变Mesh
            可形变Mesh
            Skeleton
            体素
        Grid
            2D Grid
            3D Grid
        SDF
        混合代理
    仿真代理之间的作用
        碰撞
            碰撞检测
                离散相交检测
                    粗检测
                    细检测
                连续穿透检测
                    粗检测
                    细检测
            碰撞响应
                相交解除
                状态更新
        约束
</pre>
<blockquote>
<p>✅ 王老师建议的学习方法：<br />
读 paper 而不是教材<br />
只读重点不读全文<br />
学知识而不是学用 Unity<br />
多读多写多想</p>
</blockquote>
<h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<ol>
<li>
<p>基于物理的计算机动画入门 <a href="https://www.bilibili.com/video/BV12Q4y1S73g/?spm_id_from=333.337.search-card.all.click">原始课程链接</a></p>
</li>
<li>
<p>知乎、Deepseek等网络材料</p>
</li>
<li>
<p>图形学相关</p>
</li>
</ol>
<p><a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/index.html">数学基础</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES105_mdbook/">Animation - 角色动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES103_mdbook/">Animation - 物理动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/">Geometry</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/">Rendering</a></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。<br />
https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="vector-basics"><a class="header" href="#vector-basics">Vector: Basics</a></h1>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>An (Euclidean) vector: <em>A geometric entity endowed with magnitude and direction</em>.</p>
<p>$$
\mathbf{P} =\begin{bmatrix}
p_x\\ 
p_y\\ 
p_z\\
\end{bmatrix}\in \mathbf{R} ^3
$$</p>
<p>$$
\mathbf{o} =\begin{bmatrix}
0\\ 
0\\ 
0\\
\end{bmatrix}
$$</p>
<p>The vector <strong>p</strong> is defined with respect to the origin <strong>o</strong>.</p>
<h2 id="坐标系"><a class="header" href="#坐标系">坐标系</a></h2>
<p><img src="./assets/02-02.png" alt="" /></p>
<blockquote>
<p>✅ 用黑来区分，矢量：黑体小写；标量：斜体；矩阵：黑体大写；</p>
</blockquote>
<p>P4</p>
<p>The choice of a right-hand or left-hand system is largely due to:<br />
<strong>the convention of the screen space</strong>.</p>
<p><img src="./assets/02-3.png" alt="" /></p>
<blockquote>
<p>✅ 左手坐标系，E轴正方向朝屏幕内，好处是物体坐标 x、y、z 都是正值。右手系统的物体都在E轴负方向。</p>
</blockquote>
<p>P5</p>
<h2 id="stacked-vector"><a class="header" href="#stacked-vector">Stacked Vector</a></h2>
<p>Vectors can be stacked up to form a high-dimensional vector, commonly used for describing the state of an object.</p>
<p><img src="./assets/02-4-1.png" alt="" /></p>
<p>Not a geometric vector,but a <strong>stacked vector</strong>.</p>
<p>P6</p>
<h1 id="vector-arithematic-addition-and-subtraction"><a class="header" href="#vector-arithematic-addition-and-subtraction">Vector Arithematic: Addition and Subtraction</a></h1>
<p>$$
\mathbf{p\pm q=} \begin{bmatrix}
p_x\pm q_x\\
p_y\pm q_y\\
p_z\pm q_z\\
\end{bmatrix}
$$</p>
<p>$$
\mathbf{p+q=q+p} 
$$</p>
<table><thead><tr><th>Addition is commutative.</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/02-5-1.png" alt="" /></p>
<table><thead><tr><th>Geometric Meanings</th></tr></thead><tbody>
</tbody></table>
<p>P7</p>
<h2 id="example-1-linear-representation"><a class="header" href="#example-1-linear-representation">Example 1: Linear Representation</a></h2>
<p>A (geometric) vector can represent a position, a velocity, a force, or a line/ray/segment.</p>
<p><img src="./assets/02-6-2.png" alt="" /></p>
<p><img src="./assets/02-7-2.png" alt="" /></p>
<blockquote>
<p>✅ 图2。同一个公式，对\(t\)做不同的约束，可以定义不同的东西。<br />
\(\mathbf{P}(t)\) 是 \(\mathbf{P}\) 和 \(\mathbf{q}\) 的 blend </p>
</blockquote>
<p>P8</p>
<h1 id="vector-norm"><a class="header" href="#vector-norm">Vector Norm</a></h1>
<p>A vector norm measures the magnitude of a vector: its length. </p>
<p><img src="./assets/02-8.png" alt="" /></p>
<blockquote>
<p>✅ L1-Norm 又称为曼哈顿的距离。没写下标一般默认L2-Norm</p>
</blockquote>
<p>P9</p>
<h2 id="vector-norm-usage"><a class="header" href="#vector-norm-usage">Vector Norm: Usage</a></h2>
<p>Distance between <strong>q</strong> and <strong>p</strong>：
$$
\mathbf{||q-p||} 
$$</p>
<p>A unit vector：</p>
<p>$$
\mathbf{||p||} =1
$$</p>
<p>Normalization：
$$
\mathbf{\bar{p} =p/||p||} 
$$</p>
<p>P10</p>
<h1 id="vector-arithematic-dot-product"><a class="header" href="#vector-arithematic-dot-product">Vector Arithematic: Dot Product</a></h1>
<p>A dot product, also called inner product, is:</p>
<p><img src="./assets/02-11-1.png" alt="" /> </p>
<table><thead><tr><th>Geometric Meanings</th></tr></thead><tbody>
</tbody></table>
<p>$$
\begin{array}{c} 
\mathbf{p\cdot q}=p_xq_x+p_yq_y+p_zq_z=\mathbf{p^Tq}   \\
=||\mathbf{p} ||||\mathbf{q} ||\cos \theta 
\end{array}
$$</p>
<ul>
<li>\(\mathbf{p\cdot q=q\cdot p} \)</li>
<li>\(\mathbf{p\cdot (q+r)=p\cdot q+p\cdot r} \)</li>
<li>\(\mathbf{p \cdot p = ||p||^2_2} \), a different way to write norm.</li>
<li>If \(\mathbf{p·q} = 0\) and  \(\mathbf{p,q}\ne 0\)  then  \(\cos \theta = 0\),then \(\mathbf{p}\) and \(\mathbf{q}\) are orthogonal.</li>
</ul>
<p>P11</p>
<h2 id="example-2-particle-line-projection"><a class="header" href="#example-2-particle-line-projection">Example 2: Particle-Line Projection</a></h2>
<p><img src="./assets/02-12-2.png" alt="" /></p>
<blockquote>
<p>✅\(X\)为物体中心点的位置，为物体上所有点的整体位移，是前面说的\(T\).<br />
速度是加速度的积分，表示为\(V\)或\(\dot{X} \)<br />
加速度为\(F／M\)，但\(F\)比较复杂，与时间、位置、速度都可能有关系。<br />
位置是速度的积分。</p>
</blockquote>
<p>P12</p>
<h2 id="example-3-plane-representation"><a class="header" href="#example-3-plane-representation">Example 3: Plane Representation</a></h2>
<p><img src="./assets/02-13-1.png" alt="" /></p>
<p><img src="./assets/02-12P.png" alt="" /></p>
<p>S: The <u>signed</u> distance to the plane</p>
<p>Quiz: How to test if a point is within a box?</p>
<p><img src="./assets/02-14-1.png" alt="" /></p>
<p>P13</p>
<h2 id="example-4-particle-sphere-collision"><a class="header" href="#example-4-particle-sphere-collision">Example 4: Particle-Sphere Collision</a></h2>
<p><img src="./assets/02-15.png" alt="" /></p>
<p>If collision does happen, then:</p>
<p>$$
||\mathbf p(t) - \mathbf{c}||^2= r^2
$$</p>
<p>$$
(\mathbf p-\mathbf c+t\mathbf v)·(\mathbf p-\mathbf c +t\mathbf v) =r^2
$$</p>
<p>$$
(\mathbf v·\mathbf v)t^2+2(\mathbf p-\mathbf c)·\mathbf vt+ (\mathbf p-\mathbf c)·(\mathbf p-\mathbf c)-r^2=0
$$</p>
<ul>
<li>Three possiblities:
<ul>
<li>No root、无碰撞</li>
<li>One root、擦边 if \(t &gt; 0\)</li>
<li>Two roots:自碰撞 if \(t &gt; 0 \)</li>
</ul>
</li>
</ul>
<p>P14</p>
<h1 id="vector-arithematic-cross-product"><a class="header" href="#vector-arithematic-cross-product">Vector Arithematic: Cross Product</a></h1>
<p><img src="./assets/02-17.png" alt="" /></p>
<p>The result of a cross product is a vector:</p>
<p>$$
\mathbf{r=p\times q} =\begin{bmatrix}
p_yq_z-p_zq_y \\
p_zq_x-p_xq_z\\
p_xq_y-p_yq_x\\
\end{bmatrix}
$$</p>
<ul>
<li>\(\mathbf r·\mathbf p = 0; \mathbf r·\mathbf q = 0; ||\mathbf r|| = ||\mathbf p||||\mathbf q||   \sin \theta\)</li>
<li>\(\mathbf p\times \mathbf q =-\mathbf q\times \mathbf p\)</li>
<li>\(\mathbf p\times (\mathbf q +\mathbf r) = \mathbf p\times \mathbf q +\mathbf p\times \mathbf r\)</li>
<li>If \( \mathbf p \times  \mathbf q =\mathbf 0\) and \(\mathbf p,\mathbf q\ne 0 \) then \(\sin \theta= 0\), then \(\mathbf p\) and \(\mathbf q \) are parallel (in the same or opposite direction).</li>
</ul>
<p>P15</p>
<h2 id="example-5-triangle-normal-and-area"><a class="header" href="#example-5-triangle-normal-and-area">Example 5: Triangle Normal and Area</a></h2>
<p><img src="./assets/02-18.png" alt="" /></p>
<ul>
<li>Cross product gives both the normal and the area.</li>
<li>The normal depends on the triangle index order, also known as topological order.</li>
</ul>
<p>P16<br />
Quiz: How to test if three points are on the same line (co-linear)?</p>
<p>P17</p>
<h2 id="example-6-triangle-insideoutside-test"><a class="header" href="#example-6-triangle-insideoutside-test">Example 6: Triangle Inside/Outside Test</a></h2>
<p><img src="./assets/02-177.png" alt="" /></p>
<p>P18</p>
<p><img src="./assets/02-21.png" alt="" /></p>
<p><img src="./assets/02-211.png" alt="" /></p>
<p>Otherwise, outside.</p>
<blockquote>
<p>✅ 假设P点在三角形所在平面上<br />
三个点的顺序很重要，不能搞反。</p>
</blockquote>
<p>P19</p>
<h2 id="example-7-barycentric-coordinates"><a class="header" href="#example-7-barycentric-coordinates">Example 7: Barycentric Coordinates</a></h2>
<p><img src="./assets/02-22-1.png" alt="" /></p>
<p>Note that:</p>
<p>$$
\frac{1}{2} \mathbf{(x_0−p)×(x_1−p)\cdot n} =\begin{cases} 
\frac{1}{2}||\mathbf{(x_0−p)×(x_1−p)} ||&amp; \mathrm{inside}  \\<br />
\frac{1}{2}||\mathbf{(x_0−p)×(x_1−p)} || &amp; \mathrm{outside} 
\end{cases} 
$$</p>
<p>Signed areas:</p>
<p>$$
\mathbf{A_2=\frac{1}{2} (x_0−p)×(x_1−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_0=\frac{1}{2} (x_1−p)×(x_2−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_1=\frac{1}{2} (x_2−p)×(x_0−p)\cdot n}
$$</p>
<p>$$
\mathbf{A_0+A_1+A_2=A}
$$</p>
<p>Barycentric weights of <strong>p</strong> :</p>
<p>$$
b_0=A_0/A   \quad  b_1=A_1/A   \quad  b_2=A_2/A 
$$</p>
<p>$$
b_0+b_1+b_2=1
$$</p>
<p>Barycentric Interpolation</p>
<p>$$
\mathbf{p} =b_0\mathbf{x} _0+b_1\mathbf{x} _1+b_2\mathbf{x} _2
$$</p>
<blockquote>
<p>✅ 当 \(\mathbf{p}\) 在三角形外面时，面积为负，但面积总和不变
\(b_0,b_1,b_2\) 为 \(\mathbf{p}\) 在三角形重心坐标系下的坐标 </p>
</blockquote>
<blockquote>
<p>✅ \(\mathbf{p}\) 在三角形外部、重心坐标同样适用，不过权重有负数。</p>
</blockquote>
<p>P20</p>
<h3 id="gouraud-shading"><a class="header" href="#gouraud-shading">Gouraud Shading</a></h3>
<p><img src="./assets/02-23.png" alt="" /></p>
<ul>
<li>
<p>Barycentric weights allows the interior points of a triangle to be interpolated.</p>
</li>
<li>
<p>In a traditional graphics pipeline, pixel colors are calculated at triangle vertices first, and then interpolated within. This is known as <em>Gouraud shading</em>.</p>
</li>
<li>
<p>It is hardware accelerated.</p>
</li>
<li>
<p>It is no longer popular.</p>
</li>
</ul>
<blockquote>
<p>✅ 由于硬件能力提升，已经可以做到逐像素。<br />
shading,不再需要此方法<br />
通常也不是逐像素计算重心坐标，而是扫描线算法<br />
例如要计算某一行，可以 ：<br />
(1) 插值出行起点像素；<br />
(2) 插值出行终点像素；<br />
(3) 起点与终点间批量插值； </p>
</blockquote>
<p>P21</p>
<h2 id="example-9-tetrahedral-volume"><a class="header" href="#example-9-tetrahedral-volume">Example 9: Tetrahedral Volume</a></h2>
<p><img src="./assets/02-24.png" alt="" /></p>
<p>Edge vectors:</p>
<p>$$
\mathbf{X_{10}=X_1-X_0  \quad \quad X_{20}=X_2-X_0   \quad \quad X_{30}=X_3-X_0} 
$$</p>
<p>Base triangle area:</p>
<p>$$
A=\frac{1}{2} ||\mathbf{X} _{10}\times \mathbf{X} _{20}||
$$</p>
<p>Height:<br />
$$
h=\mathbf{x} _{30}\cdot\mathbf{n} =\mathbf{x} _{30}\cdot \frac{\mathbf{x} _{10}\times \mathbf{x} _{20}}{||\mathbf{x} _{10}\times \mathbf{x} _{20}||} 
$$</p>
<p>Volume:</p>
<p>$$
\begin{align*}
V&amp;=\frac{1}{3} ℎA=\frac{1}{6} \mathbf{x} _{30}\cdot \mathbf{x} _{10}\times \mathbf{x} _{20}\\
&amp;=\frac{1}{6}\begin{vmatrix}
\mathbf{x} _1 &amp; \mathbf{x} _2 &amp; \mathbf{x} _3 &amp;\mathbf{x} _0 \\
1&amp; 1 &amp; 1 &amp;1
\end{vmatrix}
\end{align*}
$$</p>
<blockquote>
<p>✅ 四面体<br />
\(h\)是\(\mathbf{x}_{30}\)在 normal 上的投影<br />
行列式是上面叉乘的另一种马法。</p>
</blockquote>
<p>P22</p>
<p>Note that the volume \(V =\frac{1}{3}h\mathit{A} =\frac{1}{6} \mathbf{x} _ {30}\cdot (\mathbf{x} _ {10}\times \mathbf{x}_{20})\) is <strong>signed</strong>.</p>
<p><img src="./assets/02-25.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{x}_{3}\)的后面法线的同方向上，也正四面体，反之为负四面体，四点共面为零体积。</p>
</blockquote>
<p>P23</p>
<h2 id="example-10-barycentric-weights-cont"><a class="header" href="#example-10-barycentric-weights-cont">Example 10: Barycentric Weights (cont.)</a></h2>
<p><img src="./assets/02-26.png" alt="" /></p>
<ul>
<li><strong>p</strong> splits the tetrahedron into four sub-tetrahedra:</li>
</ul>
<p>$$
\begin{matrix}
V_0=\mathrm{Vol} (\mathbf{x}_3,\mathbf{x}_2, \mathbf{x}_1, \mathbf{p} )\\
V_1=\mathrm{Vol} (\mathbf{x}_2,\mathbf{x}_3, \mathbf{x}_0, \mathbf{p} )\\
V_2=\mathrm{Vol} (\mathbf{x}_1,\mathbf{x}_0, \mathbf{x}_3, \mathbf{p} )\\ 
V_3=\mathrm{Vol} (\mathbf{x}_0,\mathbf{x}_1, \mathbf{x}_2, \mathbf{p} )
\end{matrix} 
$$</p>
<ul>
<li>
<p><strong>p</strong> is inside if and only if: \(V_0,V_1,V_2, V_3 &gt; 0\).</p>
</li>
<li>
<p>Barycentric weights:<br />
$$
b_0=V_0/V   \quad   b_1=V_1/V   \quad b_2=V_2/V   \quad   b_3=V_3/V
$$</p>
</li>
</ul>
<p>$$
b_0+b_1+b_2+b_3=1
$$</p>
<p>$$
\mathbf{p} =b_0\mathbf{x} _0+b_1\mathbf{x} _1+b_2\mathbf{x} _2+b_3\mathbf{x} _3
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P26</p>
<h1 id="matrix-basics"><a class="header" href="#matrix-basics">Matrix: Basics</a></h1>
<h2 id="matrix-definition"><a class="header" href="#matrix-definition">Matrix: Definition</a></h2>
<p>A real matrix is a set of real elements arranged in rows and columns.</p>
<p>$$
A=\begin{bmatrix}
a_{00} &amp; a_{01} &amp; a_{02} \\
a_{10}&amp; a_{11} &amp; a_{12} \\
a_{20}&amp; a_{21} &amp; a_{22}
\end{bmatrix}=[a_{0} \quad a_{1} \quad  a_{2}]\in \mathbf{R}   ^{3\times 3}
$$</p>
<p><img src="./assets/02-29.png" alt="" /></p>
<p>$$
\mathbf{A^T=A}    \quad  \mathrm{Symmetric} 
$$</p>
<p>P27</p>
<h2 id="matrix-multiplication"><a class="header" href="#matrix-multiplication">Matrix: Multiplication</a></h2>
<p>How to do matrix-vector and matrix-matrix multiplication? (Omitted)</p>
<ul>
<li>\(\mathbf{AB≠BA} 	 \quad \quad \quad \quad  	\quad  \quad \quad \quad \mathbf{(AB)x=A(Bx)} \)</li>
<li>\(\mathbf{(AB)^T=B^TA^T}	 \quad \quad	\quad \quad \quad \quad \mathbf{(A^TA)^T=A^TA}\)</li>
<li>\(\mathbf{Ix=x}		 \quad 	\quad \quad   \quad \quad \quad \quad \quad \quad \mathbf{AI=IA=A}\)<br />
\(\quad\)</li>
<li>\(\mathbf{A^{−1}:  AA^{−1}=A^{−1}A=I}	 \quad \quad \mathrm{inverse}\)</li>
<li>\(\mathbf{(AB)^{−1}=B^{−1}A^{−1}}\)</li>
<li>Not every matrix is invertible, e.g., \(\mathbf{A} =\begin{bmatrix}
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0
\end{bmatrix}\)</li>
</ul>
<p>P28</p>
<h2 id="matrix-orthogonality"><a class="header" href="#matrix-orthogonality">Matrix: Orthogonality</a></h2>
<p>An orthogonal matrix is a matrix made of orthogonal <strong>unit</strong> vectors. </p>
<p>$$
\mathbf{A} =[\mathbf{a} _0\quad \mathbf{a} _1\quad \mathbf{a} _2]\quad\mathrm{such \quad that
} \quad \mathbf{a}_i^\mathbf{T}\mathbf{a}_j =\begin{cases}
1，&amp; \text{ if } i= j \text{(unit)}\\
0.&amp; \text{ if } i\ne j \text{(orthogonal)}
\end{cases}
$$</p>
<p>$$
\mathbf{A^TA}=\begin{bmatrix}
\mathbf{a}_0^\mathbf{T} \\
\mathbf{a}_1^\mathbf{T} \\
\mathbf{a}_2^\mathbf{T}
\end{bmatrix}\begin{bmatrix}
\mathbf{a}_0 &amp; \mathbf{a}_1 &amp;\mathbf{a}_2
\end{bmatrix}=\begin{bmatrix}
\mathbf{a}_0^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_0^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_0^\mathbf{T} \mathbf{a}_2\\
\mathbf{a}_1^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_1^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_1^\mathbf{T} \mathbf{a}_2\\
\mathbf{a}_2^\mathbf{T} \mathbf{a}_0 &amp;  \mathbf{a}_2^\mathbf{T} \mathbf{a}_1 &amp;  \mathbf{a}_2^\mathbf{T} \mathbf{a}_2
\end{bmatrix}=I
$$</p>
<p>$$
\mathbf{A^T=A^{-1}}
$$</p>
<p>P29</p>
<h2 id="matrix-transformation"><a class="header" href="#matrix-transformation">Matrix Transformation</a></h2>
<p>A rotation can be represented by an orthogonal matrix.</p>
<p><img src="./assets/02-30.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{x、y、z}\) 是世界坐标系、 \(\mathbf{u、v、w}\) 是局部坐标系，<strong>旋转矩阵是局部坐标系在世界坐标系中的状态的描述</strong>。 </p>
</blockquote>
<p>P30<br />
A scaling can be represented by a diagonal matrix.</p>
<p><img src="./assets/02-31.png" alt="" /></p>
<p>P31</p>
<h1 id="矩阵分解"><a class="header" href="#矩阵分解">矩阵分解</a></h1>
<h2 id="singular-value-decomposition"><a class="header" href="#singular-value-decomposition">Singular Value Decomposition</a></h2>
<p>A matrix can be decomposed into:<br />
\(\mathbf{A=UDV^T} \quad\)such that \(\mathbf {D}\) is diagonal,and \(\mathbf {U}\) and \(\mathbf {V}\) are orthogonal.<br />
\(\quad \quad \quad  \quad\quad\) D 的对角线元素是<strong>singular values（奇异值）</strong></p>
<p>Any <strong>linear deformation</strong> can be decomposed into three steps: rotation, scaling and rotation:</p>
<p><img src="./assets/02-32.png" alt="" /></p>
<blockquote>
<p>✅ rotation \(\longrightarrow\) scaling \(\longrightarrow\) rotation 分别对应 \(\mathbf{V}_2^\mathbf{T},\mathbf{D}, \mathbf{U}\). 注意顺序！！！<br />
所有 \(\mathbf{A}\) 都能做 \(\mathbf{SVD} \)</p>
</blockquote>
<p>P32</p>
<h2 id="eigenvalue-decomposition"><a class="header" href="#eigenvalue-decomposition">Eigenvalue Decomposition</a></h2>
<p>A <strong>symmetric</strong> matrix can be decomposed into:<br />
\(\mathbf{A=UDU^{-1}}\quad\)such that \(\mathbf {D}\) is diagonal,and \(\mathbf {U}\) is orthogonal.<br />
\(\quad \quad \quad  \quad\quad\) D 的对角线元素是<strong>eigenvalues（特征值）</strong></p>
<blockquote>
<p>✅ \(\mathbf{ED}\) 看作是\(\mathbf{SVD}\)的特例，仅应用于对称矩阵，此时 \(\mathbf{U=V}\)<br />
\(\mathbf{U}\) 是正交矩阵，因此也可写成 \(\mathbf{A = UVU^T}\)</p>
</blockquote>
<blockquote>
<p><strong>As in the textbook</strong><br />
Let \(\mathbf{U} =\begin{bmatrix}
\cdots  &amp; \mathbf{u} _i &amp;\cdots
\end{bmatrix}\), we have:<br />
$$
\mathbf{Au} _i= \mathbf{UDU^T} \mathbf{u} _i=\mathbf{UD} \begin{bmatrix}
\vdots \\
0\\
1\\
0\\
\vdots 
\end{bmatrix}=\mathbf{U} \begin{bmatrix}
\vdots \\
0\\
d_i\\
0\\
\vdots 
\end{bmatrix}=d_i\mathbf{u} _i
$$
\(\mathbf{U}\): 是 the eigenvector of \(d_i\)<br />
\(d_i\): 是 eigenualue</p>
</blockquote>
<p>We can apply eigenvalue decomposition to <u>asymmetric</u> matrices too, if we allow eigenvalues and eigenvectors to be <strong>complex</strong>. <strong>Not considered here</strong>.</p>
<blockquote>
<p>✅ complex：复数<br />
图形学不考虑虚数，因此也不考虑非对称矩阵的 \(\mathbf{ED}\)</p>
</blockquote>
<p>P33</p>
<h2 id="symmetric-positive-definiteness-spd"><a class="header" href="#symmetric-positive-definiteness-spd">Symmetric Positive Definiteness (s.p.d.)</a></h2>
<h3 id="定义-1"><a class="header" href="#定义-1">定义</a></h3>
<p>\(\mathbf{A}\)  is s.p.d. if only if: 		\(\quad\quad\quad\quad\quad\quad\quad\quad	\)	\(\mathbf{v^TAv}&gt;0\), for any \(\mathbf{v} ≠ 0. \)</p>
<p>\(\mathbf{A}\) is symmetric semi-definite if only if: 	\(\quad\quad	\)	\(\mathbf{v^TAv}≥0\), for any \(\mathbf{v}≠ 0\). </p>
<blockquote>
<p>✅ 计算矩阵的有限元或 Hession 时会用到正定性</p>
</blockquote>
<table><thead><tr><th align="left">What does this even mean???</th></tr></thead><tbody>
</tbody></table>
<h3 id="怎么理解spd"><a class="header" href="#怎么理解spd">怎么理解SPD</a></h3>
<p>\(d&gt;0   \quad\quad\quad\quad\Leftrightarrow \quad  \mathbf{v^T} d\mathbf{v} &gt;0\), for any \(\mathbf{v} ≠ 0. \)</p>
<p>\(d_0, d_1,…&gt;0     \quad\Leftrightarrow \quad     \mathbf{v^TDv=v^T} \begin{bmatrix}
\ddots  &amp; \Box  &amp; \Box\\
\Box  &amp; d_i &amp; \Box\\
\Box  &amp;\Box  &amp;\ddots 
\end{bmatrix}\mathbf{v} &gt;0\), for any \(\mathbf{v} ≠0.\)</p>
<blockquote>
<p>✅ 一堆大于零的实数组成一个对角矩阵, 公式1的扩展</p>
</blockquote>
<p>\(d_0, d_1,…&gt;0    \quad\Leftrightarrow \quad     \mathbf{v^T(UDU^T)v=v^TUU^T(UDU^T)UU^Tv}\)</p>
<p>\(\mathbf{U}\) <strong>orthogonal</strong> \(\quad\quad\quad\quad\quad\quad\quad\quad=\mathbf{(U^Tv)^T(D)(U^Tv)&gt;0 } \), for any \(\mathbf{v} ≠0 \)</p>
<blockquote>
<p>✅ 公式3是公式2的扩展</p>
</blockquote>
<p>P34</p>
<h3 id="怎么判断spd"><a class="header" href="#怎么判断spd">怎么判断SPD</a></h3>
<ul>
<li>
<p><strong>A</strong> is s.p.d. if only if all of its eigenvalues are positive:<br />
\(\mathbf{A=UDU^T}\)  and \(d_o,d_1,\cdots &gt; 0.\)</p>
</li>
<li>
<p>But eigenvalue decomposition is a stupid idea most of the time, since it takes lotsof time to compute.</p>
</li>
</ul>
<blockquote>
<p>✅ 实际上不会通过 \(\mathbf{ED}\) 来判断矩阵的正定性。因为ED的计算量很大。</p>
</blockquote>
<ul>
<li>In practice, people often choose other ways to check  if <strong>A</strong> is sp.d. For example,</li>
</ul>
<blockquote>
<p>\(a_{ii}&gt;∑_{i≠j}|a_{ij}|\) for all \(i\)<br />
A diagonally dominant matrix is p.d.</p>
</blockquote>
<p>$$
\begin{bmatrix}
4&amp;3  &amp; 0\\
-1&amp; 5 &amp;3 \\
-8&amp; 0 &amp;9
\end{bmatrix}\begin{matrix}\quad\quad
\quad4&gt;3+0\\
\quad\quad\quad 5&gt;1+3 \\
\quad\quad9&gt;8
\end{matrix}
$$</p>
<blockquote>
<p>✅ 对角占优矩阵必定正定，正定不一定对角占优</p>
</blockquote>
<ul>
<li>Finally, a s.p.d.matrix must be invertible:<br />
$$
\mathbf{A^{-1} =(U^T)^{-1}D^{-1}U^{-1} = UD^{-1}U^T}.
$$</li>
</ul>
<p>P35</p>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<p>Prove that if <strong>A</strong> is s.p.d., then \(\mathbf{B} =\begin{bmatrix}
\mathbf{A} &amp;\mathbf{-A} \\
\mathbf{-A}  &amp;\mathbf{A}
\end{bmatrix}\)is symmetric semi-definite.</p>
<p>For any \( \mathbf{x}\) and \(\mathbf{y}\), we know:</p>
<p>$$
\begin{bmatrix}
\mathbf{ x^T}&amp;\mathbf{ y^T}
\end{bmatrix}\mathbf{B}\begin{bmatrix}
\mathbf{x} \\
\mathbf{y}
\end{bmatrix}=\begin{bmatrix}
\mathbf{ x^T}&amp;\mathbf{ y^T}
\end{bmatrix}\begin{bmatrix}
\mathbf{A} &amp;\mathbf{-A} \\
\mathbf{-A}  &amp;\mathbf{A}
\end{bmatrix}\begin{bmatrix}
\mathbf{x} \\
\mathbf{y}
\end{bmatrix}
$$</p>
<p>$$
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad\mathbf{=x^TA(x-y)-y^TA(x-y)=(x-y)^TA(x-y)} 
$$</p>
<p>Since <strong>A</strong> is sp.d., we must have:</p>
<p>$$
\begin{bmatrix}
\mathbf{ x^T} &amp; \mathbf{y^T} 
\end{bmatrix}\mathbf{B} \begin{bmatrix}
\mathbf{x} \\
\mathbf{y} 
\end{bmatrix}\ge 0
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P42</p>
<h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<h2 id="1st-order-derivatives"><a class="header" href="#1st-order-derivatives">1st-Order Derivatives</a></h2>
<h3 id="值是实数变量是矢量"><a class="header" href="#值是实数变量是矢量">值是实数，变量是矢量</a></h3>
<p>If  \(f(\mathbf{x} )\in \mathbf{R} \), then \(df=\frac{∂f}{∂x}dx+\frac{∂f}{∂y}dy+\frac{∂f}{∂z}dz=\begin{bmatrix}
\frac{∂f}{∂x} &amp; \frac{∂f}{∂y} &amp;\frac{∂f}{∂z}
\end{bmatrix}\begin{bmatrix}
dx \\
dy\\
dz
\end{bmatrix}\).</p>
<p>$$
\frac{∂f}{∂x}=\begin{bmatrix}
\frac{∂f}{∂x} &amp; \frac{∂f}{∂y} &amp;\frac{∂f}{∂z}
\end{bmatrix}<br />
$$</p>
<p>$$
\mathrm{ or  }
$$</p>
<table><thead><tr><th>\(\nabla f(\mathbf{x} )=\begin{bmatrix}\frac{∂f}{∂x} \\ \frac{∂f}{∂y}\\\frac{∂f}{∂z}\end{bmatrix}\) <br>  gradient</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ \(\nabla f(x)=(\frac{\partial f}{\partial x} )^T\), 重要！！！</p>
</blockquote>
<p><img src="./assets/02-42.png" alt="" /></p>
<p>Gradient is the steepest direction for increasing  \(f\). It’s perpendicular to the isosurface.</p>
<blockquote>
<p>✅ isosurface：等高面</p>
</blockquote>
<p>P43</p>
<h3 id="值是矢量变量是是矢量"><a class="header" href="#值是矢量变量是是矢量">值是矢量，变量是是矢量</a></h3>
<p>If \(f(\mathbf{x} )=\begin{bmatrix}
f(\mathbf{x} ) \\
g(\mathbf{x} )\\
h(\mathbf{x} )
\end{bmatrix}\in \mathbf{R} ^3\),then:</p>
<p><img src="./assets/02-43.png" alt="" /></p>
<blockquote>
<p>✅ Divergence:散度，也是\(\mathbf{J}(\mathbf{x})\)的 trace<br />
✅ Curl：旋度。<br />
✅ 怎么理解 curl?把微分算子\(\nabla \)看作是个向量，让它与 \(\mathbf{f}\) 做叉乘、在流体模拟中常用。 </p>
</blockquote>
<p>P44</p>
<h2 id="2nd-order-derivatives"><a class="header" href="#2nd-order-derivatives">2nd-Order Derivatives</a></h2>
<p>If \(f\mathbf{(x)\in R} \),then:</p>
<p><img src="./assets/02-44.png" alt="" /></p>
<blockquote>
<p>✅ 求导顺序不影响求导结果，因此 \(\mathbf{H}\) 是对称的<br />
\(\mathbf{H}\)的trace称为Laplace</p>
</blockquote>
<h1 id="泰勒展开"><a class="header" href="#泰勒展开">泰勒展开</a></h1>
<p>①\(x\in R,f(x)\in R\)<br />
$$
f(x)=f(x_0)+{f}' (x_0)(x-x_0)+\frac{1}{2} {f}'' (x_0)(x-x_0)^2+\cdots 
$$</p>
<p>②\(x\in R^n,f(x)\in R\)</p>
<p>$$
f(x)=f(x_0)+\nabla  {f}' (x_0)\cdot (x-x_0)+\frac{1}{2}(x-x_0)^TH(x-x_0)+\cdots 
$$</p>
<blockquote>
<p>✅ 当\(\mathbf{H}\)正定时, \(f(\mathbf{x})\)满足一些特殊的性质</p>
</blockquote>
<p>P45</p>
<h2 id="quiz"><a class="header" href="#quiz">Quiz:</a></h2>
<p>\(\frac{∂||\mathbf{x}||}{∂\mathbf{x}} = ?\)</p>
<p>$$
\frac{∂||\mathbf{x}||}{∂\mathbf{x}  } =  \frac{∂(\mathbf{\mathbf{x^Tx} } )^{1/2}}{∂\mathbf{x} }=\frac{1}{2}(\mathbf{x^{T}x} )^{−1/2}
\frac{∂(\mathbf{x^Tx}  )}{∂\mathbf{x} }=\frac{1}{2||\mathbf{x} ||}2\mathbf{x^T} =\frac{\mathbf{x^T} }{||\mathbf{x} ||}
$$</p>
<table><thead><tr><th>$$\frac{∂(\mathbf{\mathbf{x^Tx} } )}{∂\mathbf{x} }=\frac{∂(x^2+y^2+z^2)}{∂\mathbf{x} }= \begin{bmatrix}2x&amp; 2y &amp;2z \end{bmatrix}= 2\mathbf{x^T}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 向量梯度的物理意义：向量沿什么方向变化能最快地变短/长？答：沿它自己的当前方向。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P36</p>
<h1 id="linear-solver"><a class="header" href="#linear-solver">Linear Solver</a></h1>
<p>Many numerical problems are ended up with solving a linear system:</p>
<p><img src="Math/../assets/02-32-1.png" alt="" /></p>
<p>It's expensive to compute \(\mathbf{A^{-1}} \), especially if \(\mathbf{A} \) is large and sparse. So we cannot simply do:\(\mathbf{x = A^{-1}b}\).</p>
<ol>
<li>当 \(\mathbf{A}\) 是稀疏时. \(\mathbf{A}^{-1}\)通常不是稀疏。 如果 \(\mathbf{A}\) 很大，\(\mathbf{A}^{-1}\)会占用大量空间。</li>
<li>计算\(\mathbf{A}^{-1}\)非常耗时</li>
</ol>
<p>P25</p>
<h2 id="an-incomplete-summary"><a class="header" href="#an-incomplete-summary">An Incomplete Summary</a></h2>
<p>There are two popular linear solver approaches: direct and iterative.</p>
<ul>
<li>
<p>Direct Solvers (LU, LDLT, Cholesky, Intel MKL PARDISO)</p>
<ul>
<li>One shot, expensive but worthy if you need exact solutions.</li>
<li>Little restriction on \(\mathbf{A}\)</li>
<li>Mostly suitable on CPUs</li>
</ul>
</li>
<li>
<p>Iterative Solvers（ Jacobbi. Gauss-Seidel，共轭梯度）</p>
<ul>
<li>Expensive to solve exactly, but controllable</li>
<li>Convergence restriction on \(\mathbf{A}\), typically positive definiteness</li>
<li>Suitable on both CPUs and GPUs</li>
<li>Easy to implement</li>
<li>Accelerable: Chebyshev, Nesterov, <u>Conjugate Gradient</u></li>
</ul>
</li>
</ul>
<p>P37</p>
<h2 id="direct-linear-solver"><a class="header" href="#direct-linear-solver">Direct Linear Solver</a></h2>
<h3 id="方法"><a class="header" href="#方法">方法</a></h3>
<p>A direct solver is typically based LU factorization, or its variant: Cholesky, \(\mathrm{LDL^\top } \), etc…</p>
<blockquote>
<p>✅ \(\mathbf{LU}\) 可用于非对称矩阵。<br />
Cholesky 和 \( \mathbf{LDL^\top}\) 仅用于对称矩阵，但内存消耗更少。<br />
这里不介绍如何做\(\mathbf{LU}\)分解</p>
</blockquote>
<p>$$
\mathbf{A=LU=} \begin{bmatrix}
l_{00} &amp; \Box  &amp; \Box \\
l_{10} &amp;  l_{11} &amp; \Box \\
\vdots &amp; \cdots  &amp;\ddots 
\end{bmatrix}\begin{bmatrix}
\ddots  &amp; \cdots  &amp;\vdots  \\
\Box&amp;u_{n−1,n−1}  &amp;u_{n−1,n} \\
\Box &amp; \Box &amp;u_{n,n}
\end{bmatrix}
$$
\(\quad\quad\quad\quad\quad\quad\quad\)lower triangular   \(\quad\quad\) upper triangular</p>
<p><img src="Math/../assets/02-33-1.png" alt="" /></p>
<p><img src="Math/../assets/02-34-1.png" alt="" /></p>
<p>P38</p>
<h3 id="分析"><a class="header" href="#分析">分析</a></h3>
<ul>
<li>When \(\mathbf{A}\)  is sparse, \(\mathbf{L}\) and \(\mathbf{U}\) are not so sparse. Their sparsity depends on the permutation.(See matlab)</li>
</ul>
<blockquote>
<p>✅ \(\mathbf{L}、\mathbf{U}\) 和稀疏性与行列顺序有关，因此通常在\(\mathbf{LU}\) 分解之前做 permutation,使得到比较好的顺序。</p>
</blockquote>
<ul>
<li>lt contains two steps: factorization and solving. lf we must solve many linear systems with the same \(\mathbf{A}\) , we can factorize it only once.</li>
</ul>
<blockquote>
<p>✅ \(\mathbf{LU}\) 分解是计算量的大头，只做一次 \(\mathbf{LU}\) 分解，能省去大量计算。 </p>
</blockquote>
<ul>
<li>Cannot be easily parallelized:Intel MKL PARDISO</li>
</ul>
<p>P39</p>
<h2 id="iterative-linear-solver"><a class="header" href="#iterative-linear-solver">Iterative Linear Solver</a></h2>
<p>An iterative solver has the form:</p>
<p><img src="Math/../assets/02-355.png" alt="" /></p>
<p>Why does it work?</p>
<p>$$
\begin{matrix}
\mathbf{b−Ax} ^{[k+1]} =\mathbf{b−Ax} ^{[k]}−\mathbf{αAM} ^{−1}(\mathbf{b−Ax} ^{[k]}) \\
\quad\quad\quad\quad\quad\quad\quad\quad\quad\quad=(\mathbf{I−αAM} ^{−1})(\mathbf{b−Ax} ^{[k]}) =(\mathbf{I−αAM} ^{−1})^{k+1}(\mathbf{b−Ax} ^ {[0]})
\end{matrix}
$$</p>
<p>So,</p>
<p>\(\mathbf{b−Ax} ^{[k+1]}→0\), if \(ρ(\mathbf{I−αAM} ^{−1})&lt;1.\)</p>
<blockquote>
<p>✅\(\mathbf{b-Ax}^{[k＋1]}\) 代表下一时的残差，迭代要想收敛，\(\mathbf{b-Ax}^{[k+1]}\) 应趋于0</p>
</blockquote>
<p>\(\rho\):矩阵的spectral radius (the largest absolute value of the eigenvalues)</p>
<blockquote>
<p>✅ 不会真的去算 \(\rho\),而是调\(α\),试错。 因为求特征值的代价比较大</p>
</blockquote>
<p>P40<br />
\(\mathbf{M}\) must be easier to solve:</p>
<table><thead><tr><th>\(\mathbf{M} =\mathrm{diag} (\mathbf{A} )\)  <br> Jacobi Method</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\mathbf{M} =\mathrm{lower} (\mathbf{A} )\) <br>Gauss-Seidel Method</th></tr></thead><tbody>
</tbody></table>
<p>The convergence can be accelerated: Chebyshev, Conjugate Gradient, … (Omitted here.)</p>
<p>优点：</p>
<ul>
<li>simple</li>
<li>fast for inexact solution</li>
<li>paralleable</li>
</ul>
<p>缺点：</p>
<ul>
<li>convergence condition</li>
</ul>
<blockquote>
<p>✅ 例如要求M是正定的或对角占优的</p>
</blockquote>
<ul>
<li>slow for exact solution</li>
</ul>
<p>P24</p>
<h3 id="the-jacobi-method"><a class="header" href="#the-jacobi-method">The Jacobi Method</a></h3>
<p>We can use the Jacobi method to solve \(\mathbf{A}∆\mathbf{x}  = \mathbf{b} \).</p>
<p><img src="Math/../assets/05-21.png" alt="" /></p>
<p>The vanilla Jacobi method (\(α\) = 1) has a tight convergence requirement on \(\mathbf{A}\), i.e., being diagonal dominant.</p>
<p>The use of \(α\) allows the method to converget even when \(\mathbf{A}\) is positive definite only.</p>
<p>P26</p>
<h3 id="the-jacobi-method-with-chebyshev-acceleration"><a class="header" href="#the-jacobi-method-with-chebyshev-acceleration">The Jacobi Method with Chebyshev Acceleration</a></h3>
<p>We can use the accelerated Jacobi method to solve \(\mathbf{A}∆\mathbf{x} =\mathbf{b} \).</p>
<blockquote>
<p>The Accelerated Jacobi Method<br />
\(∆\mathbf{x}  \longleftarrow \mathbf{0} \)<br />
last_\(∆\mathbf{x}  \longleftarrow \mathbf{0}\)<br />
For \(k=0\dots \mathbf{K}\)<br />
\(\mathbf{r}  \longleftarrow \mathbf{b} −\mathbf{A} ∆\mathbf{x}\)<br />
If \(||\mathbf{r} ||&lt;\omega \quad\)	break<br />
If  \(k=0	\quad\quad\quad \omega =1\)<br />
Else If \( k=1 \quad \quad\quad\omega =2/(2-\rho^2)\)<br />
Else \(\quad\quad\quad\omega =4/(4-\rho ^2\omega )\)<br />
old_\(∆ \mathbf{x} \longleftarrow ∆ \mathbf{x}\)<br />
\(∆\mathbf{x} ⟵∆\mathbf{x} +\mathbf{αD} ^{−1}\mathbf{r}\)<br />
\(∆\mathbf{x} \longleftarrow \omega ∆ \mathbf{x} +(1−\omega)\)last_∆\(\mathbf{x} <br>\)<br />
last_\(∆\mathbf{x} \longleftarrow \) old_\(∆\mathbf{x}\)</p>
</blockquote>
<p>\(\rho  (\rho &lt;1)\) is the estimated spectral radius of the iterative matrix.</p>
<h2 id="课后答疑"><a class="header" href="#课后答疑">课后答疑</a></h2>
<p>问题二：怎么加速？<br />
答：用 Jacobian 可以在 GPU 上加速、直接法比迭代法慢。<br />
问题三：共轭梯度<br />
共轭梯度的效率很大程度上取决于 precondition,但在GPU上能使用的precondition 比较受限、 CPU 上一般选择 Incomplete LU 分解。<br />
问题四：支持的维度<br />
直接法比较占内存，因此支持的维度不如迭代法大。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力"><a class="header" href="#力">力</a></h1>
<p>仿真对象/代理有可能会受到推力、重力、阻力等。</p>
<h2 id="重力"><a class="header" href="#重力">重力：</a></h2>
<p>F = mg</p>
<p>g：重力加速度</p>
<p>单位体积上的重力为：<br />
$$
\mathbf{f}_{\text{gravity}}=ρg
$$</p>
<h2 id="阻力"><a class="header" href="#阻力">阻力</a></h2>
<blockquote>
<p>✅ 在做模拟时，如果不要求能量守衡，出于问题简化的目的，直接对速度做衰减，代替引入阻力</p>
</blockquote>
<p>$$
v^{[1]} = \alpha v^{[2]}
$$</p>
<h2 id="其它力"><a class="header" href="#其它力">其它力</a></h2>
<p>前面提到的力中，重力是与速度、位置无关的力。阻力是只与速度有关的力。但也有些其它力与粒子的位置有关。例如电磁力。因此使用更通用的形式来描述力：</p>
<p>$$
F = \mathbf{f} (\mathbf{x} (t), \mathbf{v} (t), t)
$$</p>
<h2 id="压力梯度力"><a class="header" href="#压力梯度力"><strong>压力梯度力</strong></a></h2>
<ul>
<li>压力 \(p(\mathbf{x}, t)\) 是标量场。</li>
<li>流体从高压区流向低压区。</li>
<li>作用在微团上的净压力力等于<strong>压力场的负梯度</strong>：<br />
\[
\mathbf{f}_{\text{pressure}} = -\nabla p
\]
（负号表示力指向压力下降的方向）</li>
</ul>
<h2 id="粘性力"><a class="header" href="#粘性力"><strong>粘性力</strong></a></h2>
<ul>
<li>对于<strong>牛顿流体</strong>，剪切应力与速度梯度成正比。</li>
<li>从连续介质力学推导可得，单位体积的粘性力为：<br />
\[
\mathbf{f}_{\text{viscous}} = \mu \nabla^2 \mathbf{u}
\]
其中 \(\mu\) 是<strong>动态粘度</strong>，\(\nabla^2\) 是拉普拉斯算子。
<em>（注：这是对于<strong>常粘度 \(\mu\)</strong> 且满足<strong>不可压缩条件 \(\nabla\cdot\mathbf{u}=0\)</strong> 的情况的简化形式；更一般的形式是 \(\nabla \cdot (2 \mu \mathbf {S})\) ，其中\(\mathbf {S}\) 是应变率张量。）</em></li>
</ul>
<h2 id="其他体积力"><a class="header" href="#其他体积力"><strong>其他体积力</strong>：</a></h2>
<p>除了重力 \(\rho \mathbf{g}\)，还可以加入其他体积力，如表面张力（在多相流中）、电磁力（在磁流体中）等，只需加到右边即可。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="力与力矩"><a class="header" href="#力与力矩">力与力矩</a></h1>
<h2 id="力矩-torque-mathbfτ-"><a class="header" href="#力矩-torque-mathbfτ-">力矩 torque \(\mathbf{τ} \)</a></h2>
<p>Torque：力矩，造成物体旋转的趋势。类比于Force：力，造成物体运动的趋势。</p>
<h3 id="力转化为力矩"><a class="header" href="#力转化为力矩">力转化为力矩</a></h3>
<blockquote>
<p>✅ 力转化为力矩，不是物理性质上的转化，而是数学形式上的转化。把力用力矩的形式表达，用于计算它对旋转产生的影响。</p>
</blockquote>
<p><img src="Physics/../assets/04-2.png" alt="" /></p>
<p>定义：</p>
<ul>
<li>\(\mathbf{f} _i\)：力</li>
<li>\(\mathbf{Rr} _i\)：当前状态下质心到作用点的向量 </li>
<li>\(\mathbf{τ} _i\)：力矩</li>
</ul>
<p>分析：</p>
<ul>
<li>\(\mathbf{τ} _i\) is perpendicular to both vectors: \(\mathbf{Rr} _i\) and \(\mathbf{f} _i\).</li>
<li>\(\mathbf{τ} _i\) is porportional to ||\(\mathbf{Rr} _i\)|| and ||\(\mathbf{f} _i\)||.</li>
</ul>
<blockquote>
<p>✅ 力矩的大小决定旋转的快慢。 </p>
</blockquote>
<ul>
<li>\(\mathbf{τ} _i\) is porportional to \(\sin \theta\).</li>
</ul>
<blockquote>
<p>✅ \(\theta\)  is the angle between (\mathbf{f} _i\)和\(\mathbf{Rr} _i\)</p>
</blockquote>
<p>因此：</p>
<p>$$
\mathbf{τ} _i\longleftarrow (\mathbf{Rr} _i)\times \mathbf{f} _i
$$</p>
<p>P6</p>
<h2 id="inertia-tensor"><a class="header" href="#inertia-tensor">inertia tensor</a></h2>
<p>inertia 看作是对运动的抵抗。</p>
<p><img src="Physics/../assets/04-3.png" alt="" /></p>
<p>Which side receives greater resistance?</p>
<blockquote>
<p>✅ 两图对同一个刚体施加的力矩大小相同，但产生的旋转不同。可知inertia的效果与力矩的方向有关，因此不是常数。</p>
</blockquote>
<p>换个角度出，对两个不同（旋转）状态的刚体施加（大小和方向）相同的力矩，其产生的效果也不一样。</p>
<p>即，<strong>inertia 与自身的状态相关</strong>。</p>
<p>P7</p>
<h3 id="计算inertia"><a class="header" href="#计算inertia">计算inertia</a></h3>
<p>Similar to mass, an inertia tensor describes the resistance to rotational tendency caused by torque. But different from mass, it’s not a constant.</p>
<p>It’s a matrix! The mass inverse is the resistance (just like mass).</p>
<blockquote>
<p>✅ 用于旋转的质量不再是实数，而是\(3\times 3\)的矩阵，称为 Inertia 矩阵。<br />
✅ 用 \(\mathbf{I}\) 来标记当前状态下的 Inertia 矩阵。用 \(\mathbf{I}_{ref}\)为参考状态下的Inertia 矩阵。</p>
</blockquote>
<p>具体计算公式如下 ：</p>
<table><thead><tr><th>reference state</th><th>current state</th></tr></thead><tbody>
<tr><td><img src="Physics/../assets/04-4.png" alt="" /></td><td><img src="Physics/../assets/04-5.png" alt="" /></td></tr>
<tr><td>\(\mathbf{I} _{\mathbf{ref} }=\sum m_i(\mathbf{r} _i^\mathbf{T} \mathbf{r} _i\mathbf{1} −\mathbf{r} _i\mathbf{r} _i^\mathbf{T} )\)<br>\(\mathbf{1}\)  is the 3-by-3 identity.</td><td>\(\mathbf{I} =\sum m_i(\mathbf{r} _i^\mathbf{T}\mathbf{R}  ^\mathbf{T}\mathbf{Rr}  _i\mathbf{1} −\mathbf{Rr} _i\mathbf{r} _i^\mathbf{T} \mathbf{R^T} )\)  <br> \(\quad=\sum m_i(\mathbf{Rr} _i^\mathbf{T}\mathbf{r}  _i\mathbf{1R}  ^\mathbf{T} −\mathbf{Rr} _i\mathbf{r} _i^\mathbf{T} \mathbf{R^T} )\) <br> \(\quad=\sum m_i\mathbf{R}(\mathbf{r}_i^\mathbf{T}\mathbf{r}_i\mathbf{1}−\mathbf{r}_i\mathbf{r}_i^\mathbf{T} ) \mathbf{R^T}\)   <br> \(\quad=\mathbf{RI _{ref}R^T}\)</td></tr>
</tbody></table>
<blockquote>
<p>✅ 不需要每次都根据当前状态计算，而是基于一个已经算好的ref状态的 inertia快速得出。</p>
</blockquote>
<p>P33</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="三维弹性力学"><a class="header" href="#三维弹性力学">三维弹性力学</a></h1>
<h2 id="变形梯度-deformation-gradient"><a class="header" href="#变形梯度-deformation-gradient">变形梯度 deformation gradient</a></h2>
<p>将未变形的弹性体置于坐标系中，用 Ω 表示弹性体占据的体积域，该区域被称为参考构形（或未变形构形）。</p>
<p>用大写字母表示的向量X∈Ω指代未变形构形中的单个物质点。</p>
<p>弹性体发生变形时，每个物质点X都会位移至新的变形位置，该位置用小写字母表示的向量x指代。</p>
<p>物质点与其变形后位置的对应关系由变形函数ϕ​:R3→R3描述，该函数将每个物质点X映射至其变形后的位置x=ϕ​(X)。</p>
<p>变形梯度张量F∈R3×3是变形映射的雅可比矩阵。</p>
<p><img src="Physics/../assets/Elasticity-1.png" alt="" /></p>
<h3 id="变形函数与变形梯度举例"><a class="header" href="#变形函数与变形梯度举例">变形函数与变形梯度举例：</a></h3>
<table><thead><tr><th>形变</th><th>变形函数ϕ</th><th>变形梯度F</th></tr></thead><tbody>
<tr><td>平移</td><td>x =ϕ( X )= X + t</td><td>F=∂ϕ( X )/∂ X =I</td></tr>
<tr><td>均匀缩放</td><td>ϕ( X )=γ X</td><td>F=γI</td></tr>
<tr><td>各向异性缩放</td><td>ϕ( X )=S X</td><td>F=S</td></tr>
<tr><td>旋转</td><td>ϕ( X )=RX</td><td>F=R</td></tr>
</tbody></table>
<h2 id="应变能与超弹性"><a class="header" href="#应变能与超弹性">应变能与超弹性</a></h2>
<p>弹性变形会积累势能，该势能被称为应变能，用E[ϕ]表示。</p>
<p><strong>应变能仅与最终的变形形态有关，而与弹性体达到该构形的时间变形路径无关</strong>。这是超弹性材料的标志性特征。</p>
<p>弹性体不同部位的变形程度存在差异，因此，变形与应变能的关系更适合在<strong>局部</strong>尺度上定义。因此引入能量密度函数Ψ[ϕ;X]。</p>
<p>Ψ[ϕ;X]用于度量物质点X周围微元域dV内，单位<strong>未变形体积</strong>的应变能。</p>
<p>对能量密度函数在整个体积域 Ω 上积分，即可得到弹性体的总应变能：</p>
<p><img src="Physics/../assets/Elasticity-2.png" alt="" /></p>
<p>由于能量密度Ψ[ϕ;X​]定义在X的局部域上，因此可通过一阶泰勒展开对该微小区域的变形映射进行合理近似：</p>
<p><img src="Physics/../assets/Elasticity-3.png" alt="" /></p>
<p>其中t对能量不影响，因此<strong>能量密度仅为局部变形梯度的函数</strong>。但Ψ(F)的具体形式与材料特性有关。</p>
<p>能量密度函数一个自然的期望性质是下有界，即存在最小能量状态，弹性体可稳定于该状态。</p>
<h3 id="能量密度函数举例"><a class="header" href="#能量密度函数举例">能量密度函数举例：</a></h3>
<table><thead><tr><th>能量密度函数</th><th>稳定状态</th><th>特点</th></tr></thead><tbody>
<tr><td><img src="Physics/../assets/Elasticity-4.png" alt="" /></td><td>F=0，ϕ(X)=常数</td><td>所有物质点都有收缩至同一点的趋势。<br>不符合自然规律，因为参考构形 Ω 并非其平衡构形。</td></tr>
<tr><td><img src="Physics/../assets/Elasticity-5.png" alt="" /></td><td>F=I，ϕ(X)=X）</td><td>处于参考构形或其恒定平移构形时，能量取得最小值。但旋转状态下的能量非零。</td></tr>
</tbody></table>
<h2 id="力force与面力traction"><a class="header" href="#力force与面力traction">力（Force）与面力（Traction）</a></h2>
<p>力密度，为物质点X周围微元域内，单位未变形体积的力。</p>
<p>对应的：面力密度函数traction(X)，用于度量弹性体边界上物质点X周围微元域内，单位未变形面积的力。</p>
<p>对有限边界区域B⊂∂Ω积分，即可得到该边界区域的总作用力：</p>
<p><img src="Physics/../assets/Elasticity-6.png" alt="" /></p>
<h2 id="应力张量"><a class="header" href="#应力张量">应力张量</a></h2>
<h3 id="the-first-piola-kirchhoff-应力张量"><a class="header" href="#the-first-piola-kirchhoff-应力张量">The First Piola-Kirchhoff 应力张量</a></h3>
<p>定义：</p>
<p><img src="Physics/../assets/Elasticity-7.png" alt="" /></p>
<p>其中N为参考构形（<strong>未变形</strong>）中边界的单位外法向量。</p>
<p>对于超弹性材料，P仅为变形梯度的函数，且与应变能存在简单的关系：</p>
<p><img src="Physics/../assets/Elasticity-8.png" alt="" /></p>
<p>因此任意给出Ψ(F)或者P(F)中的一个，即可根据F得出traction τ
( X )</p>
<h3 id="应力张量使用举例"><a class="header" href="#应力张量使用举例">应力张量使用举例</a></h3>
<p>定义：</p>
<p><img src="Physics/../assets/Elasticity-5.png" alt="" /></p>
<p>可以推导出：P=∂Ψ/∂F=k(F−I)</p>
<p>考虑弹性体沿所有方向均匀拉伸 2 倍的情况，ϕ( X )=2 X时，F=2I，P=kI，τ =−k N，该边界力会使弹性体产生向内的运动，以恢复原始的形状和体积。</p>
<h1 id="材料本构模型"><a class="header" href="#材料本构模型">材料本构模型</a></h1>
<p>对材料物理特性的数学描述被称为本构模型，其中包含将外界激励（如变形）与材料响应（如力、应力、能量）关联起来的方程。</p>
<h2 id="基于f的本构方程"><a class="header" href="#基于f的本构方程">基于F的本构方程</a></h2>
<p>将Ψ与F（或P与F）关联的显式公式完全可作为本构方程，例如：<br />
<img src="Physics/../assets/Elasticity-5.png" alt="" /></p>
<p>但<strong>直接利用矩阵F的元素分析变形的类型和程度非常不直观</strong>，通常会定义一些由F推导得到的中间量来定义本构方程。</p>
<h2 id="中间度量"><a class="header" href="#中间度量">中间度量</a></h2>
<h3 id="应变度量strain-measures"><a class="header" href="#应变度量strain-measures">应变度量（Strain measures）</a></h3>
<p>应变度量是用于定量描述变形程度的物理量，即衡量当前构形与静息构形的偏离程度。</p>
<p>应变度量由变形梯度推F导得到，保留变形梯度中与<strong>变形程度</strong>评估相关的信息，同时舍弃变形梯度中与形状变化无关的信息。</p>
<h4 id="格林应变张量"><a class="header" href="#格林应变张量">格林应变张量</a></h4>
<p><img src="Physics/../assets/Elasticity-9.png" alt="" /></p>
<p>特点：</p>
<ol>
<li>当弹性体处于参考构形（ϕ​(X)=X）时，F=I，因此E=0；</li>
<li>当弹性体仅发生旋转和平移（形状不变）时，ϕ​(X)=RX+t（R为旋转矩阵），此时F=R，由于RTR=I，因此E=0。</li>
<li>对于更一般的非刚体运动，可以将F分解为F=RS，此时</li>
</ol>
<p><img src="Physics/../assets/Elasticity-10.png" alt="" /></p>
<p>优点：</p>
<ol>
<li>舍弃了与变形程度无关的旋转自由度，仅保留了对称因子S中包含的拉伸 / 剪切信息，且该过程无需显式进行极分解。</li>
</ol>
<p>缺点：</p>
<ol>
<li>格林应变张量是变形的非线性（二次）函数，因此基于格林应变张量构建的本构模型复杂度更高。 </li>
<li>离散化后的节点力将是节点位置的非线性函数。</li>
</ol>
<h4 id="小应变张量"><a class="header" href="#小应变张量">小应变张量</a></h4>
<p>E(F)在E(I)处泰勒展开，并代入E(I)=0，得：</p>
<p><img src="Physics/../assets/Elasticity-11.png" alt="" /></p>
<p>优点：</p>
<ol>
<li>计算效率高</li>
<li>离散化后的节点弹性力与节点位置呈线性映射关系</li>
</ol>
<p>缺点：</p>
<ol>
<li>小应变张量仅能可靠地度量小变形。若用于大变形场景，将产生明显的误差。</li>
</ol>
<h4 id="共旋应变张量"><a class="header" href="#共旋应变张量">共旋应变张量</a></h4>
<p><img src="Physics/../assets/Elasticity-17.png" alt="" /></p>
<h3 id="不变度量"><a class="header" href="#不变度量">不变度量</a></h3>
<h4 id="各向同性不变量"><a class="header" href="#各向同性不变量">各向同性不变量</a></h4>
<p>$$
I_1(F) = tr (F^TF)
$$</p>
<p>I1是F的各奇异值的平方和</p>
<h4 id="体积比不变量j"><a class="header" href="#体积比不变量j">体积比不变量J</a></h4>
<p>$$
J = \det F
$$</p>
<p>J的物理意义：变形引起的<strong>体积变化比</strong>。</p>
<h2 id="本构模型"><a class="header" href="#本构模型">本构模型</a></h2>
<h3 id="基于线性弹性linear-elasticity张量的本构模型"><a class="header" href="#基于线性弹性linear-elasticity张量的本构模型">基于线性弹性（Linear elasticity）张量的本构模型</a></h3>
<p><img src="Physics/../assets/Elasticity-12.png" alt="" /></p>
<p><img src="Physics/../assets/Elasticity-13.png" alt="" /><br />
<img src="Physics/../assets/Elasticity-14.png" alt="" /></p>
<p>优点：</p>
<ol>
<li>应力P是变形梯度F的线性函数，因此节点弹性力与节点位置呈线性关系。</li>
<li>与其他非线性材料模型相比，线弹性模型的计算成本显著更低。</li>
<li>在小变形场景下准确</li>
</ol>
<p>缺点：</p>
<ol>
<li>仅在小变形场景下准确，因此仅适用于运动幅度较小的情况。</li>
</ol>
<h3 id="基于格林应变张量的圣维南---基尔霍夫模型"><a class="header" href="#基于格林应变张量的圣维南---基尔霍夫模型">基于格林应变张量的圣维南 - 基尔霍夫模型</a></h3>
<p>将小应变模型中的ϵ（E的近似）替换为E</p>
<p><img src="Physics/../assets/Elasticity-15.png" alt="" /></p>
<p>可求得</p>
<p><img src="Physics/../assets/Elasticity-16.png" alt="" /></p>
<p>特点：</p>
<ol>
<li>旋转不变性</li>
<li>非线性关系：应力是变形梯度F分量的三次多项式函数；离散化后，节点力也将表示为节点位置的三次多项式。</li>
<li>压缩缺陷：对强压缩的抵抗性较差。当弹性体受到强压缩力或运动学约束时，容易发生局部的扭曲和翻转。</li>
</ol>
<h3 id="基于共旋应变张量的共旋线性弹性模型"><a class="header" href="#基于共旋应变张量的共旋线性弹性模型">基于共旋应变张量的共旋线性弹性模型</a></h3>
<p><img src="Physics/../assets/Elasticity-18.png" alt="" /><br />
<img src="Physics/../assets/Elasticity-19.png" alt="" /></p>
<p>这三种写法的是等价的。</p>
<p><img src="Physics/../assets/Elasticity-20.png" alt="" /></p>
<p>特点：</p>
<ol>
<li>极分解的计算成本，以及在部分仿真中需要使用非线性求解器的成本。</li>
<li>相较于圣维南 - 基尔霍夫等高度非线性模型，其计算效率仍有显著优势。</li>
</ol>
<h3 id="新胡克弹性"><a class="header" href="#新胡克弹性">新胡克弹性</a></h3>
<p><img src="Physics/../assets/Elasticity-21.png" alt="" /></p>
<p><img src="Physics/../assets/Elasticity-22.png" alt="" /></p>
<p>特点：</p>
<ol>
<li>对极端压缩具有极强的抵抗效应。</li>
<li>近似不可压缩材料，实现保体积的数值格式。</li>
<li>当模拟中意外出现体积反转构型（理论上物理上不可能但实际仿真中极易发生）时，模型没有内置的稳定处理机制。</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流体力学"><a class="header" href="#流体力学">流体力学</a></h1>
<p>流体力学将物体建模为物质在其体内<strong>连续分布</strong>的实体，称为<strong>流体微团</strong>。</p>
<p><strong>连续性方程</strong>描述了物理量在时空中的输运</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F1.png" alt="" /></p>
<p>其中：</p>
<ul>
<li><strong>A</strong> 可为任意标量、矢量或张量形式的物理属性，</li>
<li><strong>u</strong> 表示速度，</li>
<li><strong>s</strong> 是 <strong>A</strong> 的源项，</li>
<li>所有这些量均定义于时间 <strong>t</strong> 和位置 <strong>x</strong>。</li>
</ul>
<p>公式 (1) 表明，在固定位置处任何物理属性的变化率 <strong>∂A/∂t</strong> 取决于 <strong>Au</strong> 通量所带来的变化以及源项 <strong>s</strong> 的贡献。</p>
<p>针对公式 (1) 中的物理属性 <strong>A</strong>，流场可从拉格朗日或欧拉视角进行分析：</p>
<p><strong>欧拉视角</strong> 基于固定位置来研究物理属性的变化。在给定位置 <strong>x</strong> 处物理量 <strong>A</strong> 的变化率即为公式 (1) 中的 <strong>∂A(x, t)/∂t</strong> 项。虽然直观，但这一视角并未显式表达连续介质假设中流体微团的运动，因为微团始终在不同时刻流经固定的空间位置。</p>
<p><strong>拉格朗日视角</strong> 通过将公式 (1) 改写为以下形式，研究流体微团的物理属性变化：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F2.png" alt="" /></p>
<p>其中 <strong>D(·)/Dt</strong> 即所谓的<strong>物质导数</strong>，表示流体微团内物理量 <strong>A</strong> 的变化率。</p>
<h1 id="纳维-斯托克斯方程"><a class="header" href="#纳维-斯托克斯方程"><strong>纳维-斯托克斯方程</strong></a></h1>
<p><strong>纳维-斯托克斯方程</strong>描述了流体流动的动力学规律，是流体仿真的根本基础。</p>
<h2 id="质量守恒"><a class="header" href="#质量守恒"><strong>质量守恒</strong></a></h2>
<p>在封闭系统中，流体的质量随时间保持守恒。该原理由连续性方程（公式（2））表示。令 <strong>A</strong> 为流体密度，并设 <strong>s ≡ 0</strong>，则公式（2）可改写为：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F3.png" alt="" /></p>
<p>在不可压缩流动的情况下，流体内的密度变化保持恒定，即 <strong>Dρ/Dt = 0</strong>。该条件进一步意味着速度场<strong>无散度</strong>，其表达式为：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F4.png" alt="" /></p>
<h2 id="纳维-斯托克斯动量方程"><a class="header" href="#纳维-斯托克斯动量方程"><strong>纳维-斯托克斯动量方程</strong></a></h2>
<p>为进一步描述不可压缩流体流动的运动特性，可对每个流体微团的动量进行分析。将动量项 <strong>ρu</strong> 代入公式（1），并利用公式（2），可得：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F5.png" alt="" /></p>
<p>其中 <strong>sm</strong> 是改变各流体微团速度的<strong>动量源项</strong>，符号 <strong>⊗</strong> 表示<strong>外积运算</strong>。在此基础上，<strong>黏性可压缩流</strong>的纳维-斯托克斯动量方程基本形式进一步将 <strong>sm</strong> 具体表述为三个独立项：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F6.png" alt="" /></p>
<p>其中 <strong>p</strong> 表示<strong>压力</strong>，<strong>g</strong> 为<strong>重力加速度</strong>，<strong>µ</strong> 是描述流体粘性程度的<strong>动态粘性系数</strong>。公式（6）表明，流体微团的速度变化率受三个力项的影响：<strong>压力项（−∇p）</strong>、<strong>粘性项（µ∇2u）</strong> 以及<strong>重力项（ρg）</strong>。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间步长"><a class="header" href="#时间步长">时间步长</a></h1>
<p><strong>库朗-弗里德里希斯-列维(CFL)条件</strong>是确定时间步长的一种常用方法。当前大多数仿真方法都根据CFL条件在每个时间步计算一个全局时间步长。通常，CFL条件的形式如下：</p>
<p><img src="Physics/../assets/206-%E5%85%AC%E5%BC%8F8.png" alt="" /></p>
<p>其中 \(‖u_c‖\) 表示<strong>信息传播速度</strong>，\(∆x\) 在欧拉或混合仿真中代表<strong>网格单元尺寸</strong>，在拉格朗日方法中则指<strong>光滑长度</strong>。\(C_{\mathrm{max} }\) 是一个基于离散算子大小的常数，\(C\) 即为<strong>CFL数</strong>或<strong>库朗数</strong>。在实际应用中，\(‖u_c‖\) 通常指材料中的<strong>声速</strong>或仿真中的<strong>最大流速</strong>。</p>
<p>时间步长 \(∆t\) 的选择通常使得 \(C\) 处于 <strong>[0, 1]</strong> 范围内。最大库朗数\(C_{\mathrm{max} }\)的选取一般取决于所用仿真算法的类型，但其值不应超过 1。相较于SPH方法，PIC或MPM等方法在选择 \(C_{\mathrm{max} }\)时通常具有更大的灵活性。在使用<strong>隐式时间积分方案</strong>时，可以在保持仿真稳定的前提下，采用更大的 \(C_{\mathrm{max} }\)值。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="graphics-pipeline"><a class="header" href="#graphics-pipeline">Graphics Pipeline</a></h1>
<p><a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/index.html">数学基础</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES105_mdbook/">Animation - 角色动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES103_mdbook/">Animation - 物理动画</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/">Geometry</a><br />
<a href="https://caterpillarstudygroup.github.io/GAMES101_mdbook/">Rendering</a></p>
<h2 id="real-time-graphics-pipeline"><a class="header" href="#real-time-graphics-pipeline">Real-Time Graphics Pipeline</a></h2>
<p><img src="Graphics/../assets/01-1-1.png" alt="" /> </p>
<p>P15<br />
The number of frames sent to display in a second is called the <em>frame rate</em>.<br />
For example, 24 FPS, 30 FPS, 60 FPS, …</p>
<blockquote>
<p>✅ 帧率要求主要取决于交互性，因此游戏要求比电­影高。</p>
</blockquote>
<p>P17</p>
<h2 id="animation-playback"><a class="header" href="#animation-playback">Animation Playback</a></h2>
<p><img src="Graphics/../assets/01-1.png" alt="" /> </p>
<blockquote>
<p>✅ 由于实时比较难，可以把不需要交互的动画，例如过场动画做成离线<br />
✅ 同理，不需要交互的场景。 </p>
</blockquote>
<p>P18</p>
<h2 id="movie"><a class="header" href="#movie">Movie</a></h2>
<blockquote>
<p>✅ Geometry: 离线：构造离线的3D也界<br />
✅ 动画：渲染，实时，需要与3D世界或玩家互动<br />
✅ 电影：离线，不需要交互，提前录下来，例如游戏中的过场动画</p>
</blockquote>
<p><img src="Graphics/../assets/01-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="非线性方程求解转化为优化问题"><a class="header" href="#非线性方程求解转化为优化问题">非线性方程求解转化为优化问题</a></h1>
<p>求解的非线性方程如下，其中\({x} ^{[1]}\)是未知量。<br />
$$
\mathbf{x} ^{[1]}=\mathbf{x}^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f} (\mathbf{x}^{[1]})
$$</p>
<p>P14</p>
<p>$$
\mathbf{||x||_M^2=x^TMx} 
$$</p>
<blockquote>
<p>✅ Note that this is applicable to every system, not just a mass-spring system.</p>
</blockquote>
<p>把公式处理一下得，<br />
$$
x^{[0]}+Δtv^{[0]}+Δt^2M^{-1}f(x^{[1]})-x^{[1]}=0
$$
左右两边同时乘以\(\frac{M}{Δt^2}\)得<br />
$$
\frac{1}{Δt^2} M(x^{[1]}-x^{[0]}-Δtv^{[0]})-f(x^{[1]})=0
$$<br />
这里面唯一的未知量是\(x^{[1]}\)，定义函数
$$
y=\frac{1}{Δt^2} M(x-x^{[0]}-Δtv^{[0]})-f(x)
$$<br />
当\(x = x^{[1]}\) 时，\(y = 0\), 即 \(y(x^{[1]}) = 0\)<br />
从另一个角度讲， 
$$
\begin{eqnarray}
x^{[1]} &amp; =  \mathrm{argmin}&amp; F(x)\Rightarrow {F}' (x^{[1]}) &amp; = &amp; 0
\end{eqnarray}
$$<br />
因此, \({F}' (x) = y. \quad F(x) = \int ydx \)<br />
反之则不一定成立，\({F}' (x) = 0\) 解出的 \(x\) 有可能是极大值点，所以还要看 \({F}' (x)\) 的正负。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newton-raphson-method"><a class="header" href="#newton-raphson-method">Newton-Raphson Method</a></h1>
<h2 id="x是值的fx函数"><a class="header" href="#x是值的fx函数">x是值的F(x)函数</a></h2>
<p>The Newton-Raphson method, commonly known as Newton’s method, solves the optimization problem: \(x^{[1]}\) = argmin \(F(x)\).</p>
<p><img src="Graphics/../assets/05-13.png" alt="" /></p>
<p>Given a current \(x^{(k)}\), we approximate our goal by: </p>
<p>$$
0={F}' (x)≈{F}'(x^{(k)})+{F}'' (x^{(k)})(x−x^{(k)})
$$</p>
<blockquote>
<p>✅ \(a = \min F(x)⇒ F'(a)= 0\)，\({F}' (x)\) 是非线性函数，直接解\({F}' (x)=0\) 很难解<br />
✅ 对\({F}'(x)\) 做一阶泰勒展开，保留到二阶项。<br />
✅ 假设\(x^{[k]}\)为任意已知值，就变成了解线性方程，很容易解出\(x\).<br />
✅ 因为\({F}'(x)\) 是一个近似的，\(x\) 也是一个近似解。但\(x^{[k]}\) 越接近真实解，\(x\) 也会越接近真实解。因此，选代是\(x^{[k]}\)和\(x\) 都不断逼近真实解的过程。<br />
✅ 普通的梯度下降是把\({F}' (x)\) 近似到一阶，牛顿法是近似到二阶，因此下降更快。</p>
</blockquote>
<p><img src="Graphics/../assets/05-14.png" alt="" /></p>
<blockquote>
<p>✅ Overshooting 的本质：误差会积累和放大</p>
</blockquote>
<p>P16<br />
Newton’s method finds an extremum, but it can be a minimum or maximum.</p>
<p><img src="Graphics/../assets/05-15.png" alt="" /></p>
<ul>
<li>At a minimum \(x^∗, {F}'' (x^∗)&gt;0\).</li>
<li>At a maximum \(x^∗, {F}''(x^∗)&lt;0\). </li>
<li>If \({F}''(x)&gt;0\) is everywhere, \(F(x)\) has no maximum.  \(=&gt; F(x)\) has only one minimum.</li>
</ul>
<blockquote>
<p>✅ \(F'(a)= 0,a\)  有可能是最大值或最小值，因此要判定解是否合理。判定方法： \({F}''(x)\)</p>
</blockquote>
<p>P17</p>
<h2 id="x是向量的fx函数"><a class="header" href="#x是向量的fx函数">x是向量的F(x)函数</a></h2>
<p>Now we can apply Newton’s method to: \(x^{[1]} \)= argmin \(F(x)\).
Given a current \(x^{(k)}\), we approximate our goal by: </p>
<p>$$
0=\nabla F( \mathbf{x}) ≈\nabla F (\mathbf{x} ^{(k)})+\frac{∂F ^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} (\mathbf{x−x} ^{(k)}) 
$$</p>
<p><img src="Graphics/../assets/05-16.png" alt="" /></p>
<blockquote>
<p>✅ 按照 \(\Delta x\) 的更新公式，只需要用到\(F'(x)\) 和 \({F}''(x)\)， 不需要知道 \(F(x)\).<br />
✅ 此处\(x\)是向量，因此\(F'(x)\)是向量，\({F}''(x)\)是 Hession 矩阵</p>
</blockquote>
<p>[TODO]怎么保证 \(\mathbf{x}\) 收敛</p>
<p>P26</p>
<h2 id="补充三预条件最速下降法-preconditioned-steepest-descent"><a class="header" href="#补充三预条件最速下降法-preconditioned-steepest-descent">补充三：预条件最速下降法 Preconditioned Steepest Descent</a></h2>
<ul>
<li>Mathematically, this approach is preconditioned steepest descent, in which:</li>
</ul>
<p><img src="Graphics/./assets/06-16.png" alt="" /></p>
<p>$$
F(\mathbf{x} )=\frac{1}{2∆t^2} ||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_\mathbf{M} ^2+E(\mathbf{x} )
$$</p>
<p>The performance depends on how well \(\mathbf{{\color{Orange} H} }\) approximates the real Hessian.</p>
<blockquote>
<p>✅\(\mathrm{H}\)不需要很精确，一个近似的正定的矩阵，就能让结果收敛。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P19</p>
<h2 id="gradient-descent"><a class="header" href="#gradient-descent">Gradient Descent</a></h2>
<p>Another way to solve \(\mathbf{x}^∗\)=argmin \(F(\mathbf{x})\) is the gradient descent method.</p>
<p><img src="Graphics/../assets/08-7.png" alt="" /></p>
<p>How to find the optimal step size becomes a critical question.</p>
<p>P20</p>
<h3 id="step-size-adjustment"><a class="header" href="#step-size-adjustment">step size adjustment</a></h3>
<p><img src="Graphics/../assets/08-8.png" alt="" /></p>
<p>优点：simple, Low overhead</p>
<p>P21</p>
<h3 id="descent-directions"><a class="header" href="#descent-directions">Descent Directions</a></h3>
<p>The direction \(\mathbf{d(x)}\) is descending, if a sufficiently small step size \(α\) exists for:</p>
<p>$$
F(\mathbf{x} )&gt;F(\mathbf{x} +α\mathbf{d} (\mathbf{x} ))
$$</p>
<p><img src="Graphics/../assets/08-9.png" alt="" /></p>
<table><thead><tr><th>In other words, \(−∇F(\mathbf{x} )\cdot \mathbf{d} (\mathbf{x} )&gt;0\)</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅沿负梯度方向可以下降，但不一定是最好的方向。怎样判断一个方向是否可以下降？答：看与负梯度方向是否在同侧。</p>
</blockquote>
<p>P22<br />
With line search, we can use any search direction as long as it’s descending:</p>
<p>$$
F(\mathbf{x} ^{(0)})&gt;F(\mathbf{x} ^{(1)})&gt;F(\mathbf{x} ^{(2)})&gt;F(\mathbf{x} ^{(3)})&gt;…
$$</p>
<p><img src="Graphics/../assets/08-10.png" alt="" /></p>
<p>P23</p>
<h3 id="descent-methods"><a class="header" href="#descent-methods">Descent Methods</a></h3>
<ul>
<li>Gradient descent is a descent method, since:</li>
</ul>
<p>$$
\mathbf{d} (\mathbf{x} )=−∇F(\mathbf{x} )\quad \Rightarrow  \quad −∇F(\mathbf{x} )\cdot (−∇F(\mathbf{x} ))&gt;0
$$</p>
<ul>
<li>Newton’s method is also a descent method, if the Hessian is always positive definite:</li>
</ul>
<p>$$
\mathbf{d} (\mathbf{x} )=−(\frac{∂^2F(\mathbf{x} )}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ) \quad \Rightarrow  \quad −∇F(\mathbf{x} )\cdot (−(\frac{∂^2F(\mathbf{x} )}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ))&gt;0
$$</p>
<blockquote>
<p>✅牛顿法不一定收敛，\(\mathbf{H}\)正定场景牛顿法一定收敛。</p>
</blockquote>
<ul>
<li><strong>Any method using a positive definite matrix P to modify the gradient</strong> yields a descent method:</li>
</ul>
<p>$$\mathbf{d} (\mathbf{x} )=−\mathbf{P} ^{−1}∇F(\mathbf{x} )
\quad \Rightarrow  \quad 
−∇F(\mathbf{x} )\cdot (−\mathbf{P} ^{−1}∇F(\mathbf{x} ))&gt;0
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P24</p>
<h2 id="a-unified-descent-framework"><a class="header" href="#a-unified-descent-framework">A unified descent framework</a></h2>
<p>A unified descent framework</p>
<p><img src="Graphics/../assets/08-11-1.png" alt="" /></p>
<p><img src="Graphics/../assets/08-11.png" alt="" /></p>
<p>P25<br />
<img src="Graphics/../assets/08-12.png" alt="" /></p>
<blockquote>
<p>✅ 图形学中更关注 Total Cost. 让 P 更加接近 H，可以减少迭代数，让 P 更容易得到，减少迭代成本。<br />
Traction：物体表面上的力的密度，有点像压强</p>
</blockquote>
<p>P27</p>
<h3 id="after-class-reading"><a class="header" href="#after-class-reading">After-Class Reading</a></h3>
<p>Wang. 2016. Descent <em>Methods for Elastic Body Simulation
on the GPU</em>. TOG (SIGGRAPH Asia).</p>
<p>P28</p>
<h1 id="a-summary-for-the-day"><a class="header" href="#a-summary-for-the-day">A Summary For the Day</a></h1>
<ul>
<li>
<p>We can calculate the Hessian of the FEM elastic energy based on SVD derivatives.</p>
</li>
<li>
<p>The goal of doing this is for implicit time integration. </p>
</li>
<li>
<p>Fundamentally, the goal is to solve a nonlinear optimization.</p>
<ul>
<li>Gradient Descent, Newton’s method, and others can all be considered as descent methods.</li>
<li>The key question is the matrix for calculating the search direction.</li>
<li>We need both the per-iteration cost and the number of iterations to be small.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 模拟的公式通常都固定，很难有突破、瓶颈在于计算量、随着分辨率的提升，模拟的计算量几乎是无止境的。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="粒子的属性"><a class="header" href="#粒子的属性">粒子的属性</a></h1>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>全局位置</td><td>p或x</td><td>是</td></tr>
</tbody></table>
<p>在可变的仿真属性中，通常还会考虑它们的一阶导、二阶导等。</p>
<table><thead><tr><th>属性</th><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td>速度</td><td>v或\(\mathbf{\dot{x}} \)</td><td>p的一阶导</td></tr>
<tr><td>加速度</td><td>a</td><td>p的二阶导</td></tr>
</tbody></table>
<p>更新仿真对象的可变属性。</p>
<h1 id="粒子的仿真"><a class="header" href="#粒子的仿真">粒子的仿真</a></h1>
<p>当粒子同时受到多个力时，通过相加得到它们的合力。<br />
粒子在各种力的作用下会发生位移（transform）。其p, v, a都会发生改变。</p>
<h2 id="连续形式"><a class="header" href="#连续形式">连续形式</a></h2>
<p>真实的物理世界里，属性的变化是连续的。</p>
<p>$$
\begin{cases}
\mathbf{v} (t^{[1]})=\mathbf{v} (t^{[0]})+ m^{−1}\int_{t^{[0]}}^{t^{[1]}} \mathbf{f} (\mathbf{x} (t), \mathbf{v} (t), t)dt\\
\mathbf{x} (t^{[1]})=\mathbf{x} (t^{[0]})+\int_{t^{[0]}}^{t^{[1]}} \mathbf{v} (t)dt
\end{cases}
$$</p>
<blockquote>
<p>✅ 速度是加速度的积分，因此\( \Delta v=\int a=\int \frac{F}{M} =m^{-1}\int F\).<br />
✅ 位置是速度的积分，公式的本质上是解积分。</p>
</blockquote>
<h2 id="离散形式"><a class="header" href="#离散形式">离散形式</a></h2>
<blockquote>
<p>💡 为了方便计算机进行计算，需要把连续积分形式转为离散积分形式。
数值积分相关内容请戳这里：<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/NumericalAnalysis/NumericalIntegration.html">link</a>。最后结论是混合式的积分方法。</p>
</blockquote>
<p>$$
\begin{cases}
\mathbf{v} (t^{[1]})=\mathbf{v} (t^{[0]})+ \Delta t m^{−1}\mathbf{f} (\mathbf{x(t^{[0]})}, \mathbf{v}(t^{[0]}), t^{[0]})\\
\mathbf{x} (t^{[1]})=\mathbf{x} (t^{[0]})+\Delta t\mathbf{v} (t^{[1]})
\end{cases}
$$</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p><img src="Particle/../assets/03-14.png" alt="" /></p>
<p><img src="Particle/../assets/03-15.png" alt="" /></p>
<blockquote>
<p>✅ 质量 \(M\) 是一个标量</p>
</blockquote>
<h1 id="应用场景"><a class="header" href="#应用场景">应用场景</a></h1>
<p>粒子可以作为水分子，气体分子，烟雾分子的仿真代理。用于仿真液体、气体的效果，针对实际的应用场景，还会增加一些粒子属性。<br />
粒子也可以作为刚体所占用空间的代理，仿真刚体破碎的效果。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sph-model"><a class="header" href="#sph-model">SPH Model</a></h1>
<blockquote>
<p>✅ SPH = Smoothed Particle Hydrodynamics</p>
</blockquote>
<p>P5</p>
<h2 id="原理"><a class="header" href="#原理">原理</a></h2>
<ul>
<li>Suppose each particle j has a physical quantity \(A_j\).</li>
<li>The quantity can be: velocity, pressure, density, temperature….</li>
<li>How to estimate the quantity at a new location \(\mathbf{x}_i\)?</li>
</ul>
<blockquote>
<p>✅ 空间中有很多带有物理量的粒子，求任意位置上的物理量。这是插值问题，关键是要插值结果平滑。<br />
✅ SHP 的核心思想是将连续场量的导数转化为粒子间的求积。</p>
</blockquote>
<p><img src="Particle/../assets/1.3-01.png" alt="" /></p>
<p>\(A\) 可以是任何随空间变化的物理量。<br />
SPH 适用于模拟自由表面流体。(简单理解为有表面，但不需要 Mesh 来描述表面)。<br />
烟不属于自由表面流体，因为没有表面。</p>
<h2 id="模型"><a class="header" href="#模型">模型</a></h2>
<table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>属性</td><td>符号</td></tr>
<tr><td>体积</td><td>\( V \)</td></tr>
<tr><td>密度</td><td>\( \rho \)</td></tr>
<tr><td>其它非仿真属性</td><td>\( A \)</td></tr>
</tbody></table>
<h3 id="a-simple-model"><a class="header" href="#a-simple-model">A Simple Model</a></h3>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth}}=\frac{1}{n}\sum _jA_j &amp; \text{ For } ||\mathbf{x}_i−\mathbf{x}_j||&lt;R
\end{matrix}
$$</p>
<p><img src="Particle/../assets/12-2.png" alt="" /></p>
<blockquote>
<p>✅ 假设空间是一个关于 \(A\) 的场，粒子是空间中的采样。<br />
✅ 根据 \(i\) 附近范围内采样出的 \(A\) 值预测 \(i\) 点处的 \(A\) 值。</p>
</blockquote>
<h4 id="存在的问题"><a class="header" href="#存在的问题">存在的问题</a></h4>
<p><img src="Particle/../assets/12-3.png" alt="" /></p>
<blockquote>
<p>✅ 取平均的方式没有考虑粒子的分布。</p>
</blockquote>
<p>P7</p>
<h3 id="a-better-model"><a class="header" href="#a-better-model">A Better Model</a></h3>
<ul>
<li>Let us assume each one represents a volume \(V_j\).</li>
<li>So a better solution is:</li>
</ul>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth} }=\frac{1}{n}\sum_jV_jA_j  &amp; \text{  For }  ||\mathbf{x} _i−\mathbf{x} _j||&lt;R
\end{matrix}
$$</p>
<p><img src="Particle/../assets/12-4.png" alt="" /></p>
<blockquote>
<p>✅ 体积 \(V-i\) 的计算在后面介绍。这里先假设 \(V-i\) 已知。<br />
✅ 公式假设总球的体积是1，球内的粒子瓜分这些体积。所以\(\sum _jV_j=1\)</p>
</blockquote>
<p>P8</p>
<h4 id="存在的问题-1"><a class="header" href="#存在的问题-1">存在的问题</a></h4>
<ul>
<li>One problem of this solution:</li>
</ul>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth} }=\frac{1}{n}\sum_jV_jA_j  &amp; \text{  For }  ||\mathbf{x} _i−\mathbf{x} _j||&lt;R
\end{matrix}
$$</p>
<ul>
<li>Not smooth!  (7 -&gt; 9!)</li>
</ul>
<p><img src="Particle/../assets/12-5.png" alt="" /></p>
<blockquote>
<p>✅ 微小的移动，圆内多了两个点，导致结果突变。</p>
</blockquote>
<p>P9</p>
<h3 id="final-solution"><a class="header" href="#final-solution">Final Solution</a></h3>
<p>解决方法：根据 \(j\) 到 \(i\) 的距离来决定 \(j\) 对 \(i\) 的影响权重。</p>
<p>$$
\begin{matrix}
A_i^{\mathbf{smooth}}=\sum _ j V_jA_jW_{ij}  &amp; \text {  For } ||\mathbf{x} _ i− \mathbf{x} _j||&lt; R
\end{matrix}
$$</p>
<ul>
<li>\(W_{ij}\) is called smoothing kernel.</li>
<li>When \(||\mathbf{x} _ i − \mathbf{x} _ j||\) is large, \(W_{ij}\) is small.</li>
<li>When \(||\mathbf{x} _ i−\mathbf{x} _ j||\) is small, \(W_{ij}\) is large.</li>
</ul>
<p>P10</p>
<h2 id="particle-volume-estimation"><a class="header" href="#particle-volume-estimation">Particle Volume Estimation</a></h2>
<ul>
<li>But how do we get the volume of particle \(i\)?<br />
$$
V_i=\frac{m_i}{ρ_i}
$$</li>
</ul>
<p>$$
ρ_i^ \mathbf{smooth} =\sum _ j V_ j ρ_ j W _ {ij}= \sum _ jm_jW_{ij}
$$</p>
<table><thead><tr><th>$$V_i=\frac{m_i}{ρ_i^\mathbf{smooth} }=\frac{m_i}{∑_jm_jW_{ij}}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="Particle/../assets/12-7.png" alt="" /></p>
<blockquote>
<p>✅ 粒子在运动过程中，疏密会有变化，因此体积不是常数，要实时计算。<br />
✅ 公式中的\(\rho \)不是指水的密度，而是粒子分布的密度。<br />
✅ 把密度当作粒子的物理量。用同样的方法插出某个点的密度。</p>
</blockquote>
<p>P11</p>
<h3 id="smoothed-interpolation--final-solution"><a class="header" href="#smoothed-interpolation--final-solution">Smoothed Interpolation – Final Solution</a></h3>
<ul>
<li>So the actual solution is:</li>
</ul>
<p><img src="Particle/../assets/12-8.png" alt="" /></p>
<p>P12</p>
<h2 id="kernal函数"><a class="header" href="#kernal函数">Kernal函数</a></h2>
<h3 id="kernal函数的作用"><a class="header" href="#kernal函数的作用">Kernal函数的作用</a></h3>
<ul>
<li>
<p>We can easily compute its derivatives:</p>
<ul>
<li>Gradient</li>
</ul>
<p>$$ \begin{matrix}
A_i^ \mathbf{smooth} = \sum _ jV_jA_ jW_ {ij} \quad &amp; ∇A_i ^\mathbf{smooth} = \sum_jV_jA_j∇W_ {ij}
\end{matrix}
$$</p>
<ul>
<li>Laplacian</li>
</ul>
<p>$$
\begin{matrix}
A_i^ \mathbf{smooth} = \sum _ j V_ j A_ jW_ {ij} \quad &amp; ∇A_i^\mathbf{smooth} = \sum_ jV_ jA_ j∇W_ {ij}
\end{matrix}
$$</p>
</li>
</ul>
<blockquote>
<p>❓ 为什么认为体积是常数？答：假设一个点的运动不影向周围邻居的体积。<br />
✅ 对于当前点来说，周围粒子的物理量是常数，只有\(W_{ij}\)与当前点有关。<br />
✅ 而\(W_{ij}\)来自于已知的kernel函数，其derivative也是已知的。</p>
</blockquote>
<p>P13</p>
<h3 id="a-smoothing-kernel-example"><a class="header" href="#a-smoothing-kernel-example">A Smoothing Kernel Example</a></h3>
<p><img src="Particle/../assets/12-9.png" alt="" /></p>
<p>$$
W_{ij}=\frac{3}{2\pi h^3} 
\begin{cases}
\frac{2}{3}-q^2+\frac{1}{2} q^3  \quad &amp;  (0\le q&lt;1) \\
\frac{1}{6}(2-q)^3  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
q=\frac{||\mathbf{x} _i-\mathbf{x} _j||}{h} 
$$</p>
<p>\(h\) is called smoothing length</p>
<blockquote>
<p>✅ smooth Kernal 有很多种，这种最常见。</p>
</blockquote>
<p>P14</p>
<h3 id="kernel-derivatives"><a class="header" href="#kernel-derivatives">Kernel Derivatives</a></h3>
<ul>
<li>Gradient at particle i (a vector)</li>
</ul>
<p>$$
\nabla _ i W _ {ij} = \begin{bmatrix}
\frac{\partial W _ {ij}}{\partial x _ i} \\
\frac{\partial W _ {ij}}{\partial y _ i} \\
\frac{\partial W _ {ij}}{\partial z _ i} 
\end{bmatrix} = \frac{\partial W_ {ij}}{\partial q} \nabla _ iq= \frac{\partial W _ {ij}}{\partial q} \frac{\mathbf{x} _ i-\mathbf{x} _ j}{|| \mathbf{x} _ i - \mathbf{x} _ j||h} 
$$</p>
<p>$$
q=\frac{||\mathbf{x} _i-\mathbf{x} _j||}{h} 
$$</p>
<p>$$
W_{ij}=\frac{3}{2\pi h^3} 
\begin{cases}
\frac{2}{3}-q^2+\frac{1}{2} q^3  \quad &amp;  (0\le q&lt;1) \\
\frac{1}{6}(2-q)^3  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
\frac{\partial W_{ij}}{\partial q} =\frac{3}{2\pi h^3} 
\begin{cases}
-2q+\frac{3}{2}q^2  \quad &amp;  (0\le q&lt;1) \\
-\frac{1}{2}(2-q)^2  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>P15</p>
<h3 id="kernal-laplacian"><a class="header" href="#kernal-laplacian">Kernal Laplacian</a></h3>
<table><thead><tr><th>$$\Delta _i W _ {ij}= \frac{\partial^2 W _ {ij}}{\partial x_i^2}+ \frac{\partial^2 W _ {ij}}{\partial y_i^2} + \frac{\partial^2 W _ {ij}}{\partial z_i^2}= \frac{\partial^2 W _ {ij}}{\partial q^2}\frac{1}{h^2} + \frac{\partial W _ {ij}}{\partial q} \frac{2}{h} $$</th></tr></thead><tbody>
</tbody></table>
<p>$$
\frac{\partial W_{ij}}{\partial q} =\frac{3}{2\pi h^3} 
\begin{cases}
-2q+\frac{3}{2}q^2  \quad &amp;  (0\le q&lt;1) \\
-\frac{1}{2}(2-q)^2  \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<p>$$
\frac{\partial^2 W_{ij}}{\partial q^2} =\frac{3}{2\pi h^3} 
\begin{cases}
-2+3q  \quad &amp;  (0\le q&lt;1) \\
2-q \quad&amp; (1\le q&lt;2) \\
0 \quad &amp; (2\le q)
\end{cases}
$$</p>
<h1 id="reference-1"><a class="header" href="#reference-1">Reference</a></h1>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P16</p>
<h1 id="sph-based-fluids"><a class="header" href="#sph-based-fluids">SPH-Based Fluids</a></h1>
<p>P17</p>
<p>Consider a (<strong>Lagrangian</strong>) particle system: each water molecule is a particle with physical quantities attached, such as position \(\mathbf{x}_i\), velocity \(\mathbf{v}_i\), and mass \(m_i\).</p>
<p><img src="Particle/../assets/12-1.png" alt="" /></p>
<blockquote>
<p>✅ 用粒子来表达流体，物理变量附着在粒子上。先通过粒子系统的方式独立计算每个粒子。粒子转化为三角网格再渲染，或直接渲染带透明贴图的粒子(游戏)。</p>
</blockquote>
<p>关键在于怎样构造粒子所受到的力，使粒子的运动效果看上去像水分子的运动。</p>
<ul>
<li>We model fluid dynamics by applying three forces on particle i.
<ul>
<li>Gravity</li>
<li>Fluid Pressure</li>
<li>Fluid Viscosity</li>
</ul>
</li>
</ul>
<p>P18</p>
<h2 id="gravity-force"><a class="header" href="#gravity-force">Gravity Force</a></h2>
<ul>
<li>Gravity Force is:</li>
</ul>
<p>$$
\mathbf{F} _ \mathbf{i}^ \mathbf{gravity}  = m _i \mathbf{g} 
$$</p>
<p>P19</p>
<p>\(\mathbf{g}\) 可以单指重力，也可以指所有的外力。</p>
<h2 id="pressure-force"><a class="header" href="#pressure-force">Pressure Force</a></h2>
<blockquote>
<p>✅ WCSPH：弱可压缩流体</p>
</blockquote>
<p>计算密度 → 计算压强 → 计算压力，这是弱可压缩流体的关键。<br />
严格不可压缩流体，速度散度严格为0，只能通过迫松方程求解，因为密度不变，不能反应压力。而 WCSPH 允许密度可变，并建立“密度 —— 压力”反馈方程。</p>
<h3 id="计算密度"><a class="header" href="#计算密度">计算密度</a></h3>
<p>First compute the density of Particle i:</p>
<p>$$
\rho _ i = \sum _ j m _ j W _ {ij}
$$</p>
<h3 id="计算压强"><a class="header" href="#计算压强">计算压强</a></h3>
<p>$$
P_i=k((\frac{\rho _i}{\rho _\mathrm{constant } } )^7-1)
$$</p>
<blockquote>
<p>✅ 密度到压强的计算是一个经验公式。直观理解就是：密度大 → 压强大 → 推动周围粒子离开自己 → 保体积效果</p>
</blockquote>
<ul>
<li>To compute this pressure gradient, we assume that the  pressure is also smoothly represented:</li>
</ul>
<p>$$
P_i^{smooth}=  \sum _ j V_jP_j W_{ij}
$$</p>
<blockquote>
<p>✅ 假设空间是一个压强场、粒子是空间中的采样。\(P^{smooth}\)是通过周粒子\(P\)的插值得到的采样点压强。</p>
</blockquote>
<p>通过 smooth 函数，把离散值变成连续值，以便于微分计算。这是一种常用技巧。</p>
<h3 id="压强转化为力"><a class="header" href="#压强转化为力">压强转化为力</a></h3>
<p>P20</p>
<ul>
<li>Pressure force depends on the <strong>difference</strong> of pressure:</li>
</ul>
<p>从公式上理解：</p>
<p>$$
\frac{D\boldsymbol{v}}{Dt}=-\frac{1}{\rho}\nabla \mathbf{p}+\boldsymbol{g}
$$</p>
<p>公式中的 \(\boldsymbol{g} \) 不在这里考虑，仅考虑 \(\mathbf{p}\) 对 \(\boldsymbol{v}\) 的影响<br />
求 \(\mathbf{p}_i^{smooth}\) 的梯度的过程见补充<br />
代入即可求得粒子的速度变化</p>
<p>$$
\Delta \boldsymbol{v}=\Delta t \cdot \frac{D\boldsymbol{v}}{Dt}=-\frac{1}{\rho}\Delta t \nabla \mathbf{p}_i^{smooth}=\Delta t \frac{\boldsymbol{F}_i^{Pressure}}{m}
$$</p>
<p>$$
\boldsymbol{F}_i^{Pressure}=-\boldsymbol{v}_i \nabla \mathbf{p}_i^{smooth}
$$</p>
<p>从物理上理解。</p>
<p><img src="Particle/../assets/12-10.png" alt="" /></p>
<p>压强差产生压力。</p>
<p>P21</p>
<ul>
<li>Mathematically, <strong>the difference of pressure =&gt; Gradient of pressure</strong>.</li>
</ul>
<p>$$
\mathbf{F} _i^{pressure}=-V_i\nabla _iP^{smooth}
$$</p>
<blockquote>
<p>✅ 体积为粒子在空间中占有的体积，体积越大受到的压力越大、\(\nabla\)代表压强的差。</p>
</blockquote>
<ul>
<li>So:</li>
</ul>
<p>$$
\mathbf{F} _ i^{pressure} = - V _ i \sum _ j V _ j P _ j \nabla _ i W _ {ij}
$$</p>
<p>P22</p>
<h2 id="viscosity-force-粘滞力"><a class="header" href="#viscosity-force-粘滞力">Viscosity Force 粘滞力</a></h2>
<h3 id="粘滞所产生的效果"><a class="header" href="#粘滞所产生的效果">粘滞所产生的效果</a></h3>
<ul>
<li>Viscosity effect means: <em>particles should move together in the same velocity</em>.</li>
<li>In other words, minimize the difference between the particle velocity and the velocities of its neighbors.</li>
</ul>
<p><img src="Particle/../assets/12-11.png" alt="" /></p>
<blockquote>
<p>✅  Viscosity (粘滞)类似于 damping (阻尼)，但有些区别，后者的目标是让粒子的运动停下来，前者的目的是让所有粒子的运动整齐划一，即速度差趋于0.<br />
✅ smooth 会产生粘滞的效果。</p>
</blockquote>
<p>P23</p>
<h3 id="计算粘滞力"><a class="header" href="#计算粘滞力">计算粘滞力</a></h3>
<ul>
<li>Mathematically, it means:<br />
$$
\mathbf{F} _i^{viscosity}=-\nu m_i\Delta  _i\mathbf{V} ^{smooth}
$$ </li>
</ul>
<blockquote>
<p>✅ \(\nu\)：粘滞系数， \(\Delta \nu\)：速度的 Laplacian. 注意速度是3D矢量。</p>
</blockquote>
<ul>
<li>To compute this Laplacian, we assume that the velocity is also smoothly represented:</li>
</ul>
<p>$$
\mathbf{V} _i^{smooth}= \sum_jV_j \mathbf{v} _ j W _ {ij}
$$ </p>
<ul>
<li>So:</li>
</ul>
<p>$$
\mathbf{F} _i^{viscosity}=-\nu m_i\sum _jV_j\mathbf{v} _j\Delta  _iW _{ij}
$$</p>
<p>P24</p>
<h2 id="algorithm"><a class="header" href="#algorithm">Algorithm</a></h2>
<ul>
<li>For every particle i
<ul>
<li>Compute its neighborhood set</li>
<li>Using the neighborhood, compute:
<ul>
<li>Force = 0</li>
<li>Force + = The gravity force</li>
<li>Force + = The pressure force</li>
<li>Force + = The viscosity force</li>
</ul>
</li>
</ul>
</li>
<li>Update \(v_i = v_i + t * \text{ Force } / m_i\);</li>
<li>Update \(x_i = x_i + t * v_i\);</li>
</ul>
<p>这是显式积分的流程，也可以把它们转为隐式积分方式。</p>
<h2 id="补充-1spatial-partition加速求最近邻"><a class="header" href="#补充-1spatial-partition加速求最近邻">补充 1：Spatial Partition加速求最近邻</a></h2>
<p>P25</p>
<h3 id="exhaustive-neighborhood-search"><a class="header" href="#exhaustive-neighborhood-search">Exhaustive Neighborhood Search</a></h3>
<table><thead><tr><th>$$ \color{Red}{ \text{ What is the bottleneck of the performance here?}} $$</th></tr></thead><tbody>
</tbody></table>
<ul>
<li>Search over every particle pair? O(\(N^2\))</li>
<li>10M particles means: 100 Trillion pairs…</li>
</ul>
<blockquote>
<p>✅ 性能瓶颈在于搜索邻居，因为总粒子数为百万级。</p>
</blockquote>
<p>P26</p>
<h3 id="solution-spatial-partition"><a class="header" href="#solution-spatial-partition">Solution: Spatial Partition</a></h3>
<ul>
<li>Separate the space into cells</li>
<li>Each cell stores the particles in it</li>
<li>To find the neighborhood of i, just look at the surrounding cells</li>
</ul>
<p><img src="Particle/../assets/12-13.png" alt="" /></p>
<p>其它技巧：位压缩，Moten 编码，Compact hashing, AI 方法</p>
<p>P27</p>
<h3 id="遗留问题"><a class="header" href="#遗留问题">遗留问题：</a></h3>
<ul>
<li>What if particles are not uniformly distributed?</li>
</ul>
<blockquote>
<p>✅ 例如水花喷溅的效果，通常靠近水面的粒子小一点，更利于表现细节。</p>
</blockquote>
<ul>
<li><strong>Solution</strong>: Octree, Binary Spatial Partitioning tree…</li>
</ul>
<p><img src="Particle/../assets/12-14.png" alt="" /></p>
<p>P28 </p>
<h2 id="补充-2流体粒子渲染"><a class="header" href="#补充-2流体粒子渲染">补充 2：流体粒子渲染</a></h2>
<p>• Need to reconstruct the water surface from particles!</p>
<p><img src="Particle/../assets/12-15.png" alt="" /></p>
<blockquote>
<p>✅ 点云转成三角面片用于渲染也是一个比较复杂的问题。<br />
✅（1）平滑方法：bias kemal（见GAMES 102）或 vdb<br />
✅（2）把球转为SDF，SDF转为 Mesh (Marching Cubes)</p>
</blockquote>
<h2 id="补充-3计算梯度"><a class="header" href="#补充-3计算梯度">补充 3：计算梯度</a></h2>
<p>这个奇怪的梯度计算公式能让计算结果稳定。</p>
<p><img src="Particle/../assets/1.3-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predictive-corrective-icompressible-sphpcisph"><a class="header" href="#predictive-corrective-icompressible-sphpcisph">Predictive-Corrective Icompressible SPH(PCISPH)</a></h1>
<h2 id="一预测-修正框架predictive-corrective"><a class="header" href="#一预测-修正框架predictive-corrective">一、预测-修正框架（Predictive-Corrective）</a></h2>
<pre class="mermaid">flowchart LR
    A[当前状态] --&gt;|预测步①| B[中间状态&lt;br&gt;（SPH → 密度偏差）]
    B --&gt;|SPH| E[未修正的密度]
    E &amp; C[恒定的期望密度] --&gt; F[修正压力]
    F --&gt; |修正步②| D[下一时刻状态]
</pre>
<p>①预测步：基于外力的物理仿真<br>（不考虑内力约束）<br />
②这一步是WCSPH和PCISPH的关键差别</p>
<h2 id="二wcsph-与-pcisph-的关键区别"><a class="header" href="#二wcsph-与-pcisph-的关键区别">二、WCSPH 与 PCISPH 的关键区别</a></h2>
<ol>
<li>
<p><strong>WCSPH</strong>
$$
F_{\text{压力}} = F(P)
$$</p>
<ul>
<li>每次仅更新一次压力，无迭代修正</li>
<li>密度误差大（通常 &gt;1%），易出现体积漂移</li>
</ul>
</li>
<li>
<p><strong>PCISPH</strong>
$$
F_{\text{压力}} = F(\Delta P)
$$</p>
<ul>
<li>多次迭代修正压力，直到密度偏差 $\Delta P$ 满足阈值（如 &lt;0.1%）</li>
<li>密度约束更强，震荡更小（1% → 0.1%）</li>
<li>基于可压缩连续性方程推导，无需求解不可压缩泊松方程</li>
</ul>
</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implicit-imcompressible-sph"><a class="header" href="#implicit-imcompressible-sph">Implicit Imcompressible SPH</a></h1>
<pre class="mermaid">flowchart LR
    A[当前状态] --&gt;|预测步| B[中间状态]
    B --&gt; E[未知量：位置修正] 
    B --&gt; F[预测位置] 
    B --&gt; G[预测密度]
    B --&gt; H[期望密度]
    E &amp; F --&gt; I[基于动量的公式①]
    G &amp; H --&gt; J[基于密度约束势能的公式②]
    I &amp; J --&gt; K[构建方程组]--&gt; L[解出$$\Delta x$$]--&gt; M[下一时刻状态] --&gt; A[当前状态]
    
</pre>
<p>优化目标：<br />
不可压缩条件下的动量守恒</p>
<p>$$
E = \text{动能} + \lambda \cdot \text{约束项}
$$</p>
<p>(1)</p>
<p>$$
\frac{\partial E}{\partial x} = \frac{\partial \text{动能}}{\partial x} + \lambda \cdot \frac{\partial \text{约束项}}{\partial x} = 0
$$</p>
<p>(2)<br />
$$
\frac{\partial E}{\partial \lambda } = \text{约束项} = 0
$$</p>
<p>$$
\frac{\partial \text{动能}}{\partial x} = \int \rho u \frac{\partial u}{\partial t} dV 动能= \frac{1}{2} \int \rho u^2 dV (3)
$$</p>
<p>$$
\frac{\partial \text{约束项}}{\partial x} = \nabla \cdot \text{约束项} = \nabla \cdot u (4)
$$</p>
<p>(3) 化简得到NS方程的变分形式，即</p>
<p>$$
\rho \frac{D\boldsymbol{u}}{Dx} = -\nabla p - \rho (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} \quad (5)
$$</p>
<p>将公式(4)(5)离散化，得到方程：<br />
方程组中有两个未知量：\(\lambda, \boldsymbol{\nabla x}\)<br />
求解这个线性方程组 (不是泊松方程)</p>
<p>(4) 是 ISPH 的约束项的定义<br />
而IISPH的约束项的定义应该是：</p>
<p>$$
\rho^{n+1} = \rho^0
$$</p>
<p>IISPH 避开解泊松方程，但又使用了隐式积分和密度不变约束，在稳定性、精度、效率方面达到平衡。</p>
<h2 id="三iisph-补充"><a class="header" href="#三iisph-补充">三、IISPH 补充</a></h2>
<ul>
<li>隐式离散格式，无需求解泊松方程，效率更高</li>
<li>推导基于可压缩连续性方程，而非不可压缩泊松方程</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divergenc-fre-sphdfsph"><a class="header" href="#divergenc-fre-sphdfsph">Divergenc-Fre SPH(DFSPH)</a></h1>
<p>IISPH 使用“密度不变约束”达到速度无散的效果，但 DFSPH 直接使用速度无散约束。<br />
DFSPH 沿用“预测-修正”方法，也无须解泊松方程。 </p>
<pre class="mermaid">flowchart LR
    A[当前状态] --&gt;|预测步| B[中间状态]
    B --&gt;|SPH| E[中间速度场]
    E --&gt;|无散投影| F[无散速度场分量]
    E --&gt;|无散投影| G[有散势场分量]
    G --&gt;I[剔除]
    F --&gt;J[无散速度场]
    J --&gt;K[压强场]
    J --&gt;L[粒子位置]
    K --&gt;M[加速度]
    L --&gt;A[当前状态]
</pre>
<p>IISPH：密度不变 → 间接速度无散<br />
DFSPH：直接速度无散 → 自然密度守恒</p>
<p>无散投影使用亥姆霍兹分解，过程中求解标量势 \(\phi\) 的泊松方程，而不是压强 \(P\) 的泊松方程，计算量更小。</p>
<p>DFSPH 的特点</p>
<ol>
<li>无散投影的密度误差低，长期模拟几乎无体积漂移</li>
<li>解标量势 \(\phi\) 的泊松方程，与“IISPH的求解线性方程组”计算量相当，但DFSPH精度更高</li>
<li>适用于高保真流体模拟、大形变场景。</li>
</ol>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="positon-based-fluid-pbf"><a class="header" href="#positon-based-fluid-pbf">Positon Based Fluid (PBF)</a></h1>
<p>用于实时场景，PBD + SPH</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间自适应"><a class="header" href="#时间自适应">时间自适应</a></h1>
<p>剧烈运动时需要较小的时间步长，而当整体运动平缓时则可采用更长的步长。</p>
<ol>
<li>怎样算是合适的步长？</li>
<li>怎样计算一个粒子的适合的步长？</li>
<li>怎样管理粒子的仿真步长？</li>
<li>不同仿真步长之间的切换？</li>
<li>不同仿真粒子表现的跳变？</li>
</ol>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td>182</td><td>2014</td><td>Regional Time Stepping for SPH</td><td>适用于（WCSPH）的区域时间步长法（RTS），首个考虑不同区域的时间自适用算法。</td><td><a href="https://caterpillarstudygroup.github.io/ReadPapers/182.html">link</a></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="空间自适应"><a class="header" href="#空间自适应">空间自适应</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ongoing-research"><a class="header" href="#ongoing-research">Ongoing Research</a></h1>
<ul>
<li>
<p>How to make the simulation more efficient?</p>
</li>
<li>
<p>How to make fluids incompressible?</p>
</li>
<li>
<p>When simulating water, only use water particles, no air particles. So particles are sparse on the water-air boundary. How to avoid artifacts there?</p>
</li>
<li>
<p>Using AI, not physics, to predict particle movement?</p>
</li>
</ul>
<h2 id="非ai方法"><a class="header" href="#非ai方法">非AI方法</a></h2>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2025</td><td>Implicit Position-Based Fluids</td><td>1. 构建隐式积分转优化问题的目标函数<br> 2. 使用GPU亲和的方式解优化问题中的线性系统 <br> 3. 近似H保证H的正定性 <br> 4. 使流体趋于平静的机制</td><td></td><td><a href="https://dl.acm.org/doi/epdf/10.1145/3757377.3764005">link</a></td></tr>
</tbody></table>
<p>Lecture 2 [1:08:23]<br />
Lecture2[1:08:23]</p>
<p>其它粒子仿真方法：<br />
Discrete element methed<br />
Moving Particle Semi-implicit<br />
Power Particle<br />
Peridynamic</p>
<h2 id="ai方法"><a class="header" href="#ai方法">AI方法</a></h2>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2024</td><td>Modeling the real world with high-density visual particle dynamics</td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>刚体是指有体积但很硬不会发生形变的物体。</p>
<p>刚体所占的是一个连续的空间，包含了无限多个粒子。实际上会把它离散化为有限个相对位置关系不变的粒子的组合。离散化的方式有两种：</p>
<ol>
<li>仅用极少量的例子来表示刚体的外部轮廓。粒子之间用line连接，构成Mesh。用这种方式构造出的刚体不考虑与粒子之间的相互作用力。是最常见的方式。见<a href="Particle/../Rigid/Attribution.html">Mesh</a></li>
<li>用稠密的粒子点云来表示刚体所占据的空间。这种方式可以考虑粒子间的相互作用力，因此可以模拟刚体破碎的效果。<strong>这一页指的是这种情况。</strong></li>
</ol>
<p>无数的粒子以相对位置关系不变的方式聚合到一起，就形成了刚体。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="不可形变mesh--刚体"><a class="header" href="#不可形变mesh--刚体">不可形变Mesh —— 刚体</a></h1>
<p><a href="https://caterpillarstudygroup.github.io/GAMES102_mdbook/Introduction/3DData.html">Mesh</a>由顶点、边、面片组成。</p>
<p>不可形变的Mesh指，Mesh上的顶点、边、面片的相对位置位移保持不变，因此把不可形变Mesh称为刚体。刚体的特点是物体很硬，不考虑形变。</p>
<h1 id="刚体的仿真属性"><a class="header" href="#刚体的仿真属性">刚体的仿真属性</a></h1>
<p>把Mesh看作一个整体，Mesh相当于一个有体积的粒子。那么Mesh有以下属性：</p>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m（均质）或M（非均质）</td><td>否。</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>p或x</td><td>是。刚体所占的是一个连续的空间，而不是一个点。选择刚体中的某一个点（通常是质心）的位置作为刚体的位置。</td></tr>
<tr><td>全局旋转（世界坐标系）</td><td>q <br> 旋转的表示戳这里<a href="https://caterpillarstudygroup.github.io/mathematics_basic_for_ML/Geometry/Quaternion.html">link</a>。最后结论是四元数表示方法。</td><td>是</td></tr>
</tbody></table>
<p>对应的：</p>
<table><thead><tr><th>属性</th><th>符号</th><th>说明</th></tr></thead><tbody>
<tr><td>速度</td><td>v或\(\mathbf{\dot{x}} \)</td><td>p的一阶导</td></tr>
<tr><td>加速度</td><td>a</td><td>p的二阶导</td></tr>
<tr><td>角速度</td><td>\(\mathbf{\omega}\)或\(\mathbf{\dot{q}} \)</td><td>q的一阶导</td></tr>
<tr><td>角加速度</td><td></td><td>q的二阶导</td></tr>
</tbody></table>
<p><img src="Rigid/../assets/03-21.png" alt="" /> </p>
<p>$$ 
\begin{cases} \text{The direction of } \mathbf{\omega} \text{ is the axis.} \\<br />
\text{The magnitude of }  \mathbf{\omega} \text{ is the speed.}<br />
\end{cases}
$$ </p>
<h1 id="刚体顶点的属性"><a class="header" href="#刚体顶点的属性">刚体顶点的属性</a></h1>
<p>刚体上的顶点没有自己的自由度，因此没有仿真属性。但它们具有以下运动属性：</p>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>相对位置(质心的坐标系)</td><td>p或x</td><td>否。虽然每个粒子都有位置属性，但它们所有的粒子相对位移不变，因此不需要独立对每个粒子的位置属性做仿真，只需要仿真其中一个粒子的位置就可以。其它粒子的位置都是相对它的偏移</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>\(x_i\)</td><td>是。粒子的位置变化是由于质心坐标的平移和旋转导致的，是被动变化的，因此不直接仿真每个粒子的全局位置。</td></tr>
</tbody></table>
<p><img src="Rigid/../assets/03-2.png" alt="" /></p>
<blockquote>
<p>✅ reference：参考状态,无平移,无旋转，假设刚体在reference状态的坐标系与世界坐标系是一致的。<br />
当前状态：旋转为\(\mathbf{R}\)，平移为\(\mathbf{T}\). 那么物体上任意点的位置为：<br />
$$
\mathbf{{x}}' = \mathbf{Rx} + \mathbf{T}
$$</p>
</blockquote>
<p>粒子视角可以用于Mesh的受力分析，但是不能直接对Mesh上的粒子进行仿真，要把粒子受到的力转化为刚体的受力响应。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="刚体对外力的响应"><a class="header" href="#刚体对外力的响应">刚体对外力的响应</a></h1>
<p>虽然刚体受到的力都是作用在刚体上的某个点上。但受力点不能独立的响应这个力。而是要让刚体作为整体来响应这个力。<br />
即，刚体的质心的全局位置（世界坐标系）和全局旋转（世界坐标系）。<br />
因此，刚体在力的作用下会发生旋转和平移。</p>
<p><img src="Rigid/../assets/03-1.png" alt="" /></p>
<h2 id="刚体受到经过质心的力"><a class="header" href="#刚体受到经过质心的力">刚体受到经过质心的力</a></h2>
<p>刚体受到经过质心的力，会发生位移，即x的改变。但不会发生旋转。
以下情况可以看作是刚体受到经过质心的力：</p>
<ul>
<li>力作用在刚体的一个或多个点上，且每个力都经过质心</li>
<li>对于均质刚体，对整个刚体施加一个力，例如重力</li>
</ul>
<p>刚体受力后的平移响应与粒子相似。连续形式与离散形式下的速度、位置更新公式也相同。</p>
<p><img src="Rigid/../assets/03-3.png" alt="" /></p>
<h2 id="刚体受到一个不经过质心的力"><a class="header" href="#刚体受到一个不经过质心的力">刚体受到一个不经过质心的力</a></h2>
<p>对刚体上的一个点施加一个力F，且力不经过质心，其作用等效于：</p>
<ol>
<li>对刚体的质心施加一个力，其它大小与方向与F相同。这个力导致刚体平移。仿真方法上同一节。</li>
<li>对刚体施加一个力偶，其力矩使刚体发生旋转。</li>
</ol>
<blockquote>
<p>inertia、torque等概念，请戳这里<a href="Rigid/./supplementary.html">link</a></p>
</blockquote>
<p>参考刚体平移的离散积分过程，可以推导出刚体旋转的更新法则：</p>
<table><thead><tr><th></th><th>Translational (linear)</th><th>Rotational (Angular)</th></tr></thead><tbody>
<tr><td>Updafe</td><td><img src="Rigid/../assets/03-23.png" alt="" /></td><td><img src="Rigid/../assets/03-24.png" alt="" /></td></tr>
<tr><td>states</td><td>Velocity \(\mathbf{v}\) <br> Position \(\mathbf{x}\)</td><td>Angular velocity \(\mathbf{ω} \)<br>   Quaternion \(\mathbf{q}\)</td></tr>
<tr><td>Physical Quantities</td><td>Mass \(\mathbf{M}\) <br> Force \(\mathbf{f}\)</td><td>Inertia \(\mathbf{I} \) <br> Torque \(\mathbf{τ} \)</td></tr>
</tbody></table>
<blockquote>
<p>✅  平移： \(加速度 = \frac{力}{质量}\) ，旋转： \(加速度 =\frac{力矩}{\text{Inertia}}\)<br />
✅  \(q\)是四元数，代表物体的旋转状态<br />
✅  \(q_1\times q_2\)不是叉乘，而是四元数普通乘法<br />
✅  \(\begin{bmatrix}
0 &amp; \frac{\bigtriangleup t}{2}  &amp; w^{(1)}
\end{bmatrix}\)是一个四元数，0为实部，后面为虚部<br />
❗  算完\(q^{[1]}\)的之后要对它 Normalize<br />
🔎 由\(q^{[0]}\)到\(q^{[1]}\)的更新公式的推导过程见Affer Class Reading（Appendix B）</p>
</blockquote>
<p><img src="Rigid/../assets/03-20.png" alt="" /></p>
<h2 id="更复杂的情况"><a class="header" href="#更复杂的情况">更复杂的情况</a></h2>
<p>更复杂的情况，也都可以把力分解为经过质心的力（造成平移）和力矩（造成旋转）。<br />
计算出力和力矩以后，都可以套用以上公式更新刚体状态。</p>
<p>P30 </p>
<h1 id="总结-1"><a class="header" href="#总结-1">总结</a></h1>
<p><img src="Rigid/../assets/03-27.png" alt="" /><br />
<img src="Rigid/../assets/04-1.png" alt="" /></p>
<h1 id="after-class-reading-before-collision"><a class="header" href="#after-class-reading-before-collision">After-Class Reading (Before Collision)</a></h1>
<p>P35</p>
<p><a href="https://graphics.pixar.com/pbm2001">https://graphics.pixar.com/pbm2001</a></p>
<blockquote>
<p>✅ 建议读其中的Rigid Body Dynamics部分</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><pre class="mermaid">mindmap
弹性体
    属性
        可仿真属性
        约束
    仿真方法
        弹簧系统
        基于投影的方法
            PBD
            PD
            Strain Limiting
        基于形变的方法
            FEM
            FVM
    应用场景
        线
        布
        软体
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可形变-mesh-的属性"><a class="header" href="#可形变-mesh-的属性">可形变 Mesh 的属性</a></h1>
<p>可形变 Mesh 同样拥有顶点、边和面片，但其顶点之间的位置关系不保证严格不变，又不像粒子系统中的顶点那边可以随意移动。每个顶点可以独立移动，但顶点之间又满足约束关系。因此把可形变 Mesh 称为弹性体。</p>
<p>虽然可形变 Mesh 与不可形变 Mesh 底层有相同的数据结构，但他们的仿真自由度不同，对应的可仿真的属性不同，因此也产生了不同仿真方式。</p>
<h2 id="弹性体的仿真属性"><a class="header" href="#弹性体的仿真属性">弹性体的仿真属性</a></h2>
<p>弹性体上的每个顶点都有自己的自由度，即独立的仿真属性：</p>
<table><thead><tr><th>属性</th><th>符号</th><th>在通常的仿真场景中是否可变</th></tr></thead><tbody>
<tr><td>质量</td><td>m</td><td>否</td></tr>
<tr><td>全局位置（世界坐标系）</td><td>\(x_i\)</td><td>是</td></tr>
</tbody></table>
<p>弹性体与粒子系统的区别在于，顶点之间是存在约束的：</p>
<ol>
<li>顶点之间的距离( Mesh 的边的长度)要尽量保持不变</li>
<li>Mesh 的体积要尽量保持不变</li>
<li>Mesh 的每个面片尽量不要发生形变</li>
</ol>
<h1 id="应用场景-1"><a class="header" href="#应用场景-1">应用场景：</a></h1>
<p>线、布料、弹性体</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="弹簧质点模型"><a class="header" href="#弹簧质点模型">弹簧质点模型</a></h1>
<blockquote>
<p>✅ 整体流程就像是对 Mesh 上的每个顶点独立地进行粒子仿真，只是力变得复杂，因为在粒子之间增加了弹簧。当弹簧发生形变，就产生了弹簧力（内力）。<br />
✅ 通过在粒子间构造弹簧来约束 Mesh 边长尽量不变。通过构造网状的弹簧系统来保证 Mesh 面片不发生形变。通过增加对角顶点的弹簧来约束 Mesh 体积上的形变。</p>
</blockquote>
<pre class="mermaid">---
title: 弹簧系统   
---
flowchart LR
    Current([&quot;当前状态&quot;]) 
    Constrain[(&quot;约束&quot;)]
    Outter[(&quot;外力&quot;)]
    Energy([&quot;能量&quot;]) 
    Force([&quot;内力&quot;]) 
    Next([&quot;下一时刻状态&quot;]) 

    Constrain--&gt;Energy--&gt;Force
    Outter &amp; Force &amp; Current --&gt; Integrate --&gt; Next --&gt; Current
</pre>
<p>积分可以是显式积分或者隐式积分。如果是显式积分，由力得到速度，速度更新状态。</p>
<pre class="mermaid">---
title: 弹簧系统 - 显式积分   
---
flowchart LR
    Current([&quot;当前状态&quot;]) 
    Constrain[(&quot;约束&quot;)]
    Outter[(&quot;外力&quot;)]
    Energy([&quot;能量&quot;]) 
    Force([&quot;内力&quot;]) 
    Velocity([&quot;速度&quot;]) 
    Next([&quot;下一时刻状态&quot;]) 

    Constrain--&gt;Energy--&gt;Force
    Outter &amp; Force --&gt; Velocity
    Velocity &amp; Current --&gt; Next
</pre>
<p>但显式积分存在不稳定性问题，在图形学中更常用的是隐式积分。</p>
<pre class="mermaid">---
title: 弹簧系统 - 隐式积分   
---
flowchart LR
    Current([&quot;当前状态&quot;]) 
    Constrain[(&quot;约束&quot;)]
    Outter[(&quot;外力&quot;)]
    Energy([&quot;势能能量&quot;]) 
    Mometen([&quot;动能能量&quot;]) 
    Target([&quot;优化目标&quot;])
    Velocity([&quot;速度&quot;]) 
    Next([&quot;下一时刻状态&quot;]) 
    NextWoContrain([&quot;不考虑约束的下一时刻状态&quot;])

    Outter --&gt; Velocity
    Velocity &amp; Current --&gt; NextWoContrain --&gt; Mometen
    Constrain--&gt;Energy 
    Energy &amp; Mometen --&gt; Target --&gt; Optimize --&gt; Next
</pre>
<blockquote>
<p>✅ 本节课所讲的套路：分析力/能量 → 隐式积分 → 通过优化解积分 → 更新，对弹簧系统、有限元、弹性体等各种物理模拟同样适用。区别在于如何构造能量和解优化问题。</p>
</blockquote>
<h2 id="构建弹簧系统"><a class="header" href="#构建弹簧系统">构建弹簧系统</a></h2>
<h3 id="an-ideal-spring--一个端点"><a class="header" href="#an-ideal-spring--一个端点">An Ideal Spring —— 一个端点</a></h3>
<p><img src="Elastic/../assets/02-46.png" alt="" /></p>
<blockquote>
<p>✅ Energy：物理上的弹性势能<br />
✅ Force：物理上的力，是 Energy 的 gradient 的反方向; 公式后面有个 T,来源于前面的\(\nabla \)，直观解释，前面是力的大小，后面是力的方向。<br />
🔍 Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH) --- 以上公式推导的详细过程</p>
</blockquote>
<h3 id="an-ideal-spring--两个端点"><a class="header" href="#an-ideal-spring--两个端点">An Ideal Spring —— 两个端点</a></h3>
<p><img src="Elastic/../assets/02-47-1.png" alt="" /></p>
<p>$$
\mathbf{f} _ i(\mathbf{x} )=−∇ _ i\mathbf{E} =−k(||\mathbf{x} _ i −\mathbf{x} _ j||−L)\frac{\mathbf{x} _ i −\mathbf{x} _ j}{||\mathbf{x} _ i −\mathbf{x} _ j ||} \\
\mathbf{f} _ j(\mathbf{x})=−∇ _ jE=−k (||\mathbf{x} _ j −\mathbf{x} _ i ||−L)\frac {\mathbf{x} _ j −\mathbf{x} _ i}{||\mathbf{x} _ j −\mathbf{x} _ i||}
$$</p>
<p>P5</p>
<h3 id="multiple-springs"><a class="header" href="#multiple-springs">Multiple Springs</a></h3>
<p>When there are many springs, the energies and the forces can be simply summed up.</p>
<p><img src="Elastic/../assets/05-3.png" alt="" /></p>
<p>$$
E= {\textstyle \sum_{e=0}^{3}}E_e= {\textstyle \sum_{e=0}^{3}} (\frac{1}{2} k(||\mathbf{x} _i −\mathbf{x}_e ||−L_e)^2)
$$</p>
<p>$$
f_i=−\nabla_iE = \textstyle \sum_{e=0}^{3}(−k(||\mathbf{x}_i−\mathbf{x}_e||−L_e)\frac{\mathbf{x}_i−\mathbf{x}_e}{||\mathbf{x}_i−\mathbf{x}_e||})
$$</p>
<blockquote>
<p>✅ 能量和力都是可以叠加的</p>
</blockquote>
<h2 id="积分系统显式积分"><a class="header" href="#积分系统显式积分">积分系统——显式积分</a></h2>
<p>P12<br />
与粒子仿真相同。每个 Mesh 顶点根据受力更新位置的过程涉及积分。积分离散化也可以是显式、隐式、半隐式。</p>
<p>Explicit integration suffers from <strong>numerical instability</strong> caused by <u>overshooting</U>, when the stiffness \(k\) and/or the time step \(∆t\) is too large.</p>
<blockquote>
<p>✅ Explicit：当前力 → 当前速度 → 当前位置<br />
显式积分不稳定，如果 \(Δt\) 或 \(k\) 太大，会导致 overshooting。</p>
</blockquote>
<p>A naive solution is to use a small \(∆t\) . But that slows down the simulation.</p>
<blockquote>
<p>✅ 解决方法：减小\(\Delta t\)。但这个方法不解决本质问题，且会降低整个模拟系统的效率<br />
✅ 本质上是\(Δt\)太大导致积分近似的结果与实际积分的结果有很大误差，\(k\)太大或\(Δt\)只是让这个问题更明显，减小\(k\)或\(Δt\)问题仍然存在。</p>
</blockquote>
<p>P13</p>
<h2 id="积分系统隐式积分"><a class="header" href="#积分系统隐式积分">积分系统——隐式积分</a></h2>
<p>Implicit integration is a better solution to numerical instability.  The idea is to integrate both <strong>x</strong> and <strong>v</strong> implicitly.</p>
<blockquote>
<p>✅ Explicit和Implicit都是用某个时刻的力代表整个 \(Δt\) 时间的力，就都会出现上述误差。<br />
✅ 区别在于，Explicit用当前力，往往使结果变大，产生爆炸，Implicit用未来力，往往使结果变小，产生消失。<br />
✅ 消失只是结果不对。但爆炸会让结果崩溃，这是最不可接受的问题。因此用隐式代替显式。</p>
</blockquote>
<p>隐式积分相对稳定，可以使用稍大的 \(Δt\)，但也存在以下问题：</p>
<ol>
<li>实现复杂，因此难以优化。</li>
<li>每个 \(Δt\) 的求解更耗时，因此不一定会更快。</li>
<li>可能出现数值振荡。</li>
</ol>
<h3 id="二元非线性方程组---一元非线性方程"><a class="header" href="#二元非线性方程组---一元非线性方程">二元非线性方程组 -&gt; 一元非线性方程</a></h3>
<p>隐式积分用未来力计算未来速度，用未来速度计算未来位置。未来力，未来速度，未来位置都是未知量，不能直接求解，需要解方程。</p>
<blockquote>
<p>✅ 粒子和刚体的仿真中使用了半隐式积分(现在的力，未来的速度)。</p>
</blockquote>
<p><img src="Elastic/../assets/05-11.png" alt="" /></p>
<blockquote>
<p>✅ 质点的质量可以不同吗？<br />
答：可以不同。先根据三角形的面积计算三角的质量，再把质量分配到各个顶点上。<br />
M是一个3n*3n的对角矩阵，具体形式为：</p>
</blockquote>
<p>$$
M = \begin{pmatrix}
m_1 I_3 &amp; 0 &amp; \cdots &amp; 0 \\
0 &amp; m_2 I_3 &amp; \cdots &amp; 0 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; m_n I_3
\end{pmatrix}
$$</p>
<p>假设F是一个保守力，即F是只与x有关的非线性函数，那么公式中的f[1]不是一个新的未知量。</p>
<blockquote>
<p>✅ 保守力 holonomic：力的大小和方向只跟位置有关，跟速度无关。例如重力，弹力。那么 \(f\)可以写成关于位置的函数\(f(x)\)。但\(f(x)\)不一定是线性的。</p>
</blockquote>
<p>公式 2 代入公式 1 并消元，得：</p>
<p>$$
\mathbf{v} ^{[1]}=\mathbf{v}^{[0]}+∆t\mathbf{M} ^{−1}\mathbf{f} (\mathbf{x}^{[0]}+∆t\mathbf{v} ^{[1]})
$$</p>
<p>或把公式1代入公式2并消元，得：</p>
<p>消元得：<br />
$$
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+\Delta t\mathbf{v} ^{[0]}+\Delta t^2\mathbf{M} ^{-1}\mathbf{f}(x^{[1]})
$$</p>
<p>对x或v消元，解法都是类似的。最后都转化为解非线性方程的问题。</p>
<h3 id="线性近似法求解一元非线性方程-解线性系统"><a class="header" href="#线性近似法求解一元非线性方程-解线性系统">线性近似法：求解一元非线性方程-&gt;解线性系统</a></h3>
<blockquote>
<p>✅ 近似成线性问题后直接解方程。这种方法相当于每一个Step做了一次牛顿法。</p>
</blockquote>
<p>以对x消元结果为例，\(\mathbf{f}\) 在 \(\mathbf{x}^{[0]}\) 处泰勒展开，得：</p>
<p>$$ 
\mathbf{v} _{t+1}=\mathbf{v}_t+∆t\mathbf{M} ^{−1}[\mathbf{f} (\mathbf{x}_t)+\frac{\partial \mathbf{f} }{\partial \mathbf{x} }(\mathbf{x} _t) ∆t\mathbf{v} _{t+1}] 
$$</p>
<p>整理后得:</p>
<p>$$
[\mathbf{I}-∆t^2\mathbf{M} ^{−1}\frac{\partial \mathbf{f} }{\partial \mathbf{x} }(\mathbf{x} _t)  ]\mathbf{v} _{t+1}=\mathbf{v}_t+∆t\mathbf{M} ^{−1}\mathbf{f} (\mathbf{x}_t)
$$</p>
<p>这就成了一个解线性系统的问题。解线性系统见<a href="Elastic/../Math/LinearSolver.html">Linear Solver</a></p>
<blockquote>
<p>问：为什么不直接求逆？<br />
答：求逆太贵</p>
</blockquote>
<p>这个公式再泛化一下，引入一个beta，就可以把隐式积分与之前的显式积分、中点法积分统一起来。</p>
<p>$$
[\mathbf{I} -\beta \Delta t^2\mathbf{M} ^{-1}\frac{\partial \mathbf{f} }{\partial \mathbf{x} }(\mathbf{x} _t )]\mathbf{v} _{t+1}=\mathbf{v} _t+\Delta t\mathbf{M} ^{-1}\mathbf{f} (\mathbf{x} _t)
$$</p>
<p>❶ \(\beta\) = 0: forward/semi-implicit Euler (explicit)<br />
❷ \(\beta\) = 1/2: middle-point (implicit)<br />
❸ \(\beta\) = 1: backward Euler (implicit)</p>
<h3 id="方法二求解一元非线性方程-优化问题"><a class="header" href="#方法二求解一元非线性方程-优化问题">方法二：求解一元非线性方程-&gt;优化问题</a></h3>
<blockquote>
<p>✅ 课后答疑：<br />
能量优化的方法很少用于刚体，主要是有限元、弹性体、衣服模拟。<br />
构造优化目标F(x)：</p>
</blockquote>
<p>$$
F(\mathbf{x}) = \frac{1}{2∆t^2}||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_\mathbf{M}^2+E(\mathbf{x} )
$$</p>
<p>有：
$$
\mathbf{x} ^{[1]} = \argmin F(\mathbf{x})
$$</p>
<blockquote>
<p>✅ 前面方程解\({x} ^{[1]}\)等价于F(x)函数极小点。等价转换的推导在<strong>补充1</strong>。非线性方程问题为转化为优化问题。<br />
✅ 其中：\(\mathbf{M}\)对角矩阵，描述质量，\(3N \times 3N\)。\(\mathbf{x}\)为 \(3N\times 1\)矢量,描述顶点信息。\(E\) 为所有的力的能量。\(\mathbf{||x||_M^2=x^TMx} \)。<br />
✅ 只有保守力能用能量描述、非保守力（例如摩擦力）则不行。</p>
</blockquote>
<p>定义 \(\mathbf{g(x)} =\mathbf{x} ^{[0]}+\Delta t\mathbf{v}^{[0]}+\Delta t^2M^{-1}f(\mathbf{x}^{[1]})-\mathbf{x} ^{[1]}\)<br />
也可以得出：\(x^{[1]}=\mathrm{argmin} (g(\mathbf{x} )^2)\) 或 \(\mathbf{x}^{[1]}=\mathrm{argmin} |\mathbf{g(x)}|\)</p>
<p>只是这样构造出的优化问题，求导比较难计算。</p>
<p>P18</p>
<h3 id="newtons-method解优化问题-解线性系统"><a class="header" href="#newtons-method解优化问题-解线性系统">Newton’s Method：解优化问题-&gt;解线性系统</a></h3>
<blockquote>
<p>🔎 Newton-Raphson Method见补充2. 这里直接开始Newton方向在本当前场景的应用。</p>
</blockquote>
<p>Specifically to simulation, we have:</p>
<p>$$
F (\mathbf{x} )=\frac{1}{2∆t^2} ||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_\mathbf{M} ^2+\mathbf{E} (\mathbf{x} )
$$</p>
<p>$$
∇F(\mathbf{x}^{(k)})=\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})−\mathbf{f}(\mathbf{x}^{(k)})=b
$$</p>
<p>$$
\frac{∂^2F (\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} =\frac{1}{∆t^2} \mathbf{M} +\mathbf{H} (x^{(k)})=\mathbf{A}
$$</p>
<p>解线性系统 \(A \Delta \mathbf{x} =b\)</p>
<p><img src="Elastic/../assets/05-28.png" alt="" /></p>
<h3 id="positive-definiteness-of-hessian"><a class="header" href="#positive-definiteness-of-hessian">Positive Definiteness of Hessian</a></h3>
<p>为了让优化问题收敛，我们希望A是正定的，具体原因见补充材料。</p>
<p><img src="Elastic/../assets/05-18.png" alt="" /></p>
<blockquote>
<p>✅ 而A的正定性取决于\(H(x)\) 的正定性。
✅ \(H(x)\)的维度是\(3N \times 3N\)，N 是弹簧数。每个\(H_e\)的维度是\(3 \times 3\)。它是由所有弹簧的H构成的。</p>
</blockquote>
<p><img src="Elastic/../assets/05-17.png" alt="" /></p>
<blockquote>
<p>✅ H(x)的正定性则是由 \(H_e\) 的正定性决定。</p>
</blockquote>
<p>下面分析\(H_e\)的正定性：<br />
For any \(\mathbf{x} _{ij}, \mathbf{v} ≠0\),</p>
<p>$$
\mathbf{V}^\mathbf{T}\frac{{\mathbf{x} _{ij}\mathbf{x} _{ij}}^\mathbf{T} }{||\mathbf{x} _{ij}||^2}\mathbf{V}=||\frac{{\mathbf{x} _{ij}}^\mathbf{T} \mathbf{v} }{||\mathbf{x} _{ij}||}||^2&gt; 0
$$</p>
<p>$$
\mathbf{V} ^\mathbf{T} (\mathbf{I} -\frac{{\mathbf{x} _{ij}\mathbf{x} _{ij}}^\mathbf{T} }{||\mathbf{x} _{ij}||^2}) \mathbf{V} =\frac{||\mathbf{x} _{ij}||^2||\mathbf{v} ||^2-||{\mathbf{x} _{ij}}^\mathbf{T} \mathbf{v} ||^2}{||\mathbf{x} _{ij}||^2}\ge 0 
$$</p>
<blockquote>
<p>✅ \( \mathbf{x}_ {ij}\) 代表顶点\( \mathbf{x}_ {i}\)和顶点\( \mathbf{x}_ {j}\)的位置的差。<br />
✅ 最后一个公式分子满足柯西不等式<br />
✅ 结论：\(||x_{ij}||&lt; Le\). 代表弹簧处于压缩状态。此时 He 有可能非正定(可能有多个极小值点)，但拉伸时一定正定。<br />
✅ He 正定则\(H(x)\)半正定，此时弹簧系统有唯一解。<br />
✅ \(\Delta t\)越小，A越容易正定、弹簧系统越稳定。<br />
✅ 但是A不正定，不代表没有唯一解。</p>
</blockquote>
<p>P23</p>
<h3 id="enforcement-of-positive-definiteness"><a class="header" href="#enforcement-of-positive-definiteness">Enforcement of Positive Definiteness</a></h3>
<blockquote>
<p>✅ 不正定最大的问题不是解不唯一，因为解出任意一个解都能让模拟系统进行下去。<br />
✅ 非正定的主要问题，是数学计算上的不稳定，可能导致解不出来； </p>
</blockquote>
<ul>
<li>One solution is to simply drop the ending term, when \({\color{Orange}{ ||\mathbf{x} _{ij}||&lt;\mathbf{L} _e}}:\)</li>
</ul>
<p><img src="Elastic/./assets/05-20.png" alt="" /></p>
<blockquote>
<p>✅ 简单粗爆的解决方法就是把后面这项删掉。</p>
</blockquote>
<blockquote>
<p>🔎 Choi and Ko. 2002. Stable But Responive Cloth. TOG (SIGGRAPH) --- 其它让He正定的方法</p>
</blockquote>
<p>P27</p>
<h1 id="after-class-reading-1"><a class="header" href="#after-class-reading-1">After-Class Reading</a></h1>
<blockquote>
<p>🔎 Baraff and Witkin. 1998. Large Step in Cloth Simulation. SIGGRAPH.</p>
</blockquote>
<blockquote>
<p>✅这篇论文是衣服模拟的经典论文，第一个用隐式积分做衣服模型的论文。论文没有用弹簧系统，而是另一套模型。<br />
✅ 关注其中解隐式积分的部分，没有做非线性优化或解非线性方程，而是把非线性方程线性化，等价于做一次牛顿迭代。<br />
🔎 Fast mass - spring system solver</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P2</p>
<h1 id="构建弹簧网络"><a class="header" href="#构建弹簧网络">构建弹簧网络</a></h1>
<p>P6</p>
<h2 id="structured-spring-networks"><a class="header" href="#structured-spring-networks">Structured Spring Networks</a></h2>
<p><img src="./assets/05-4.png" alt="" /></p>
<blockquote>
<p>✅ 绿线：防止斜方向的拉伸。蓝线：防止翻折。</p>
</blockquote>
<p>P7</p>
<h2 id="unstructured-spring-networks"><a class="header" href="#unstructured-spring-networks">Unstructured Spring Networks</a></h2>
<p>We can also turn an unstructured triangle mesh into a spring network for simulation.</p>
<p><img src="./assets/05-5.png" alt="" /></p>
<blockquote>
<p>✅ 蓝线：抵抗弯曲。对每条内部边，加这样一根弹簧。</p>
</blockquote>
<p>P8</p>
<h3 id="怎样基于三角形mesh增加蓝线弹簧"><a class="header" href="#怎样基于三角形mesh增加蓝线弹簧">怎样基于三角形Mesh增加蓝线弹簧</a></h3>
<p>The basic representation of a triangle mesh uses vertex and triangle lists. </p>
<p><img src="./assets/05-6.png" alt="" /></p>
<blockquote>
<p>✅ 已知边的信息，需找出内部边，例如\(\mathbf{x}_0\mathbf{x}_3\)，因此要基于此构造边：\(\mathbf{x}_1x 4\)<br />
✅ Each triangle has three edges. But there are repeated ones. Repeated edges就是内部边。<br />
✅ 1. 找出内部边。2. 找出内部边所属于的两个三角形。3.  找出两个三角形上不在这条内部边上的点。4. 连续一根弹簧。</p>
</blockquote>
<p>Vertex list: {\(\mathbf{x} _0, \mathbf{x}_1, \mathbf{x}_2, \mathbf{x}_3, \mathbf{x}_4\)}    (3D vectors)</p>
<p>Triangle list: {1, 2, 3, 0, 1, 3, 0, 3, 4}    (index triples)</p>
<p>The key to topological construction is to sort triangle edge triples.</p>
<p>Each triple contains: edge vertex index 0, edge vertex index 1 and triangle index (index 0&lt;index). </p>
<p><img src="./assets/05-8.png" alt="" /></p>
<blockquote>
<p>✅ 排序：基于边排序，排序后相同边会靠在一起</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P29</p>
<h1 id="the-bending-spring-issue"><a class="header" href="#the-bending-spring-issue">The Bending Spring Issue</a></h1>
<p>A <strong>bending</strong> spring offers <strong>little resistance</strong> when cloth is nearly planar, since its length barely changes.</p>
<p><img src="./assets/05-22.png" alt="" /></p>
<blockquote>
<p>✅ 黑线为三角形面片，每条边一根弹簧，并增加一根蓝线弹簧，构成弯曲弹簧，阻止两个面片弯折。<br />
✅ 存在的问题：小的弯折，弹簧长度几乎不变，抵抗弯曲的力量非常弱。（不适用于类似于纸的弯折效果）。</p>
</blockquote>
<p>P30</p>
<h2 id="a-dihedral-angle-model"><a class="header" href="#a-dihedral-angle-model">A Dihedral Angle Model</a></h2>
<p>A dihedral angle model defines bending forces as a function of \(\theta : \mathbf{f} _i=f (\theta )\mathbf{u} _i\).</p>
<blockquote>
<p>✅ Dihedarl Angel:二面角<br />
✅ 把弯曲的力写成关于二面角的函数</p>
</blockquote>
<p><img src="./assets/05-23.png" alt="" /></p>
<blockquote>
<p>✅ \(x_1, x_2, x_3, x_4\) 都会受到 bending force. 力的大小相同但方向不同，但都是关于二面角的函数。<br />
✅\(u_i\)：描述力的方向，与\(\theta\)大小无关。\(f(\theta)\)：描述力的大小，是关于\(\theta\)的函数。</p>
</blockquote>
<ul>
<li>
<p>First, \(\mathbf{u}_1\) and \(\mathbf{u}_2\) should be in the normal directions \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
<li>
<p>Second, bending <strong>doesn’t stretch the edge</strong>, so \(\mathbf{u}_4\)−\(\mathbf{u}_3\) should be orthogonal to the edge, i.e., in the span of \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
<li>
<p>Finally, \(\mathbf{u}_1+\mathbf{u}_2+\mathbf{u}_3+\mathbf{u}_4=\mathbf{0}\), which means \(\mathbf{u}_3\) and \(\mathbf{u}_4\) are in the span of \(\mathbf{n}_1\) and \(\mathbf{n}_2\).</p>
</li>
</ul>
<blockquote>
<p>✅ 合力为0。</p>
</blockquote>
<p>P31<br />
Conclusion:</p>
<p><img src="./assets/05-24.png" alt="" /></p>
<blockquote>
<p>✅ N是未归一化的 normal. N 的方向与 normal 相同。大小为三角形的面积。<br />
✅ 重要的不是结果，而是根据观察进行合理假设的思考过程。</p>
</blockquote>
<p>P32</p>
<p>Planar case:</p>
<p>$$
\mathbf{f} _i=k\frac{||\mathbf{E}||^2}{||\mathbf{N}_1||+||\mathbf{N}_2||} \sin(\frac{π−\theta}{2})\mathbf{u} _i
$$</p>
<p>Non-planar case:</p>
<p>$$
\mathbf{f} _i=k\frac{||\mathbf{E} ||^2}{||\mathbf{N} _1||+||\mathbf{N} _2||}(\sin(\frac{π−\theta}{2})-\sin(\frac{π−\theta_0}{2}))\mathbf{u}_i
$$</p>
<blockquote>
<p>✅ Non-planar case：不是指弯曲时的力，而是指静止状态(reference state)为非平面的场景下，弯曲为\(\theta\)时的力。\(\theta_0\)表示 reference state.<br />
✅ 老师没解释公式怎么来的<br />
🔎 Bridson et al. 2003. <em>Simulation of Clothing with Folds and Wrinkles</em>. SCA.<br />
✅ 此论文适合读完。除了弯曲模型，还有一些有意思的设计。</p>
</blockquote>
<p>Explicit integration.<br />
Derivative is difficult to compute.</p>
<blockquote>
<p>✅ 由于完全基于力而不考虑能量，适合用显式积分。</p>
</blockquote>
<p>P34</p>
<h2 id="a-quadratic-bending-model"><a class="header" href="#a-quadratic-bending-model">A Quadratic Bending Model</a></h2>
<blockquote>
<p>✅ 二面角方法是纯分析力的方法，比较复杂。此处是Bending issue的另一个方法。</p>
</blockquote>
<p>A quadratic bending model has two assumptions: 1) planar case; 2) little stretching.</p>
<p><img src="./assets/05-25.png" alt="" /></p>
<p>$$
E(\mathbf{x} )=\frac{1}{2} \begin{bmatrix}
\mathbf{x}_0 &amp; \mathbf{x}_1 &amp; \mathbf{x}_2 &amp; \mathbf{x}_3
\end{bmatrix}\mathbf{Q} \begin{bmatrix}
\mathbf{x}_0 \\
\mathbf{x}_1 \\
\mathbf{x}_2\\
\mathbf{x}_3
\end{bmatrix}
$$</p>
<p>$$
\mathbf{Q} =\frac{3}{\mathbf{A} _0+\mathbf{A} _1}\mathbf{qq^T}
$$</p>
<blockquote>
<p>✅ \({\mathbf{A} _0}\)和\({\mathbf{A} _1}\)是两个三角形在reference状态下的面积。</p>
</blockquote>
<p>$$
\mathbf{q} = \begin{bmatrix}
(\cot\theta _1+ \cot\theta _3)\mathbf{I} \\
(\cot\theta _0+ \cot\theta _2)\mathbf{I} \\
(-\cot\theta _0- \cot\theta _1)\mathbf{I} \\
(-\cot\theta _2- \cot\theta _3)\mathbf{I}
\end{bmatrix}
$$</p>
<p>\(\mathbf{I}\) is 3-by-3 identity.</p>
<blockquote>
<p>✅ \(\mathbf{Q}\)只与\(\mathbf{\theta}\)有关，因此是一个定值。</p>
</blockquote>
<p>It’s not hard to see that: \(E (\mathbf{x} )=\frac{3||\mathbf{q} ^\mathbf{T}\mathbf{x} ||^2}{2(A_0+A_1)}\).  Also, \(E (\mathbf{x} )=0\) when the triangles are flat.</p>
<blockquote>
<p>✅ \(\mathbf{q^T}\mathbf{x}\)在估算两个三角形的拉普拉斯，即两个三角的曲率、当两个三角形共面时， \(E(\mathbf{x})=0\)<br />
🔎 离散曲面的拉普拉斯，见GAMES102<br />
✅ \(E(\mathbf{x})\) 来自数学上曲率的推导，而不是来自物理意义的推导。<br />
✅ 问题：能量的思想能用在刚体上吗？<br />
答：这里的能量是弹性能量、刚体无弹性，因此也无所谓能量。</p>
</blockquote>
<h3 id="pros-of-the-quadratic-bending-model"><a class="header" href="#pros-of-the-quadratic-bending-model">Pros of The Quadratic Bending Model</a></h3>
<ul>
<li>Easy to implement:</li>
</ul>
<blockquote>
<p>✅ \(E(\mathbf{x})\)是关于\(\mathbf{x}\)的二次函数，很容易计算\(E(\mathbf{x})\)的一阶导（力）和二阶导\(\mathbf{H} \)</p>
</blockquote>
<p>$$
\mathbf{f} (\mathbf{x} )=−\nabla \mathbf{E} (x)= −\mathbf{Q} \begin{bmatrix}
\mathbf{x} _0\\
\mathbf{x} _1\\
\mathbf{x} _2 \\
\mathbf{x} _3
\end{bmatrix}
$$</p>
<p>$$
\mathbf{H} (\mathbf{x} )=\frac{∂^2E(\mathbf{x} )}{∂\mathbf{x} ^2}=\mathbf{Q} 
$$</p>
<ul>
<li>Compatible with implicit integration.</li>
</ul>
<h3 id="cons-of-the-quadratic-bending-model"><a class="header" href="#cons-of-the-quadratic-bending-model">Cons of The Quadratic Bending Model</a></h3>
<ul>
<li>No longer valid if cloth stretches much.</li>
</ul>
<blockquote>
<p>✅方法假设面料拉伸比较小，当面料拉伸太大，\(\mathbf{\theta}\)就会改变，\(\mathbf{Q}\)就不准了。</p>
</blockquote>
<ul>
<li>Not suitable if the rest configuration is not planar.
<ul>
<li>Cubic shell model.</li>
<li>Projective dynamics model.</li>
</ul>
</li>
</ul>
<h3 id="after-class-reading-2"><a class="header" href="#after-class-reading-2">After Class Reading</a></h3>
<blockquote>
<p>🔎 Bergou et al. 2006. <em>A Quadratic Bending Model for Inextensible Surfaces</em>. SCA.<br />
✅ 这篇论文是在本算法上的进一步工作。</p>
</blockquote>
<p>P37</p>
<h1 id="the-locking-issue"><a class="header" href="#the-locking-issue">The Locking Issue</a></h1>
<p>So far we talked about the mass-spring model and other bending models, <strong>assuming cloth planar deformation and cloth bending deformation are independent</strong>.</p>
<p>Is it true? Think about a zero bending case. Can a simulator fold cloth freely?</p>
<blockquote>
<p>✅ 正常来讲拉伸和弯曲是两件独立的事情。但在弹簧模型系统中，把它们耦合了。<br />
✅ 例如纸这种无弹性的面料，会把它的弹性系数调得很大，达到无弹性的效果。但导致了它无法弯折的artifacts。<br />
✅ 在K很大或网格分辨率低时， locking issue 会特别明显。</p>
</blockquote>
<p>P38</p>
<p>The fundamental reason is due to a short of degrees of freedoms (DoFs).<br />
For a <u>manifold</u> mesh, Euler’s formula says:#edges=3#vertices-3-#boundary_edges.<br />
So if edges are all hard constraints, the DoFs are only: 3+ #boundary_edges.</p>
<blockquote>
<p>✅ 自由度 = 变量数 - 约束数。<br />
✅ 每个顶点有3个自由度、每条边是一个约束，因此单纯加点不会改善，但让点变密可以改善<br />
✅ 实操套路：1. 弹簧压缩时让k比较小；2. 假设弹簧在一定长度范围内可自由活动，不受力，以上方法都不解决根本问题；3. 把自由度定义在边上不­是顶点上，但把问题搞得更复杂了。</p>
</blockquote>
<p>P43</p>
<h1 id="a-summary-for-the-day-1"><a class="header" href="#a-summary-for-the-day-1">A Summary For the Day</a></h1>
<ul>
<li>
<p>A mass-spring system</p>
<ul>
<li>Planar springs against stretching/compression - replaceable by co-rotational model</li>
<li>Bending springs - replaceable by dihedral or quadratic bending</li>
<li>Regardless of the models, as long as we have \(E (\mathbf{x})\), we can calculate force \(\mathbf{f} (\mathbf{x} )=−∇ \mathbf{E} (\mathbf{x})\) and Hessian \(\mathbf{H} (\mathbf{x} )=∂E^2(\mathbf{x} )/∂\mathbf{x} ^2\).  Forces and Hessians are stackable.</li>
</ul>
</li>
<li>
<p>Two integration approaches</p>
<ul>
<li>Explicit integration, just need force.  Instability</li>
<li>Implicit integration, as a nonlinear optimization problem</li>
<li>One way is to use Newton’s method, which solves a linear system in every iteration:</li>
</ul>
</li>
</ul>
<p>$$
(\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} (\mathbf{x} ^{(k)}))∆\mathbf{x} =− \frac{1}{∆t^2} \mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})
$$</p>
<ul>
<li>There are a variety of linear solvers (beyond the scope of this class).</li>
<li>Some simulators choose to solve only one Newton iteration, i.e., one linear system per time step.</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="position-based-dynamics-pbd"><a class="header" href="#position-based-dynamics-pbd">Position Based Dynamics (PBD)</a></h1>
<p>每个顶点独立仿真，也不用考虑弹簧力。<br />
顶点独立运动后，约束被破坏。通过投影的方式保持约束。投影是指，直接当前的(不合理的)状态直接变成最近的合理的状态。难点在于怎么找到最近的合理的状态。 </p>
<pre class="mermaid">---
title: PBD
---
flowchart LR
    Current([&quot;当前状态&quot;]) 
    Constrain[(&quot;约束&quot;)]
    Outter[(&quot;外力&quot;)]
    NextWoConstrain([&quot;不考虑约束的下一时刻状态&quot;]) 
    Next([&quot;下一时刻状态&quot;])

    Outter &amp; Current --&gt; 显式积分 --&gt; NextWoConstrain
    Constrain &amp; NextWoConstrain --&gt; 基于投影函数的顶点位置更新 --&gt; 速度更新--&gt;Next --&gt; Current
</pre>
<h2 id="基于投影函数projection-function的顶点位置更新"><a class="header" href="#基于投影函数projection-function的顶点位置更新">基于投影函数（Projection Function）的顶点位置更新</a></h2>
<p>$$
\mathbf{x} ^{\mathbf{new} } \longleftarrow \mathrm{Projection} (\mathbf{x} )
$$</p>
<p>下面以长度约束为例，但该方法同样适用于其他约束类型，包括三角形约束、体积约束与碰撞约束，实现这些约束仅需定义其对应的投影函数即可。</p>
<p>P5</p>
<h3 id="a-single-长度约束"><a class="header" href="#a-single-长度约束">A Single 长度约束</a></h3>
<p><img src="Elastic/../assets/06-1.png" alt="" /></p>
<p>根据长度约束定义投影函数：</p>
<p>$$
\mathbf{ϕ} (\mathbf{x} )=||\mathbf{x} _i− \mathbf{x} _j||−L=0
$$</p>
<p><img src="Elastic/../assets/06-2.png" alt="" /></p>
<p>P6</p>
<blockquote>
<p>✅ 把\(\mathbf{x}_ i\)和\(\mathbf{x}_ j\)拼成6维空间中的点\(\mathbf{x}\)，满足约束的\(\mathbf{x}\)构成6D空间中的一块区域；<br />
✅ 投影函数的目标：(1)把\(\mathbf{x}\)移到区域内。 (2)移动距离最短。</p>
</blockquote>
<p><img src="Elastic/../assets/06-3.png" alt="" /></p>
<blockquote>
<p>x为不满足约束点的，边界为约束，绿点为投影后满足约束的点</p>
</blockquote>
<p>因此构成优化问题：</p>
<p>$$
{\mathbf{x} _i^{\mathbf{new}},\mathbf{x} _j^{\mathbf{new} }}= \argmin  \frac{1}{2}{m_i||\mathbf{x} _i^{\mathbf{new} }−\mathbf{x} _i||^2+m_j||\mathbf{x} _j^{\mathbf{new}} −\mathbf{x} _j||^2}<br />
$$</p>
<p>such that  \(\mathbf{ϕ} (\mathbf{x} )=0\)</p>
<blockquote>
<p>✅优化问题，但不是通过迭代解决，而是数值求解，直接算出最优的\(\mathbf{x}_i\)和\(\mathbf{x}_j\).</p>
</blockquote>
<p>解得：</p>
<p>$$
\mathbf{x} ^{\mathbf{new} } \longleftarrow  \mathrm{Projection} (\mathbf{x})
$$</p>
<p>$$
\mathbf{x} _i^{\mathbf{new} }\longleftarrow \mathbf{x} _i−\frac{m_j}{m_i+m_j} (||\mathbf{x} _i−\mathbf{x} _j||−L)\frac{\mathbf{x} _i−\mathbf{x}_j}{||\mathbf{x} _i−\mathbf{x} _j||} 
$$</p>
<p>$$
\mathbf{x} _j^{\mathbf{new} }\longleftarrow \mathbf{x} _j+\frac{m_i}{m_i+m_j} (||\mathbf{x} _i−\mathbf{x} _j||−L)\frac{\mathbf{x} _i−\mathbf{x}_j}{||\mathbf{x} _i−\mathbf{x} _j||} 
$$</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{ϕ} (\mathbf{x} ^{\mathbf{new} })=||\mathbf{x} _i^{\mathbf{new} }− \mathbf{x} _j^{\mathrm{new} }||−L=||\mathbf{x} _i−\mathbf{x} _j−\mathbf{x} _i+\mathbf{x} _j+L||−L=0
$$</p>
<blockquote>
<p>✅ 对推导结果的合理性解释：(1) 移到前后质心不变。(2) 移到方向为沿着或远离质心。(3) 移到距离与自身重量有关。</p>
</blockquote>
<blockquote>
<p>✅ 对于固定点，将质量设置为无限大，且不做速度和位置的更新。</p>
</blockquote>
<p>P8</p>
<h3 id="multiple-约束--a-gauss-seidel-approach"><a class="header" href="#multiple-约束--a-gauss-seidel-approach">Multiple 约束 – A Gauss-Seidel Approach</a></h3>
<p>一次只针对一个约束作的投影，因此是局部优化方法。</p>
<p>对于多个弹簧的情况呢？Gauss-Seidel解法会按特定顺序依次处理每个弹簧的投影。假设存在两个单位原长的弹簧……</p>
<p><img src="Elastic/../assets/06-4.png" alt="" /></p>
<p>P9</p>
<p><img src="Elastic/../assets/06-22.png" alt="" /></p>
<ul>
<li>无法保证所有约束条件都能被完全满足，但迭代次数越多，约束条件的满足度就越高。</li>
<li>处理顺序会影响结果：顺序可能导致偏差，并影响收敛表现。</li>
</ul>
<p>P10</p>
<h3 id="multiple-约束--a-jacobi-approach"><a class="header" href="#multiple-约束--a-jacobi-approach">Multiple 约束 – A Jacobi Approach</a></h3>
<p>为消除偏差，雅可比法会<strong>同步</strong>计算所有边的投影，再线性融合结果。</p>
<p><img src="Elastic/../assets/06-23.png" alt="" /></p>
<ul>
<li>
<p>存在收敛速度更慢的问题。</p>
</li>
<li>
<p>迭代次数越多，约束条件满足度越高。</p>
</li>
</ul>
<h2 id="速度更新"><a class="header" href="#速度更新">速度更新</a></h2>
<p>$$
\mathbf{v}\longleftarrow \mathbf{v} +(\mathbf{x} ^{\mathbf{new} }−\mathbf{x})/∆t
$$</p>
<blockquote>
<p>✅\(\mathbf{v}\)的更新不是直接覆盖，而是叠加。</p>
</blockquote>
<p>P12</p>
<h1 id="pros-and-cons-of-pbd"><a class="header" href="#pros-and-cons-of-pbd">Pros and Cons of PBD</a></h1>
<h2 id="优势"><a class="header" href="#优势">优势</a></h2>
<ul>
<li>可在GPU上并行计算（如PhysX框架）</li>
<li>实现难度低</li>
<li>在低分辨率场景下运行速度快</li>
</ul>
<blockquote>
<p>✅ 一般来说，少于1000个点时能实时，多于1000个点时效率明显下降<br />
✅ PBD 适用于低分辨率场景、常见的低精度实时模拟的套路。<br />
❗ 模拟真正的时间开销不在计算 (虽然有很多计算公式) 而是在内存的访问上。<br />
PBD 的优点是内存访问少、因为它没有太多物理变量。<br />
因此，<strong>对追求效率的场景，主要优化内存访问而不是计算。</strong></p>
</blockquote>
<ul>
<li>通用性强，能处理多种耦合效应及约束条件（包括流体模拟）</li>
</ul>
<h2 id="劣势"><a class="header" href="#劣势">劣势</a></h2>
<ul>
<li>物理准确性不足</li>
</ul>
<blockquote>
<p>✅ 弹性表现受网格数量影响(迭代数多则弹性差、网格顶点少则弹性差。)
没有所谓的精确解(难以控制)
迭代数过多会导致locking issue.</p>
</blockquote>
<ul>
<li>高分辨率场景下性能较差
<ul>
<li>分层处理方法（可能引发振荡等问题）</li>
<li>加速方案，如切比雪夫加速法</li>
</ul>
</li>
</ul>
<p>P13</p>
<h2 id="after-class-reading-3"><a class="header" href="#after-class-reading-3">After-Class Reading</a></h2>
<p>Muller. 2008. <em>Hierarchical Position Based Dynamics</em>. VRIPHYS.</p>
<blockquote>
<p>✅ NVIDIA的很多物理引擎都是基于PBD的</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P22</p>
<h1 id="投影动力学-projective-dynamics"><a class="header" href="#投影动力学-projective-dynamics">投影动力学 (Projective Dynamics)</a></h1>
<h2 id="原理-1"><a class="header" href="#原理-1">原理</a></h2>
<h3 id="pd-vs-弹簧系统"><a class="header" href="#pd-vs-弹簧系统">PD VS. 弹簧系统</a></h3>
<p>PD由基于隐式积分弹簧系统演化而来，其基本流程是一致的。</p>
<pre class="mermaid">---
title: Projective Dynamics 
---
flowchart LR
    Current([&quot;当前状态&quot;]) 
    Constrain[(&quot;约束&quot;)]
    Outter[(&quot;外力&quot;)]
    Energy([&quot;势能能量&quot;]) 
    Mometen([&quot;动能能量&quot;]) 
    Target([&quot;优化目标&quot;])
    Velocity([&quot;速度&quot;]) 
    Next([&quot;下一时刻状态&quot;]) 
    NextWoContrain([&quot;不考虑约束的下一时刻状态&quot;])

    Outter --&gt; Velocity
    Velocity &amp; Current --&gt; NextWoContrain --&gt; Mometen
    Constrain--&gt;Energy 
    Energy &amp; Mometen --&gt; Target --&gt; Optimize --&gt; Next
</pre>
<p>PD 与弹簧系统的区别在于，弹簧系统与PD计算能量的方式不同。弹簧系统使用弹簧的弹性势能计算能量，而PD使用约束计算能量。能量定义的不同也导致了解优化问题的方法不同。</p>
<h3 id="pd-vs-pbd"><a class="header" href="#pd-vs-pbd">PD VS. PBD</a></h3>
<blockquote>
<p>✅ PBD方法直接拿约束来修复顶点位置，没有物理含义。而Projective Dynatics把projection方法跟物拟模拟结合起来。<br />
✅ Projective Dynamics与PBD的差别主要体现在用约束来做什么。</p>
</blockquote>
<p>Projective Dynamics<strong>将约束转化为能量</strong>，通过最小化能量函数来求解系统的状态。因此是一种基于优化的物理仿真方法</p>
<h2 id="优化目标"><a class="header" href="#优化目标">优化目标</a></h2>
<p>用隐式积分做弹簧系统，最终会转化为优化问题：</p>
<p>$$
\Psi(\mathbf{x}) = \frac{1}{2∆t^2}||\mathbf{x} −\mathbf{y}||_\mathbf{M}^2+E(\mathbf{x} )
$$</p>
<p>其中y为显式积分的结果，E(x)为系统的势能。</p>
<p>目标是优化\(\Psi\)：</p>
<p>$$
x = \argmin \Psi(x)
$$</p>
<p>在弹簧系统中，这样定义E(x)</p>
<p><img src="Elastic/../assets/06-10.png" alt="" /></p>
<p>$$
E(x) = \sum _ {e=(i,j)}E _ e= \frac{1}{2} k\sum _ {e=(i,j)} (||\mathbf{x} _ {i} − \mathbf{x} _ {j} ||−L _ e)^2
$$</p>
<h2 id="势能能量ex"><a class="header" href="#势能能量ex">势能能量E(x)</a></h2>
<h3 id="1根弹簧2个顶点"><a class="header" href="#1根弹簧2个顶点">1根弹簧，2个顶点</a></h3>
<p>引入变量p为长度为\(L_e\)的向量：</p>
<p>$$
p = \overrightarrow {\mathbf{x} _ {i}'\mathbf{x} _ {j}'}
$$</p>
<p>$$
\begin{aligned}
E(x) &amp;= \frac{1}{2} k(||\mathbf{x} _ {i} −\mathbf{x} _ {j} ||−L _ e)^2 \\
&amp;= \min \frac{1}{2} k(||(\mathbf{x} _ {i} − \mathbf{x} _ {j}) - (\mathbf{x} _{i}' −\mathbf{x} _ {j}') ||)^2\\
&amp;= \min \frac{1}{2} k(||(\mathbf{x} _ {i} −\mathbf{x} _ {j}) - p ||)^2
\end{aligned}
$$</p>
<p>可以解得：</p>
<p>$$
p = \argmin E(x) = L\frac{x _ i-x _ j}{||x _ i-x _ j||}
$$</p>
<p>代入p得：</p>
<p>$$
\begin{aligned}
E(x) &amp;= \frac{1}{2} k(||(\mathbf{x} _ {i} −\mathbf{x} _ {j}) - p ||)^2 \\
&amp;= \frac{1}{2} k ( || \underbrace{\begin{bmatrix} I &amp; -I \end{bmatrix}} _ {3 \times 6} \underbrace{\begin{bmatrix} x _ i \\ x _ j \end{bmatrix}} _ {6 \times 1} - \underbrace{p} _ {3\times 1}||^2)
\end{aligned}
$$</p>
<p>根据牛顿法，需要根据E(x)的一阶导和二阶导来计算x的更新方向：</p>
<p>$$
\begin{aligned}
\nabla E &amp;= k \begin{bmatrix} I \\ -I \end{bmatrix} (\begin{bmatrix} I &amp; -I \end{bmatrix} \begin{bmatrix} x_i \\  x_ j \end{bmatrix} - p) &amp;&amp; \nabla E \in R^{6\times1}\\
H &amp;= k \begin{bmatrix} I \\ -I \end{bmatrix} \begin{bmatrix} I &amp; -I \end{bmatrix} = k \begin{bmatrix} I &amp; -I \\ -I &amp; I \end{bmatrix} &amp;&amp; H \in R^{6\times6}
\end{aligned}
$$</p>
<h3 id="n根弹簧m个顶点"><a class="header" href="#n根弹簧m个顶点">n根弹簧，m个顶点</a></h3>
<p>引入变量p，其中\(p_ e\)为长度为\(L_ e\)的向量：</p>
<p>$$
p_{e=(i,j)} = \overrightarrow {\mathbf{x} _ {i}'\mathbf{x} _ {j}'}
$$</p>
<p>$$
\begin{aligned}
E(x) &amp;= \frac{1}{2} k \sum _ {e=(i,j)}(||\mathbf{x} _ {i} −\mathbf{x} _ {j} ||−L _ e)^2 \\
&amp;= \min \frac{1}{2} k\sum _ {e=(i,j)}(||(\mathbf{x} _ {i} −\mathbf{x} _ {j}) - (\mathbf{x} _ {i}' −\mathbf{x} _ {j}') ||)^2\
&amp;= \min \frac{1}{2} k\sum _ {e=(i,j)}(||(\mathbf{x} _ {i} −\mathbf{x} _ {j}) - p_ e ||)^2
\end{aligned}
$$</p>
<p>可以解得：</p>
<p>$$
p _ e = \argmin E _ {e=(i,j)}(x) = L\frac{x _ i-x _ j}{||x _ i-x _ j||}
$$</p>
<p>代入p得：</p>
<p>$$
\begin{aligned}
E(x) &amp;= \frac{1}{2} k\sum _ {e=(i,j)}(||(\mathbf{x} _ {i} −\mathbf{x}_{j}) - p _ e ||)^2 \\
&amp;= \frac{1}{2} k ( || \underbrace{A} _ {3n \times 3m} \underbrace{\mathbf{x}} _ {3m \times 1} - \underbrace{P} _ {3n\times 1}||^2)
\end{aligned}
$$</p>
<p>其中，A是由弹簧连接关系构成的矩阵，只要弹簧结构不发生变化，整个仿真过程中A保持炒变。</p>
<p>根据牛顿法，需要根据 \(E(x)\) 的一阶导和二阶导来计算 \(x\) 的更新方向：</p>
<p>$$
\begin{aligned}
\nabla E &amp;= k A^T (A \mathbf{x} - P) &amp;&amp; \nabla E \in R^{3m\times1}\\
H &amp;= k A^TA &amp;&amp; H \in R^{3m\times3m}
\end{aligned}
$$</p>
<h2 id="说明"><a class="header" href="#说明">说明</a></h2>
<h3 id="引入的变化p是形变后的e的投影"><a class="header" href="#引入的变化p是形变后的e的投影">引入的变化p是形变后的e的投影</a></h3>
<p>$$
(\mathbf{x} _ {e,i}^{\mathrm{new} },\mathbf{x} _ {e,j}^{\mathrm{new} }) = \mathrm{Projection} _ e(\mathbf{x} _ i,\mathbf{x} _ j)
$$</p>
<blockquote>
<p>✅ 本文基于约束定义能量。{\(\mathbf{x} _{e,i}^{\mathrm{new} },\mathbf{x} _ {e,j}^{\mathrm{new} }\)}为期望的顶点位置\(P\)。不直接把顶点从当前位置移到期望位置。而是把当前位置和期望位置的距离转化为能量，通过能量推动顶点从当前位置移到目标位置。</p>
</blockquote>
<p>因此称为投影动力学</p>
<h3 id="这个能量与弹簧能量有什么区别"><a class="header" href="#这个能量与弹簧能量有什么区别">这个能量与弹簧能量有什么区别</a></h3>
<p>$$
E(\mathbf{x})=\sum _ {e=(i,j)}\frac{k}{2}(||\mathbf{x} _  i-\mathbf{x} _ j||-L _ e)^2 
$$</p>
<p>$$
\mathbf{f} _ i=−\nabla_iE(\mathbf{x} )=−{\textstyle \sum _{e:i\in e}}(\mathbf{x} _ i−\mathbf{x} _ j)−(\mathbf{x} _ {e,i}^{\mathrm{new}} −\mathbf{x} _ {e,j}^{\mathrm{new} })
$$</p>
<blockquote>
<p>弹簧系统和\(PD\)都是基于当前状态\((x_i、x_j)\)和投影状态\((p)\)来计算能量，且所使用的公式都是基于胡克定理，看上去没有区别。<br />
区别在于\(p\)。\(p\)是由\(x\)投影得到的，但\(PD\)在优化的过程中假设\(p\)是一个定值，即\(f\)与\(H\)都与\(p\)无关，这就简化了后面的优化步骤。</p>
</blockquote>
<p>P23</p>
<p><img src="Elastic/../assets/06-11.png" alt="" /></p>
<p><img src="Elastic/../assets/06-12.png" alt="" /></p>
<blockquote>
<p>✅ 同一个顶点在三个不同边上的投影是不同的。<br />
✅ <strong>可以直接根据Mesh的拓扑关系构造H矩阵。</strong><br />
✅ 为什么能简化\(\mathbf{H}\)的计算？答：在计算某一个端点时，假设另一个端点不动（常量），那么能量就是只关于这个端点的二次函数</p>
</blockquote>
<h3 id="pd-的优势"><a class="header" href="#pd-的优势">\(PD\) 的优势</a></h3>
<p>以这种方式定义能量，得到的H是一个只与弹簧拓扑有关的定值。这个定值不光构造简单，也能简化计算。</p>
<p>在以牛顿法的优化迭代方法中，需要解线性系统\(Ax=b\)。复杂的A使得线性系统难以求解。</p>
<blockquote>
<p>✅ 解线性系统的主要耗时在LU分解，而这个算法中\(\mathrm{H}\)是常数矩阵，只需要做一次LU分解，简化了对\(\mathrm{H}\)分解的计算量。 </p>
</blockquote>
<p><img src="Elastic/../assets/05-18.png" alt="" /></p>
<p>由A的定义可知，当H是定值时，A也是一个定值。那么可以对A做一些预计算，以加速线性系统\(Ax=b\)的求解。</p>
<blockquote>
<p>如果只是使用了\(PD\)的方法来构造能量和\(H\)，但没有对\(A\)做预计算，实际上没有发挥\(PD\)的核心优势。<br />
\(PD\) 的优势来源于此，局限性也来源于此。如果一个约束不能简化出这种简单的 \(H\)，就不能使用\(PD\)来做。</p>
</blockquote>
<p>P28</p>
<h2 id="after-class-reading-4"><a class="header" href="#after-class-reading-4">After-Class Reading</a></h2>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2014</td><td>Projective Dynamics: Fusing Constraint Projections for Fast Simulation</td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P39</p>
<h1 id="shape-matching"><a class="header" href="#shape-matching">Shape Matching</a></h1>
<p>先让每个粒子独立仿真，也不需要考虑弹簧力。<br />
将每个面片的变形程度构建为能量，通过优化能量的方式使 Mesh 减少形变，所有面片以统一的方式进行优化，因此是一种全局优化方法。</p>
<p>所有方法最后都归结为一个分式：</p>
<p>$$
\psi(x)=k||x-y||_m^2+E(x)
$$</p>
<p>关键是如何定义，以及非线性方程如何求解</p>
<p>P40</p>
<h2 id="量化形变"><a class="header" href="#量化形变">量化形变</a></h2>
<p>The basic idea is to define a quadratic energy based on the rotated reference element. To do so, we split transformation into deformation + rotation.</p>
<p><img src="Elastic/./assets/05-26.png" alt="" /></p>
<p>P41</p>
<p><img src="Elastic/./assets/05-27.png" alt="" /></p>
<p>P42</p>
<h2 id="计算能量"><a class="header" href="#计算能量">计算能量</a></h2>
<p>We can then define the quadratic energy as:</p>
<p>$$
E (\mathbf{x} )=\frac{1}{2}||\mathbf{F−R} ||^2
$$</p>
<p>(\(\mathbf{R}\) is the rotation inside of \(\mathbf{F}\).  This energy tries to penalize the existence of \(\mathbf{S}\)).</p>
<p>Assuming that \(\mathbf{R}\) is constant, this \(E(\mathbf{x})\) becomes a quadratic function.  We can then derive the force and the Hessian.</p>
<p>$$
E(\mathbf{x} ) =\frac{1}{2} ||\begin{bmatrix}
\mathbf{x} _1-\mathbf{x} _0 &amp;\mathbf{x} _2-\mathbf{x} _0
\end{bmatrix}\begin{bmatrix}
\mathbf{r} _1-\mathbf{r} _0 &amp;\mathbf{r} _2-\mathbf{r} _0
\end{bmatrix}^{−1}−\mathbf{R}||^2
$$</p>
<p>P24</p>
<h2 id="shape-matching-1"><a class="header" href="#shape-matching-1">Shape Matching</a></h2>
<p>这是用 \(PD\) 来优化优化问题的另一个例子。原 \(PD\) 算法用于长度保持约束，而这里把它用于形状保持约束。</p>
<p>Shape matching is also projective dynamics, if we view rotation as projection:</p>
<p><img src="Elastic/../assets/06-15.png" alt="" /></p>
<table><thead><tr><th><strong>The 2D Space</strong></th><th><strong>The 3D Space</strong></th></tr></thead><tbody>
<tr><td><img src="Elastic/../assets/06-013.png" alt="" /></td><td><img src="Elastic/../assets/06-014.png" alt="" /></td></tr>
</tbody></table>
<p>Assuming that \(\mathbf{{\color{Orange} R} }\) is constant,<br />
$$
\begin{matrix}
\mathbf{f} _0=−\nabla_0E(\mathbf{x} )\\
\mathbf{f} _1=−\nabla_1E(\mathbf{x} ) \\
\mathbf{f} _2=−\nabla_2E(\mathbf{x} )\\
\mathbf{H} =\frac{∂E^2(\mathbf{x} )}{∂x^2} \quad \text{is  a constant !}<br />
\end{matrix}
$$</p>
<p>P25</p>
<h2 id="simulation-by-projective-dynamics"><a class="header" href="#simulation-by-projective-dynamics">Simulation by Projective Dynamics</a></h2>
<ul>
<li>
<p>According to implicit integration and Newton’s method, a projective dynamics simulator looks as follows, with matrix \(\mathbf{A} =\frac{1}{∆t^2}\mathbf{M+}\mathbf{H} \) being constant.</p>
</li>
<li>
<p>We can use a direct solver with <strong>only one factorization of A</strong>.</p>
</li>
</ul>
<h2 id="pipeline"><a class="header" href="#pipeline">Pipeline</a></h2>
<p>Initialize  \(\mathbf{x} ^{(0)}\), often as\( \mathbf{x} ^{[0]} \)or \(\mathbf{x} ^{[0]} +∆t\mathbf{v} ^{[0]} \)</p>
<p>For \(k=0\dots K\)<br />
\(\quad\) Recalculate projection</p>
<p>\(\quad\) Solve \((\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} )∆\mathbf{x} =−\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})\)</p>
<p>\(\quad\) \(\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} \)</p>
<p>\(\quad\) If \(||∆\mathbf{x}||\) is small	\(\quad\) then break</p>
<p>\(\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
<p>\(\mathbf{v} ^{[1]}\longleftarrow (\mathbf{x} ^{[1]}-\mathbf{x} ^{[0]})/∆t\)</p>
<p>P27</p>
<h2 id="pros-and-cons-of-projective-dynamics"><a class="header" href="#pros-and-cons-of-projective-dynamics">Pros and Cons of Projective Dynamics</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>By building constraints into energy, the simulation now has a theoretical <u>solution</u> with <strong>physical</strong> meaning.</li>
<li><strong>Fast on CPUs</strong> with a direct solver. No more factorization!</li>
</ul>
<blockquote>
<p>✅ Fast on CPU,因为它只作一次\(\mathbf{LU}\)分解。</p>
</blockquote>
<ul>
<li>Fast convergence in the first few iterations.</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li><strong>Slow on GPUs</strong>. (GPUs don’t support direct solver wells.)</li>
</ul>
<blockquote>
<p>✅ Slow on GPU，因为\(\mathbf{LU}\)分解不适用于 \(\mathbf{GPU}\)</p>
</blockquote>
<ul>
<li>Slow convergence over time, as it fails to consider Hessian caused by projection.
<ul>
<li>Still suffering from high stiffness</li>
</ul>
</li>
<li>Cannot easily handle <strong>constraint changes</strong>.
<ul>
<li>Contacts</li>
<li>Remeshing due to fracture, etc.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ constraint changes: 网格关系改变导至弹簧结构改变，原来的\(\mathbf{H}\)将不再适用。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/ </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P14</p>
<h1 id="strain-limiting"><a class="header" href="#strain-limiting">Strain Limiting</a></h1>
<p>PBD 是一个让仿真结果变得满足约束的方法，可以认为是仿真的后处理。由此产生了其它的用法。</p>
<h2 id="原理-2"><a class="header" href="#原理-2">原理</a></h2>
<p>Strain limiting aims at using the projection function for <strong>correction</strong> only. </p>
<p><img src="./assets/06-5.png" alt="" /></p>
<blockquote>
<p>✅ 投影函数作为模拟过程的后处理，防止模拟后产生大的形变，使模拟结果更稳定。</p>
</blockquote>
<table><thead><tr><th></th><th>PBD</th><th>Strain Limiting</th></tr></thead><tbody>
<tr><td>第一步</td><td>只考虑粒子运动，不考虑约束</td><td>模拟粒子运动、同时考虑约束</td></tr>
<tr><td>第二步</td><td>使粒子状态满足约束</td><td>校正，但约束较宽</td></tr>
</tbody></table>
<p>P15</p>
<h2 id="例一-spring-strain-limit"><a class="header" href="#例一-spring-strain-limit">例一： Spring Strain Limit</a></h2>
<p>We can set the spring strain, i.e., the stretching ratio σ, to be within a limit.</p>
<blockquote>
<p>✅ 这一页以弹簧为例子说明 Strain Limit<br />
✅ Strain：物理上描述形变的量，即本页的\(\sigma \)</p>
</blockquote>
<p><img src="./assets/06-6.png" alt="" /></p>
<p>$$
\sigma ^\mathrm{{min}}≤\frac{1}{L}||\mathbf{x} _i− \mathbf{x} _j||≤\sigma^\mathrm{{max}}
$$</p>
<blockquote>
<p>✅ 仅要求弹簧长度满足某不比例，不要求一定到达某个位置。</p>
</blockquote>
<p>Constraint</p>
<p><img src="./assets/06-7.png" alt="" /></p>
<p>P16</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{x}^{\mathbf{new}}\longleftarrow \mathrm{Projection}  (\mathbf{x} )
$$</p>
<p>$$
\sigma\longleftarrow \frac{1}{L}||\mathbf{x}_i− \mathbf{x}_j||
$$</p>
<blockquote>
<p>✅ 计算当前拉伸比</p>
</blockquote>
<p>$$
\sigma _0\longleftarrow \mathrm{min} (\mathrm{max} (\sigma,\sigma^{\mathrm{min} }),\sigma^{\mathrm{max} })
$$</p>
<blockquote>
<p>✅ 计算期望的拉伸比</p>
</blockquote>
<p>$$
\mathbf{x} _i^{\mathrm {new} }⟵\mathbf{x} _i−\frac{m_j}{m_i+m_j}(||\mathbf{x} _i− \mathbf{x} _j||−σ_0L)\frac{\mathbf{x} _i− \mathbf{x} _j}{||\mathbf{x} _i− \mathbf{x} _j||}
$$</p>
<p>$$
\mathbf{x} _j^{\mathrm {new} }⟵\mathbf{x} _j+\frac{m_j}{m_i+m_j}(||\mathbf{x} _i− \mathbf{x} _j||−σ_0L)\frac{\mathbf{x} _i− \mathbf{x} _j}{||\mathbf{x} _i− \mathbf{x} _j||}
$$</p>
<blockquote>
<p>✅ 用\(\sigma _0L\)代替原长\(L\)．</p>
</blockquote>
<p>\(\mathrm{PBD}: \sigma _0≡1;\quad\quad\)</p>
<blockquote>
<p>✅ PBD可以看作是Strain Limit的特例。</p>
</blockquote>
<p>No limit: \(\sigma ^{\mathrm{min} } = 0, σ^{\mathrm{max} } = \infty\)</p>
<blockquote>
<p>✅ Strain Limit 的应用场景：(1) 模拟布料：“拉伸到一定范围后变得非常 stiff” 的效果 (2) 防止“形变大发生数值不稳定”。</p>
</blockquote>
<p>P17</p>
<h2 id="例二triangle-area-limit"><a class="header" href="#例二triangle-area-limit">例二：Triangle Area Limit</a></h2>
<p>We can limit the triangle area as well. To do so, we define a scaling factor.</p>
<blockquote>
<p>✅这是另一个例子。希望顶点移动尽量少，因此定义约束：三角形面积变化在一定范围内。</p>
</blockquote>
<p>{\(\mathbf{x}_i^{\mathrm{new} },\mathbf{x}_i^{\mathrm{new} },\mathbf{x}_k^{\mathrm{new} }\)}  = \(\mathrm{argmin} \frac{1}{2} \){\(m_i||\mathbf{x}_i^{\mathrm{new} }−\mathbf{x}_i||^2+m_j||\mathbf{x}_j^{\mathrm{new} }−\mathbf{x}_j||^2+m_j||\mathbf{x}_k^{\mathrm{new} }−\mathbf{x}_k||^2\)} </p>
<p>such that the constraint is satisfied.</p>
<p><img src="./assets/06-8.png" alt="" /></p>
<blockquote>
<p>✅ strain s为面积的缩放量</p>
</blockquote>
<p>P18</p>
<p>$$
\quad
$$</p>
<p>$$
\mathbf{x} ^{\mathbf{new}} ⟵\mathrm{Projection} (\mathbf{x} )
$$</p>
<p>$$
\mathbf{A}\longleftarrow \frac{1}{2} ||(\mathbf{x} _j− \mathbf{x} _i)\mathbf{×} (\mathbf{x}_k− \mathbf{x} _i)||
$$</p>
<blockquote>
<p>✅ 计算当前三角形的面积</p>
</blockquote>
<p>$$
\mathbf{s} \longleftarrow \sqrt{\mathrm{\mathrm{min}} (\mathrm{\mathrm{max}} (A,A^{\mathrm{min}}),A^{\mathrm{max}})/A}
$$</p>
<blockquote>
<p>✅ 计算期望的面积缩放比</p>
</blockquote>
<p>$$
\mathbf{c} \longleftarrow \frac{1}{m_i+m_j+m_k} (m_i\mathbf{x} _i+m_j\mathbf{x} _j+m_k\mathbf{x} _k)
$$</p>
<blockquote>
<p>✅ C为质心，要求缩放前后质心不变。数学上、质心不变，点的移动最少；物理上，质心变了代表物体运动了，scale 不应该导致物理运动。</p>
</blockquote>
<p>$$
\mathbf{x} _i^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _i−\mathbf{c} )
$$</p>
<p>$$
\mathbf{x} _j^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _j−\mathbf{c} )
$$</p>
<p>$$
\mathbf{x} _k^{\mathrm{new}}\longleftarrow \mathbf{c} +s(\mathbf{x} _k−\mathbf{c} )
$$</p>
<blockquote>
<p>✅ 通过对顶点到质心的距离的缩放，得到顶点的新的位置</p>
</blockquote>
<p>P19</p>
<h2 id="strain-limiting在simulation中的作用"><a class="header" href="#strain-limiting在simulation中的作用">Strain Limiting在Simulation中的作用</a></h2>
<ul>
<li>
<p>Strain limiting is widely used in physics- based simulation, typically for avoiding instability and artifacts due to large deformation.</p>
</li>
<li>
<p>Strain limiting is useful for nonlinear effects, in a biphasic way.</p>
</li>
</ul>
<p><img src="./assets/06-9.png" alt="" /></p>
<blockquote>
<p>✅ 例如布料一般一开始抵抗比较小，拉到一定程度后抵抗迅速变大。对这种非线性的表现，可以把模拟分布两个阶段，前面用普通模拟，后面用strain limiting。</p>
</blockquote>
<ul>
<li>Strain limiting also helps address the <strong>locking issue</strong>.</li>
</ul>
<blockquote>
<p>✅两个阶段有不同的算法，针对两个阶段的不同特点，可以分别解决两个阶段的问题。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P37</p>
<h1 id="a-summary-for-the-day-2"><a class="header" href="#a-summary-for-the-day-2">A Summary For the Day</a></h1>
<ul>
<li>
<p><strong>基于位置的动力学与应变限制法</strong></p>
<ul>
<li>关键在于为每个约束建立投影函数。</li>
<li>两种积分方法：雅可比法与高斯-赛德尔法。</li>
<li>低分辨率下运行快，但高分辨率下存在局限。</li>
<li>物理准确性不足。</li>
</ul>
</li>
<li>
<p><strong>投影动力学</strong></p>
<ul>
<li>同样使用投影函数，但将其嵌入能量函数中构建。</li>
<li>每次迭代先更新投影量，再将其视为隐式公式中的常数处理。</li>
<li>系统矩阵恒定，可预先分解以实现快速模拟。</li>
<li>前几次迭代收敛快，后续速度下降，适合CPU计算。</li>
</ul>
</li>
<li>
<p><strong>约束动力学</strong></p>
<ul>
<li>专注于极刚性约束，引入对偶变量。</li>
<li>同样基于隐式积分，采用两种方法：原对偶法与纯对偶法。</li>
<li>对求解器有限制要求。</li>
</ul>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="骨络"><a class="header" href="#骨络">骨络</a></h1>
<p>骨络结构包含点和线，每个点都可以自由移动和旋转。(Mesh 上的顶点不能旋转。) 如果顶点之间存在边，那么顶点间的相对位置关系不能发生改变。</p>
<blockquote>
<p>✅ Skeleton 用于衣服、刚体、人体等对象的仿真代理。比如人体的关节联结，是一种非常stiff的约束。</p>
</blockquote>
<p>P30</p>
<h1 id="xpbd"><a class="header" href="#xpbd">XPBD</a></h1>
<h2 id="要解决的问题"><a class="header" href="#要解决的问题">要解决的问题</a></h2>
<p>\(PBD\) 的问题在于缺少物理性，硬度不可控，究其原因是，\(PBD\) 本质是把无限强的硬约束作为优化目标，在多轮的迭代优化中不断向这个目标靠近，但如果要真正收敛到这个目标需要很多次迭代，实际上会在目标收敛之前结束迭代。表现为 soft 的效果，所以软体的 stiff 程度取于迭代优化的收敛情况，因此不可控。</p>
<blockquote>
<p>✅ 此算法是 PD 的扩展。用于处理 very very stiff 的场景，即距离约束必须严格满足。而前面算法需要做很多次迭代才能产生这种效果（计算量大）。</p>
</blockquote>
<p>XPBD 试图通过软度系数 C 来控制物体的 stiff / soft 程度，XPBD 通过 C 定义势能的 scale，使得优化目标为动能与势能的 trade off。 当优化目标收敛时，达到期望的硬度，但如果在收敛前停止迭代，仍然会表现出比预期要软的效果。</p>
<h2 id="根据约束建立模型"><a class="header" href="#根据约束建立模型">根据约束建立模型</a></h2>
<p><img src="Elastic/../assets/06-17.png" alt="" /></p>
<p>回顾隐式积分的优化目标：</p>
<p>$$
\psi (x) = \frac{1}{2h^2}||x - y||_M^2 + E(x)
$$</p>
<p>其中第一项为动能，第二项为势能。</p>
<p>\(y\) 为 \(x\) 在不考虑内力情况下下一时刻应该到达的位置，当\(x=y\) 时动能为0。</p>
<p>根据约束来定义势能 \(E(x)\)，其中 \(\phi (x)\) 为约束，\(C\) 为柔度参数。</p>
<p>Compliant constraint</p>
<p>$$
\mathbf{ϕ} _e(\mathbf{x} )=||\mathbf{x} _{ei}− \mathbf{x} _{ej}||−L_e
$$</p>
<p>这个 \(\phi (x)\) 只是约束的一种定义方式，也可以是其他的定义。</p>
<p>$$
E(\mathbf{x} )={\textstyle \sum_e}\frac{1}{2} k(||\mathbf{x} _{ei} −\mathbf{x} _{ej}||−L_e)^2=\frac{1}{2} \mathbf{\mathbf{ϕ}^T(x)C} ^{−1}\mathbf{ϕ} (\mathbf{x} )
$$</p>
<p>$$
\mathbf{f} (\mathbf{x} )=−∇E=-\begin{pmatrix}
\frac{∂E}{∂\mathbf{ϕ}}  &amp; \frac{∂\mathbf{ϕ}}{∂x}
\end{pmatrix}^\mathbf{T} =−\mathbf{J^TC} ^{−1}\mathbf{ϕ} =\mathbf{J^Tλ} 
$$</p>
<p>Let \(N\) be the number of vertices and E be the number of constraints,</p>
<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>约束</td><td>$$ \phi (\mathbf{x} )\in \mathbf{R} ^E $$</td><td>✅ \( \phi_e = \begin{bmatrix} \phi _ 0\\ \phi _ 1 \\ \vdots  \\ \phi _ E  \end{bmatrix}\)</td></tr>
<tr><td>Compliant matrix</td><td>$$ \mathbf{C} =\begin{bmatrix} 1/k &amp; \Box  &amp; \Box\\ \Box &amp; 1/k &amp; \Box \\ \Box  &amp; \Box &amp;\ddots \end{bmatrix}\in \mathbf{R} ^{E×E} $$</td><td>✅ C称为软度矩阵、 stiffness:挺度，compliant:软度</td></tr>
<tr><td>Jacobian</td><td>\(\mathbf{J} =\frac{∂\phi}{∂\mathbf{x} } \in \mathbf{R} ^{E×3N}\)</td><td></td></tr>
<tr><td>Dual variables (Lagrangian multipliers)</td><td>\(\mathbf{λ} =−\mathbf{C} ^{−1}\phi \in \mathbf{R} ^E\)</td><td>✅ \(\lambda \) 是人为引入的变量，称为拉格朗日算子。</td></tr>
</tbody></table>
<p>引入变量 \(\lambda = -C⁻¹\phi \)，代入\(E(x)\)和\(f(x)\)，得</p>
<p>$$
E(x)=\frac{1}{2}\phi ^T (x)\lambda 
\\
f(x)=J^T \lambda<br />
$$</p>
<h2 id="转化为隐式积分问题"><a class="header" href="#转化为隐式积分问题">转化为隐式积分问题</a></h2>
<p>P31</p>
<p>By implicit integration, we get:</p>
<p>$$
v^{[1]} = v^{[0]} + \Delta tM^{-1} f^{[1]}
$$</p>
<p>隐式积分公式推导见弹簧系统部分，也可以写成：</p>
<p>$$
x^{[1]} = x^{[0]} + y + \Delta t^2 M^{-1} f^{[1]}
$$</p>
<p>引出两种不同的推导方法：</p>
<h3 id="用速度公式推导"><a class="header" href="#用速度公式推导">用速度公式推导</a></h3>
<p>$$
\mathbf{Mv} ^{\mathrm{new} }−∆t\mathbf{J^Tλ} ^{\mathrm{new} }=\mathbf{Mv} 
$$</p>
<blockquote>
<p>✅ 动量守衡公式：\(Mv'- Mv = Ft = \)冲量<br />
✅ 此处新 \(\lambda^{\mathrm{new}} \)来计算 F. 说明是 Implicit</p>
</blockquote>
<p>Meanwhile,对\(-\phi ^{\mathrm{new}}\) 的泰勒展开</p>
<p>$$
−\mathbf{ϕ} ^{\mathrm{new} }≈−\mathbf{ϕ} −\mathbf{J} (\mathbf{x} ^{\mathrm{new} }−\mathbf{x} )≈−\mathbf{ϕ} −∆t\mathbf{Jv} ^{\mathrm{new} }
$$</p>
<blockquote>
<p>✅\(J\)是上页中的Jacobian.</p>
</blockquote>
<p>根据定义 \(\lambda^{\mathrm{new} } = C^{-1}\phi^{\mathrm{new} }\)，得：</p>
<p>$$
\lambda^{\mathrm{new} } = -\phi - \Delta t\mathbf{Jv} ^{\mathrm{new} }
$$</p>
<p>构造入方程组，</p>
<p>$$
\begin{bmatrix}
\mathbf{M}  &amp; −∆t\mathbf{J^T} \\
∆t\mathbf{J}  &amp; \mathbf{C} 
\end{bmatrix}\begin{bmatrix}
\mathbf{v} ^{\mathrm{new} } \\
\mathbf{λ} ^{\mathrm{new} }
\end{bmatrix}=\begin{bmatrix}
\mathbf{Mv}  \\
-\mathbf{ϕ} 
\end{bmatrix}
$$</p>
<blockquote>
<p>✅ 最后的矩阵公式由上面两个公式整理合并得到。<br />
✅ \(x ^{\mathrm{new}}-x =\Delta t\cdot v \)</p>
</blockquote>
<h3 id="用位置公式推导"><a class="header" href="#用位置公式推导">用位置公式推导：</a></h3>
<p>$$
M \cdot \Delta x + \Delta t^2 J^{\text{new}} \lambda^{\text{new}} = 0
$$</p>
<p>将 \( J^{\text{new}} \) 近似为 \( J \)，</p>
<p>构造方程组，得：</p>
<p>$$
\begin{bmatrix}
M &amp; \Delta t^2 \cdot J^T \\
J &amp; C
\end{bmatrix}
\begin{bmatrix}
\Delta x \\
\Delta \lambda
\end{bmatrix}
=\begin{bmatrix}
0 \\
-\phi
\end{bmatrix}
$$</p>
<h2 id="解隐式积分"><a class="header" href="#解隐式积分">解隐式积分</a></h2>
<p>P32<br />
Now we have a system with two sets of variables: the primal variable \(\mathbf {x}\) (or \(\mathbf {v=x}\) ̇) and the dual variable \(\mathbf {λ}\).</p>
<blockquote>
<p>✅ 之前的隐式积分只有一个变量，此处的隐式积分有两个变量。需要同时解出两个变量。</p>
</blockquote>
<ul>
<li>Method 1: We can solve the two variables by a <strong>direct solver</strong> together, in a <u>primal-dual</u> fashion:</li>
</ul>
<p>$$
\begin{bmatrix}
\mathbf{M}  &amp; −∆t\mathbf{J^T} \\
∆t\mathbf{J}  &amp; \mathbf{C} 
\end{bmatrix}\begin{bmatrix}
\mathbf{v} ^{\mathrm{new} } \\
\mathbf{λ} ^{\mathrm{new} }
\end{bmatrix} = \begin{bmatrix}
\mathbf{Mv}  \\
-\mathbf{ϕ} 
\end{bmatrix}
$$ </p>
<blockquote>
<p>✅ 注意：Method 1 中的矩阵有可能不正定、因此很多数学方法用不了。 </p>
</blockquote>
<ul>
<li>Method 2: We can <strong>reduce the system</strong> by Schur complement and solve \(\mathbf {λ}^{\mathrm{new} }\) first.</li>
</ul>
<blockquote>
<p>✅ Method 2 的消元过程不容易构造、尤其是当矩阵比较复杂时。</p>
</blockquote>
<p>$$
(∆t^2\mathbf{JM} ^{−1}\mathbf{J} ^\mathbf{T} +\mathbf{C} )\mathbf{λ} ^{\mathrm{new} } =−\mathbf{ϕ} −∆t\mathbf{Jv} 
$$</p>
<p>$$
\mathbf{v} ^{\mathrm{new}}\longleftarrow \mathbf{v} +−∆t\mathbf{M} ^{−1}\mathbf{J^Tλ} ^{\mathrm{new}}
$$</p>
<blockquote>
<p>✅ 用哪种方法取决于应用场景</p>
</blockquote>
<h2 id="优点"><a class="header" href="#优点">优点</a></h2>
<blockquote>
<p>✅ 此方法将软硬度量解耦出来，并用矩阵C来表示，使得可以方便控制软硬度，例如让\(c=0\) 来表示 infinite stiffness.</p>
</blockquote>
<p>当\(c=0\) 时，方法退化为PBD。</p>
<h2 id="应用"><a class="header" href="#应用">应用</a></h2>
<p>Articulated Rigid Bodies (ragdoll animation)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P34</p>
<h1 id="stable-constrained-dynamics"><a class="header" href="#stable-constrained-dynamics">Stable Constrained Dynamics</a></h1>
<blockquote>
<p>✅ 没有展开讲，见after reading中的论文</p>
</blockquote>
<p>From a mass-spring system, we know spring Hessian (tangent stiffness) is:</p>
<p>$$
\mathbf{H} (\mathbf{x} )=∑_{e=(i,j)}\begin{bmatrix}
\Box  &amp; \Box  &amp; \Box  &amp; \Box  \\
\Box  &amp; \mathbf{H} _e &amp; -\mathbf{H} _e &amp; \Box   \\
\Box &amp; -\mathbf{H} _e &amp;\mathbf{H} _e  &amp; \Box   \\
\Box &amp;  \Box &amp; \Box  &amp; \Box<br />
\end{bmatrix}
$$</p>
<p><img src="Elastic/../assets/06-18.png" alt="" /></p>
<p>According to constrained dynamics:\(\mathbf{f} (\mathbf{x} )=\mathbf{J^Tλ}\)  and \(\mathbf{λ} =−\mathbf{C} ^{−1}\mathbf{ϕ} \), so: </p>
<p><img src="Elastic/../assets/06-19.png" alt="" /></p>
<p>$$
\mathbf{J}_e=\frac{∂\phi _e}{∂\mathbf{x} }=\begin{bmatrix}
\frac{\mathbf{x} _{ij}^\mathbf{T} }{||\mathbf{x} _{ij}||}   &amp; -\frac{\mathbf{x} _{ij}^\mathbf{T} }{||\mathbf{x} _{ij}||}
\end{bmatrix}
$$</p>
<p>P35</p>
<h2 id="stable-constrained-dynamics-1"><a class="header" href="#stable-constrained-dynamics-1">Stable Constrained Dynamics</a></h2>
<p>According Lecture 5, Page 16, implicit integration is:</p>
<p>$$
(\frac{1}{∆t^2}\mathbf{M+H} (\mathbf{x} ^{[0]}))∆\mathbf{x} = \frac{1}{∆t^2}\mathbf{M} (∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{[0]})
$$</p>
<p>$$
\Downarrow 
$$</p>
<p>$$
(\mathbf{M} +∆t^2\mathbf{H} (\mathbf{x} ^{[0]}))\mathbf{v} ^{\mathrm{new} }= \mathbf{Mv} ^{[0]}+∆t\mathbf{f} (\mathbf{x} ^{[0]})
$$</p>
<p><img src="Elastic/../assets/06-20.png" alt="" /></p>
<p>Missing geometric stiffness matrix here…</p>
<p>P36</p>
<h2 id="after-class-reading-optional"><a class="header" href="#after-class-reading-optional">After-Class Reading (optional)</a></h2>
<p><img src="Elastic/../assets/06-21.png" alt="" /></p>
<p>Tournier et al. 2015. <em>Stable Constrained Dynamics. TOG (SIGGRAPH)</em>.</p>
<blockquote>
<p>✅ Method 2 Gauss 消元，如果把\(\lambda\)消掉，会得到一个基本上与隐式积分相似的公式，唯一的区别是\(\mathbf{H}\)上略有不同 —— 隐式积分多了一项。如果把用这一项加回去，会使constrain dynamic 变得稳定。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="fem"><a class="header" href="#fem">FEM</a></h1>
<p>Lecture 3 [31:48]</p>
<p>把空间分成极小的 element，例如三角形，四面体。</p>
<p>用 FEM 做仿真仍然是用 \(w = \frac{1}{2h^2} || x - y ||_M^2 + E(x)\) 的思路。<br />
关键在于 \(E(x)\) 的定义方式。<br />
弹簧系统：用弹簧势能来定义\(E(x)\)。<br />
PBD/PD/XPD 用约束来定义 \(E(x)\)。<br />
FEM/FVM 的能量来自材料对形变的响应，所以需要对材料建模，根据材料特性构造 \(E(x)\)。</p>
<p>$$
\text{deformed mesh} \rightarrow \overset{形变}F {\rightarrow} \overset{能量密度}ψ{\rightarrow}\overset{能量}U{\rightarrow}力\rightarrow速度\rightarrow位置<br />
$$</p>
<p>如果采用隐式积分，则通过最小化 \(W\) 解出下一时刻的速度和位置。</p>
<h1 id="linear-finite-element-method"><a class="header" href="#linear-finite-element-method">Linear Finite Element Method</a></h1>
<p>P4</p>
<h2 id="the-linear-fem-assumption"><a class="header" href="#the-linear-fem-assumption">The Linear FEM Assumption</a></h2>
<blockquote>
<p>✅ 假设：三角形的形变是均匀的</p>
</blockquote>
<p>In a nutshell, linear FEM assumes that for any point \(\mathbf{X}\) in the reference triangle, its deformed correspondence is: \(\mathbf{x=FX+c}\).</p>
<blockquote>
<p>✅ reference triangle：三角形处于没有发生形变的静止的状态。<br />
✅ \(\mathbf{X}\)和\(\mathbf{x}\)可以分别是 reference 和 deformed 三角形的顶点或内部点，公式都同样适用。</p>
</blockquote>
<p><img src="./assets/07-01.png" alt="" /></p>
<p>一个向量对另一个向量求导，得到的是 Jacobian 矩阵。由于是均匀形变，在一个三角形内部，\(\mathbf{F}\) 是一致的。</p>
<p>For any vector between two points, we can use F to convert it from reference to deformed:<br />
$$
\mathbf{x} _{ba}=\mathbf{x} _b−\mathbf{x} _a=\mathbf{FX} _b+\mathbf{c} −\mathbf{FX} _a−\mathbf{c} =\mathbf{FX} _{ba}.
$$</p>
<p>\(J=\mathrm{det} (\mathbf{F} )\) 表示形变后的面积变化<br />
弹性势能：<br />
$$
\mathbf{U} (e)= \int _ e \psi (\mathbf{F} (x))dx=\mathbf{V} _e\psi (\mathbf{F} _e)
$$</p>
<p>\(\psi\) 是能量密度函数</p>
<p>如果采用显示积分，接下来根据能量计算力，再仿真。如果采用隐示积分，接下来基于能量做优化。<br />
弹性势能量密度函数关于体积的积分，对于一个元素来说，\(\mathbf{F}\) 是常数，\(\psi (\mathbf{F})\) 也是常用数。</p>
<p>\(\Psi(F)\) 的形式与具体的材料有关。</p>
<p>P5</p>
<h2 id="计算deformation-gradient"><a class="header" href="#计算deformation-gradient">计算Deformation Gradient</a></h2>
<p>Therefore, we can calculate the deformation gradient by edge vectors.</p>
<p><img src="./assets/07-2.png" alt="" /></p>
<p>公式第二项只与 reference 有关，可以预计算。</p>
<p><strong>Problem:</strong> \(\mathbf{F}\) <strong>is related to deformation, but it contains rotation</strong>.</p>
<blockquote>
<p>✅ 期望\(\mathbf{F}\)只包含形变量、不包含平移和旋转、因为刚体运动不应该有形变，所以要把形变提取出来。<br />
✅平移已经在\(\mathbf{c}\)里面了，所以只需考虑旋转。</p>
</blockquote>
<p>P6</p>
<h2 id="从f中去除旋转"><a class="header" href="#从f中去除旋转">从F中去除旋转</a></h2>
<h3 id="回顾svd分解"><a class="header" href="#回顾svd分解">回顾SVD分解</a></h3>
<p>Ideally, we need a tensor to describe shape deformation only.  Recall that SVD gives \(\mathbf{F=UDV^T}\), where only \(\mathbf{V^T}\) and \(\mathbf{D}\) are relevant to deformation.</p>
<p><img src="./assets/07-3.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{V^T}\) 看上去是旋转、实际上是为了确定形变的方向、 \(\mathbf{U}\) 才是真正的旋转<br />
✅ 目的：把\(\mathbf{F}\)中的\(\mathbf{U}\)去掉、可以先做 \(\mathbf{SVD}\) 分解再把\(\mathbf{U}\)去掉。但本文使用了更简单的方法</p>
</blockquote>
<h3 id="green-strain"><a class="header" href="#green-strain">Green Strain</a></h3>
<p>So we get rid of \(\mathbf{U}\) as: \(\mathbf{G} =\frac{1}{2} (\mathbf{F^TF−I} )=\frac{1}{2} (\mathbf{VD} ^2\mathbf{V} ^\mathbf{T} −\mathbf{I} )=\begin{bmatrix}
\varepsilon _{uu} &amp; \varepsilon _{uv}\\
\varepsilon _{uv} &amp; \varepsilon _{vv}
\end{bmatrix}\), <em>Green strain</em>.</p>
<blockquote>
<p>✅ \(\mathbf{G}\) 是一个描述物体形变的有无和大小矩阵，且与关旋转</p>
</blockquote>
<ul>
<li>If no deformation, \(\mathbf{G=0}\); if deformation increases,  ||\(\mathbf{G}\)|| increases.</li>
<li>Three deformation modes: \(\varepsilon _{uu}\), \(\varepsilon _{vv}\) and \(\varepsilon _{uv}\).</li>
<li>\(\mathbf{G}\) is <u>rotation invariant</u>: if additional rotation \(\mathbf{R}\), then deformation gradient is \(\mathbf{RF}\) but green strain is the same: \(\mathbf{G} =\frac{1}{2} (\mathbf{F^TR^TRF−I} )=\frac{1}{2} (\mathbf{VD} ^2\mathbf{V} ^\mathbf{T} −\mathbf{I} )\).</li>
</ul>
<p>P7</p>
<h2 id="弹性体的弹性势能"><a class="header" href="#弹性体的弹性势能">弹性体的弹性势能</a></h2>
<p>前面提到的能量公式是一种通用的形式。这里的能量计算过程是一种具体的广泛使用的公式。</p>
<p>Let \(\mathbf{G}\) be the the green strain describing deformation. We consider the <strong>energy density</strong> per reference area as: \(W (\mathbf{G})\).</p>
<p><img src="./assets/07-4.png" alt="" /></p>
<p><img src="./assets/07-5.png" alt="" /></p>
<blockquote>
<p>✅用形变程度来定义能量。\(W\)代表单位面积上的能量，因此称为能量密度。总能量为单位能量\(\mathbf{X}\)面积.<br />
✅  \(A^{ref}\) 为 reference status 下三角形的面积<br />
✅  StVK是一种经典的能量密度函数（Strain Energy Density Function）， 在力学中不常用，但在图形学中很常用、原因是简单</p>
</blockquote>
<p><img src="./assets/07-6.png" alt="" /></p>
<blockquote>
<p>✅  S 是一个与力有关的物理量。会在FVM内容中进一步解释。<br />
✅  能量对位移求导是力。形变是一种位移。能量密度对位移求导是一种类似于力的密度的量。</p>
</blockquote>
<p>P8</p>
<h2 id="计算forces"><a class="header" href="#计算forces">计算Forces</a></h2>
<p>Given everything we have, we can now calculate the forces.</p>
<blockquote>
<p>✅ 力是形变施加到顶点上的力</p>
</blockquote>
<p><img src="./assets/07-7.png" alt="" /></p>
<blockquote>
<p>✅ 绿色部分是上一页S中的内容、灰色部分将在下一页推导。</p>
</blockquote>
<p>P9</p>
<h3 id="方法一"><a class="header" href="#方法一">方法一</a></h3>
<p>Recall that,</p>
<p><img src="./assets/07-8.png" alt="" /></p>
<blockquote>
<p>❗ \(\mathbf{F}\)不是力，是deformation gradient．<br />
✅ 假设a,b,c,d是形变后的顶点。</p>
</blockquote>
<p>By definition,<br />
$$
\mathbf{G} =\frac{1}{2} (\mathbf{F^TF−I} )=\begin{bmatrix}
\frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (a\mathbf{x} _{10}+c\mathbf{x} _{20})−\frac{1}{2}  &amp; \frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})\\
\frac{1}{2}(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})  &amp; \frac{1}{2}(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} (b\mathbf{x} _{10}+d\mathbf{x} _{20})−\frac{1}{2}
\end{bmatrix}
$$</p>
<p>So:</p>
<p>$$
\frac{∂\varepsilon _{uu}}{∂\mathbf{x} _1}=a(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{vv}}{∂\mathbf{x} _1}=b(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{uv}}{∂\mathbf{x} _1}=\frac{1}{2} a(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} +\frac{1}{2}  b(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
$$</p>
<p>$$
\frac{∂\varepsilon _{uu}}{∂\mathbf{x} _2}=c(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{vv}}{∂\mathbf{x} _2}=d(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} 
\quad\quad
\frac{∂\varepsilon _{uv}}{∂\mathbf{x} _2}=\frac{1}{2} c(b\mathbf{x} _{10}+d\mathbf{x} _{20})^\mathbf{T} +\frac{1}{2}  d(a\mathbf{x} _{10}+c\mathbf{x} _{20})^\mathbf{T} 
$$</p>
<blockquote>
<p>✅ \(\mathbf{x}\)为current边的矩阵，\(\mathbf{r}\)为reference边的矩阵。</p>
</blockquote>
<p>P10</p>
<h3 id="方法二"><a class="header" href="#方法二">方法二</a></h3>
<p><img src="./assets/07-9.png" alt="" /></p>
<blockquote>
<p>✅ 把 P9 代入 P8 得到 P10<br />
✅ 上一页推导方法从定义出来，过程简单，但很容易出错。这里用矩阵来简化计算，得到同样的结果。</p>
</blockquote>
<p>P11</p>
<h3 id="结论"><a class="header" href="#结论">结论</a></h3>
<p>In conclusion, we have:</p>
<p>$$
\mathbf{f} _1=−A^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
a\\
b
\end{bmatrix}  \quad\quad \mathbf{f} _2=−A^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
c\\
d
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{f} _1 &amp;\mathbf{f} _2
\end{bmatrix}= − A ^{\mathrm{ref} }\mathbf{FS} \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20}
\end{bmatrix}^\mathbf{−T} 
$$</p>
<blockquote>
<p>✅ \(f_0=-f_1-f_2\)</p>
</blockquote>
<p>P12</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<blockquote>
<p>🔎 Volino et al. 2009. <em>A simple approach to nonlinear tensile stiffness for accurate cloth simulation</em>. TOG</p>
</blockquote>
<p>Only talks about cloth (2D reference -&gt; 3D deformation)</p>
<ul>
<li>What about tetrahedron (3D reference -&gt; 3D deformation)?
<ul>
<li>Same idea, but everything is now in 3D.</li>
<li>Deformation gradient \(\mathbf{F} \in \mathbf{R} ^{3×3}\)</li>
<li>Green strain \(\mathbf{G} \in \mathbf{R} ^{3×3}\)</li>
<li>Stress tensor \(\mathbf{S} \in \mathbf{R} ^{3×3}\)</li>
<li>Forces \(\mathbf{F}_i \in \mathbf{R} ^3\)</li>
</ul>
</li>
</ul>
<p>FEM 不擅长处理自碰撞。</p>
<h3 id="隐式积分"><a class="header" href="#隐式积分">隐式积分</a></h3>
<p>Recall backward Euler time integration:</p>
<p>$$
[\mathbf{I} -\Delta t^2\mathbf{M} ^{-1}\frac{\partial \mathbf{f} }{\partial \mathbf{x} }(\mathbf{x} _t)]\mathbf{v} _{t+1}=\mathbf{v} _t+\Delta t\mathbf{M} ^{-1}\mathbf{f} (\mathbf{x} _t)
$$</p>
<p>Want implicit time integration? Compute force differentials \(\frac{\partial \mathbf{f} }{\partial \mathbf{x} } =\frac{\partial^2\Psi  }{\partial \mathbf{F} ^2} \)</p>
<p><strong>Question:</strong> in both explicit and implicit schemes, how to compute \(m_i\)? Use mass lumping (or any other convenient approximation you want...)</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="topics-for-the-day"><a class="header" href="#topics-for-the-day">Topics for the Day</a></h1>
<ul>
<li>
<p>Hessian of Elastic Energy</p>
</li>
<li>
<p>Implicit Integration</p>
</li>
<li>
<p>Nonlinear optimization.</p>
</li>
</ul>
<blockquote>
<p>✅ 隐式积分不讲了。推荐P12页的论文<br />
✅ 直接跳到 P18、非线性优化。</p>
</blockquote>
<p>P4</p>
<h1 id="hessian-of-elastic-energy"><a class="header" href="#hessian-of-elastic-energy">Hessian of Elastic Energy</a></h1>
<p>P5</p>
<h2 id="recall-that"><a class="header" href="#recall-that">Recall that…</a></h2>
<p><img src="./assets/08-2.png" alt="" /></p>
<p>P6</p>
<h2 id="energy-hessian"><a class="header" href="#energy-hessian">Energy Hessian:</a></h2>
<p><img src="./assets/08-3.png" alt="" /></p>
<p>P7</p>
<h2 id="svd-derivative"><a class="header" href="#svd-derivative">SVD Derivative</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\)is singular value decomposition \((\mathbf{Λ} =\mathrm{diag} (λ_0,λ_1,λ_2))\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =\mathbf{U^T} (\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}\mathbf{ΛV^T} +\mathbf{U}\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}\mathbf{V^T}+\mathbf{UΛ}\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}})\mathbf{V}
$$</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =(\mathbf{U^T} \frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}})\mathbf{Λ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+ \mathbf{Λ}(\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\mathbf{V})
$$</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} = \mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+ \mathbf{ΛB}
$$</p>
<p>P8</p>
<h2 id="skew-symmetric-matrix"><a class="header" href="#skew-symmetric-matrix">Skew-Symmetric Matrix</a></h2>
<p>Matrix \(\mathbf{A}\) is skew-symmetric (or anti-symmetric), if \(\mathbf{A=−A^T}\):</p>
<p>$$
\mathbf{A} =\begin{bmatrix}
0 &amp; a &amp; b \\
-a &amp; 0 &amp; c \\
-b  &amp; -c &amp; 0
\end{bmatrix}
$$</p>
<p>If \(\mathbf{D}\) is diagonal, then:</p>
<p>$$
\mathbf{AD} =\begin{bmatrix}
0 &amp; a &amp; b \\
-a &amp; 0 &amp; c \\
-b  &amp; -c &amp; 0
\end{bmatrix}\begin{bmatrix}
d &amp; 0 &amp;0 \\
0 &amp; e &amp; 0\\
0 &amp; 0 &amp;f
\end{bmatrix}=\begin{bmatrix}
0 &amp; ? &amp; ?\\
? &amp; 0 &amp;? \\
? &amp; ? &amp;0
\end{bmatrix} 
$$</p>
<p>$$ 
\mathbf{DA} = \begin{bmatrix}
d  &amp; 0 &amp; 0\\
0 &amp; e &amp; 0\\
0 &amp; 0 &amp;f
\end{bmatrix}\begin{bmatrix}
0  &amp; a &amp; b\\
-a &amp; 0 &amp;c \\
-b &amp; -c &amp;0
\end{bmatrix}=\begin{bmatrix}
0 &amp; ? &amp;? \\
? &amp;  0&amp; ?\\
? &amp; ? &amp;0
\end{bmatrix}
$$</p>
<p>When \(\mathbf{U}\) is orthogonal, we have:</p>
<p>$$
\mathbf{0} =\frac{∂(\mathbf{U^TU)}}{∂\mathbf{F} _{kl}} =\mathbf{U^T} \frac{ ∂\mathbf{U} }{∂\mathbf{F} _{kl}}+\frac{∂\mathbf{U^T}}{∂\mathbf{F} _{kl}}\mathbf{U} =\mathbf{U^T}\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}+(\mathbf{U^T} \frac{∂\mathbf{U}}{∂\mathbf{F} _{kl}})^\mathbf{T} 
$$</p>
<p>Therefore, \(\mathbf{A=U^T}\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}\) is skew-symmetric. So is \(\mathbf{B} =\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}} \mathbf{V}\).</p>
<p>P9</p>
<h2 id="svd-derivative-cont"><a class="header" href="#svd-derivative-cont">SVD Derivative (cont.)</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\) is singular value decomposition \(\mathbf{Λ} =\mathrm{diag} (λ_0,λ_1,λ_2)\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} = \mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+\mathbf{ΛB} 
$$</p>
<p>After expansion, we get:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F}}{∂\mathbf{F} _{kl}} \mathbf{V} =<br />
\begin{bmatrix}
0 &amp; a_0 &amp; a_1\\
-a_0 &amp; 0 &amp; a_2\\
-a_1&amp; -a_2 &amp;0
\end{bmatrix} \begin{bmatrix}
λ_0 &amp; \Box  &amp; \Box\\
\Box &amp; λ_1 &amp;\Box \\
\Box &amp; \Box &amp;λ_2
\end{bmatrix} \begin{bmatrix}
\frac{∂λ_0}{∂\mathbf{F} _{kl}} &amp; \Box &amp; \Box\\
\Box &amp; \frac{∂λ_1}{∂\mathbf{F} _{kl}} &amp; \Box\\
\Box &amp; \Box &amp;\frac{∂λ_2}{∂\mathbf{F} _{kl}}
\end{bmatrix} \begin{bmatrix}
λ_0  &amp; \Box  &amp; \Box \\
\Box  &amp; λ_1 &amp;\Box  \\
\Box &amp; \Box  &amp;λ_2
\end{bmatrix} \begin{bmatrix}
0 &amp;  b_0&amp; b_1\\
-b_0 &amp; 0 &amp;b_2 \\
-b_1 &amp; -b_2 &amp;0
\end{bmatrix}
$$</p>
<p>P10</p>
<h2 id="svd-derivative-cont-1"><a class="header" href="#svd-derivative-cont-1">SVD Derivative (cont.)</a></h2>
<p>Since \(\mathbf{F=UΛV^T}\) is singular value decomposition \(\mathbf{Λ}=\mathrm{diag} (λ_0,λ_1,λ_2)\), we can do:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F} }{∂\mathbf{F} _{kl}}\mathbf{V} =\mathbf{AΛ} +\frac{∂\mathbf{Λ} }{∂\mathbf{F} _{kl}}+\mathbf{ΛB} 
$$</p>
<p>After expansion, we get:</p>
<p>$$
\mathbf{U^T} \frac{∂\mathbf{F}}{∂\mathbf{F} _ {kl}}\mathbf{V}<br />
= \begin{bmatrix}
∂λ _ 0/∂\mathbf{F} _ {kl}  &amp; λ _ 1 a _ 0 + λ _ 0 b _ 0 &amp; λ _ 2 a_ 1 + λ _ 0 b _ 1 \\
−λ _ 0 a_ 0 − λ _ 1 b _ 0 &amp; ∂λ _ 1/∂ \mathbf{F} _ {kl} &amp; λ _ 2 a _ 2 + λ _ 1 b _ 2\\
−λ _ 0 a_ 1−λ_ 2b_ 1 &amp; −λ_ 1a_ 0a_ 2−λ_ 2b_ 2 &amp;∂λ_ 2/∂ \mathbf{F} _ {kl}
\end{bmatrix} 
$$</p>
<p>$$
\begin{bmatrix}
m_ {00} &amp; m_ {01} &amp; m_ {02} \\
m_ {10} &amp; m_ {11} &amp; m_ {12}  \\
m_ {20} &amp; m_ {21} &amp; m_ {22} 
\end{bmatrix} = \begin{bmatrix}
∂λ_0/∂\mathbf{F} _{kl}  &amp; λ_1a_0+λ_0b_0 &amp; λ_2a_1+λ_0b_1\\
−λ_0a_0−λ_1b_0 &amp; ∂λ_1/∂ \mathbf{F} _{kl} &amp; λ_2a_2+λ_1b_2\\
−λ_0a_1−λ_2b_1 &amp; −λ_1a_0a_2−λ_2b_2 &amp;∂λ_2/∂ \mathbf{F} _ {kl}
\end{bmatrix} 
$$</p>
<p>Eventually, we get: \(\mathbf{A=U^T} \frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}}, \mathbf{B} = \frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\mathbf{V} \) and \(∂λ_0/∂\mathbf{F} _{kl}, ∂λ_1/∂\mathbf{F} _{kl}, ∂λ_2/∂\mathbf{F} _{kl}\).</p>
<p>P11</p>
<h2 id="a-quick-summary"><a class="header" href="#a-quick-summary">A Quick Summary</a></h2>
<ul>
<li>Step 1: By SVD derivatives, we get: \(\frac{∂\mathbf{U} }{∂\mathbf{F} _{kl}},\frac{∂λ_d}{∂\mathbf{F} _{kl}},\frac{∂\mathbf{V^T} }{∂\mathbf{F} _{kl}}\).</li>
</ul>
<p><img src="./assets/08-4.png" alt="" /></p>
<ul>
<li>Step 3: Finally, we reach our goal in Hessian matrix:</li>
</ul>
<p>$$
\frac{∂\mathbf{f} _i}{∂\mathbf{x} _j}=\sum _ {k,l}\frac{∂\mathbf{f} _i}{∂\mathbf{F} _{kl}} \frac{∂\mathbf{F} _{kl}}{∂\mathbf{x} _j}=\sum _ {k,l}
\frac{∂(\mathrm{Udiag} (\frac{∂W} {∂λ_0},\frac{∂W} {∂λ_1},\frac{∂W} {∂λ_2})\mathbf{V^T}) }{∂\mathbf{F} _{kl}}−V\mathbf{d} _i\frac{∂\mathbf{F} _{kl}}{∂\mathbf{x} _j}
$$</p>
<p>P12</p>
<h2 id="after-class-reading-5"><a class="header" href="#after-class-reading-5">After-Class Reading</a></h2>
<p>Xu et al. 2015. <em>Nonlinear Material Design Using Principal
Stretches</em>. TOG (SIGGRAPH).</p>
<p>Definitely read this paper if you decide to implement it.</p>
<p>P13</p>
<h2 id="implicit-integration"><a class="header" href="#implicit-integration">Implicit Integration</a></h2>
<p>P14</p>
<h1 id="implicit-integration-1"><a class="header" href="#implicit-integration-1">Implicit Integration</a></h1>
<p>Recall that we need implicit integration to avoid numerical instability (Class 5, page 13):</p>
<p>$$
\begin{cases} 
\mathbf{v} ^{[1]}=\mathbf{v} ^{[0]}+∆t\mathbf{M} ^{−1}\mathbf{f} ^{[1]} \\<br />
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[1]} 
\end{cases}
$$</p>
<p>$$\mathrm{or} $$</p>
<p>$$
\begin{cases} 
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f} ^{[1]}   \\<br />
\mathbf{v} ^{[1]}=(\mathbf{x} ^{[1]}−\mathbf{x} ^{[0]})/∆t<br />
\end{cases} 
$$</p>
<p>We also said that:</p>
<p>$$
\mathbf{x} ^{[1]}=\mathbf{x} ^{[0]}+∆t\mathbf{v} ^{[0]}+∆t^2\mathbf{M} ^{−1}\mathbf{f}(\mathbf{x}^{[1]})
$$</p>
<p>$$
\Updownarrow
$$</p>
<p>$$
\mathbf{x} ^{[1]}=\mathrm{argmin } F (\mathbf{x} ) 	\quad  \mathrm{for} \quad\mathbf{F} (\mathbf{x} )=\frac{1}{2∆t^2}||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_M^2+E(\mathbf{x} )
$$</p>
<p>P15</p>
<h2 id="newton-raphson-method-1"><a class="header" href="#newton-raphson-method-1">Newton-Raphson Method</a></h2>
<p>The Newton-Raphson method, commonly known as Newton’s method, solves the optimization problem: \(x^{[1]}\)=argmin \(F(x)\).  	\(\quad\quad\)		\((F(x)\) is Lipschitz continuous.)</p>
<p>Given a current \(x^{(k)}\), we approximate our goal by:</p>
<p>$$
0={F}'(x)≈{F}'(x^{(k)})+{F}'' (x^{(k)})(x−x^{(k)})
$$</p>
<p><img src="./assets/08-6.png" alt="" /></p>
<p>P16</p>
<h3 id="newton-raphson-method-2"><a class="header" href="#newton-raphson-method-2">Newton-Raphson Method</a></h3>
<p>Now we can apply Newton’s method to: \(\mathbf{x} ^{[1]}\)= argmin \( F (\mathbf{x} )\).<br />
Given a current \(\mathbf{x}^{(k)}\), we approximate our goal by:</p>
<p>$$
\mathbf{0} =∇F(\mathbf{x} )≈∇F(\mathbf{x} ^{(k)})+\frac{∂F^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} (\mathbf{x} −\mathbf{x} ^{(k)}) 
$$</p>
<blockquote>
<p>Newton’s Method<br />
Initialize \(x^{(0)}\)<br />
For \(k=0…K\)<br />
$$
∆\mathbf{x} \longleftarrow −(\frac{∂F^2(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2})^{−1}∇F(\mathbf{x} ^{(k)})
$$
$$
\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} 
$$
If \(||∆\mathbf{x}||\) is small	\(\quad\quad\)then break<br />
$$
\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}
$$</p>
</blockquote>
<p>P17</p>
<h3 id="simulation-by-newtons-method"><a class="header" href="#simulation-by-newtons-method">Simulation by Newton’s Method</a></h3>
<p>Specifically to simulation, we have:</p>
<p>$$
F (\mathbf{x} )=\frac{1}{2∆t^2} ||\mathbf{x} −\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]}||_M^2+E(\mathbf{x} )
$$</p>
<p>$$
∇F(\mathbf{x} ^{(k)})=\frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})−\mathbf{f} (\mathbf{x} ^{(k)})
$$</p>
<p>$$
\frac{∂^2F(\mathbf{x} ^{(k)})}{∂\mathbf{x} ^2} =\frac{1}{∆t^2}\mathbf{M} +\mathbf{H} (\mathbf{x} ^{(k)})
$$</p>
<blockquote>
<p>Initialize \(\mathbf{x}^{(0)}\), often as \(\mathbf{x} ^{[0]}\) or \(\mathbf{x} ^{[0]} +∆t\mathbf{v} ^{[0]}\)<br />
For \(k=0…K\)<br />
$$
\mathrm{Solve}\quad (\frac{1}{∆t^2} \mathbf{M+H} (\mathbf{x} ^{(k)}))∆\mathbf{x} =− \frac{1}{∆t^2}\mathbf{M} (\mathbf{x} ^{(k)}−\mathbf{x} ^{[0]}−∆t\mathbf{v} ^{[0]})+\mathbf{f} (\mathbf{x} ^{(k)})
$$
$$
\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+∆\mathbf{x} 
$$
If ||\(∆\mathbf{x}\)|| is small \(\quad\quad\)	then break<br />
$$
\mathbf{x} ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}
$$
$$
\mathbf{v} ^{[1]}←(\mathbf{x} ^{[1]}−\mathbf{x} ^{[0]})/ ∆t
$$</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nonlinear-optimization"><a class="header" href="#nonlinear-optimization">Nonlinear optimization</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>P13</p>
<h1 id="finite-volume-method"><a class="header" href="#finite-volume-method">Finite Volume Method</a></h1>
<blockquote>
<p>✅ FEM求导，FVM积分。在线性场景下，FEM和FVM本质上等价的。<br />
✅ FVM基于力从何而来的思想。</p>
</blockquote>
<h2 id="符号定义"><a class="header" href="#符号定义">符号定义</a></h2>
<p>P14</p>
<h3 id="traction"><a class="header" href="#traction">Traction</a></h3>
<p>First, let’s consider traction <strong>t</strong>: the internal force per unit length (area).</p>
<p><img src="./assets/07-10.png" alt="" /></p>
<blockquote>
<p>✅ 两个弹性体被界面 \(L\) 分开、求 \(L\) 上的力、</p>
</blockquote>
<p>Total interface force:</p>
<p>$$
f\mathbf{} =\oint _L \mathbf{t} dl
$$</p>
<blockquote>
<p>✅ \(\mathbf{t}\)是\(L\) 上的单位面积/长度上的力。那么总的力是 \(t\) 的积分。<br />
✅ traction 表达物体形变后会向周围施加的力。</p>
</blockquote>
<h3 id="stress"><a class="header" href="#stress">Stress</a></h3>
<p>Stress tensor \(\mathbf{σ} \) (interface normal -&gt; traction):</p>
<p>$$
\mathbf{t=σn} 
$$</p>
<p>So,</p>
<p>$$
\mathbf{f} =\oint_{L}  \mathbf{σn} dl
$$</p>
<blockquote>
<p>✅ \(\mathbf{σ}\) 一个3 \(\times \)3的矩阵</p>
</blockquote>
<p>P15</p>
<h2 id="计算fvm中的力"><a class="header" href="#计算fvm中的力">计算FVM中的力</a></h2>
<h3 id="2d"><a class="header" href="#2d">2D</a></h3>
<p>FVM considers force calculation in an integration perspective, not a differentiation perspective.</p>
<p><img src="./assets/07-11.png" alt="" /></p>
<blockquote>
<p>✅  \(\mathbf{X}_0\)是顶点\(\mathbf{X}_0\)附近邻域面积上的力。</p>
</blockquote>
<p>Force contributed by an element:</p>
<p>$$
\mathbf{f}_0 =\oint _L \mathbf{σn} dl
$$</p>
<blockquote>
<p>✅  \(\mathbf{X}_0\)上的力是邻域面边界\(L\)上的力的积分、不考虑边界内部的力，因为认为内力为0。<br />
✅  仅看其中一个三角形、假设曲线经过 \(\mathbf{X}_0\mathbf{X}_1\)和 \(\mathbf{X}_0\mathbf{X}_2\)的中点。因为三角形的力对三个顶点是平均的。</p>
</blockquote>
<p>Since \(\mathbf{σ}\) is constant within the element,</p>
<p>$$
\oint_L \mathbf{σn} dl + \oint_{L_{20}} \mathbf{σn} dl+\oint_{L_{10}}\mathbf{σn} dl=0
$$</p>
<blockquote>
<p>✅  对于封闭曲线L+L10+L20做积分，\(\int _n=0\)，因此 \(\sigma \int _n=0\)</p>
</blockquote>
<p>(Divergence Theorem)</p>
<p>We know the force is:</p>
<p>$$
\mathbf{f}_0 = - \oint _ {L _{20}} \mathbf{σn} _ {20} dl -  \oint _ {L _{10}} \mathbf{σn} _ {10} dl = - \mathbf{σ}(\frac{||\mathbf{X} _ {20}||}{2}\mathbf{n} _ {20}+ \frac{||\mathbf{X} _ {20}||}{2}\mathbf{n} _ {10})
$$</p>
<p>P16</p>
<h3 id="3d"><a class="header" href="#3d">3D</a></h3>
<blockquote>
<p>✅ 三维场景是对四面体的四个面积分。<br />
✅ 每个三角形的 stress 都不同、同一个三角形内部 stress 是常数。</p>
</blockquote>
<p>In 3D, FVM works in the same way.</p>
<p><img src="./assets/07-12.png" alt="" /></p>
<p>Force:</p>
<p>$$
\begin{array}{l} 
\mathbf{f} _ 0 = −\oint _ Ω \mathbf{σn} dA=−\mathbf{σ} (\frac{A _ {012}}{3}\mathbf{n} _ {012} + \frac{A _ {023}}{3}\mathbf{n} _ {023} + \frac{A _ {031}}{3}\mathbf{n} _ {031})\\
=−\frac{σ}{3}(\frac{||\mathbf{x} _ {10} \times \mathbf{x} _ {20}||}{2} \frac{\mathbf{x} _ {10} × \mathbf{x} _ {20}}{||\mathbf{x} _ {10} × \mathbf{x} _ {20}||} + \frac{||\mathbf{x} _ {20} × \mathbf{x} _ {30}||}{2}\frac{\mathbf{x} _ {20} × \mathbf{x} _ {30}}{||\mathbf{x} _ {20} × \mathbf{x} _ {30}||}
+\frac{||\mathbf{x} _ {30} × \mathbf{x} _ {10}||}{2}\frac{\mathbf{x} _ {30} × \mathbf{x} _ {10}}{||\mathbf{x} _ {30} × \mathbf{x} _ {10}||})\\
=−\frac{\mathbf{σ}}{6} (\mathbf{x} _ {10} × \mathbf{x} _ {20} + \mathbf{x} _ {20} × \mathbf{x} _ {30} + \mathbf{x} _ {30} × \mathbf{x} _ {10})
\end{array}
$$</p>
<blockquote>
<p>❓ 遗留问题， stress 如何计算？</p>
</blockquote>
<blockquote>
<p>✅ \(f_0\)是\(\sigma n\)在绿色体截面上的积分。<br />
✅ 类似于上一页合力为零的原理，\( \oint 截面＋\oint 表面=0\)<br />
✅ “面积／3”是因为面上的贡献均匀地分布到三个点上。</p>
</blockquote>
<p>P17</p>
<h2 id="计算fvm中的stress"><a class="header" href="#计算fvm中的stress">计算FVM中的stress</a></h2>
<p>Although the use of stress tensor is the same: <strong>mapping from the interface normal to the traction</strong>, it can be defined by different configurations.</p>
<table><thead><tr><th><img src="./assets/07-13.png" alt="" /></th><th><img src="./assets/07-14.png" alt="" /></th></tr></thead><tbody>
<tr><td>In FEM, we define the energy density \(W\) in the <strong>reference</strong> state.  Therefore, this stress \(\mathbf{S}\)  is a mapping from the normal \(\mathbf{N}\) to the traction \(\mathbf{T}\), both in the <strong>reference</strong> state.</td><td>In FVM, we need \(\mathbf{σ}\) to convert the normal into \(\mathbf{t}\) for force calculation. Therefore, this stress assumes the normal \(\mathbf{n}\) and the traction \(\mathbf{t}\) are in the <strong>deformed</strong> state.</td></tr>
</tbody></table>
<blockquote>
<p>✅ 在 reference 状态下有 normal. traction 和 stress.在形变状态下也有 normal traction 和 stress.FEM 使用的是 reference 空间下的量。</p>
</blockquote>
<p>P18</p>
<h3 id="different-stresses"><a class="header" href="#different-stresses">Different Stresses</a></h3>
<p>We can now have different stresses, serving the same purpose but in different forms.</p>
<p><img src="./assets/07-15.png" alt="" /></p>
<blockquote>
<p>✅ FVM 需要的是 Cauchy Stress.（\(\sigma \)）、上节课讲了(S)的 计算方法，需要根据(S)求(\(\sigma \)).<br />
✅ \(P → \sigma \) 的过程没有展开讲，结论在P21</p>
</blockquote>
<p>$$
S=J\sigma=PF^\tau 
$$</p>
<p>$$
P=J\sigma F^{-\tau }
$$</p>
<p>Lecture [21:35]</p>
<p>P19</p>
<h3 id="p与sigma-的关系area-weighted-normals"><a class="header" href="#p与sigma-的关系area-weighted-normals">P与\(\sigma \)的关系：Area Weighted Normals</a></h3>
<p><img src="./assets/07-16.png" alt="" /></p>
<p>Now let’s figure out the relationship between \(A^{\mathrm{ref} }\mathbf{N}\) and \(A\mathbf{n}\), the two area weighted normals.</p>
<p>$$
2A^{\mathrm{ref} }\mathbf{N} =\mathbf{X} _ {a0}×\mathbf{X} _ {b0}
$$</p>
<p>$$
\begin{array}{l} 
2A\mathbf{n} =\mathbf{x} _ {a0}×\mathbf{x} _ {b0}=\mathbf{FX} _{a0} × \mathbf{FX} _ {b0} = (\mathbf{UDV^TX} _ {a0}) × (\mathbf{UDV^TX} _ {b0}) \\
\quad\quad=\mathbf{U} ((\mathbf{DV^TX} _ {a0}) × (\mathbf{DV^TX} _ {b0})) \\
\quad\quad=\mathbf{U} \begin{bmatrix}
d_1d_2&amp; \Box  &amp; \Box \\
\Box  &amp; d_0d_2 &amp; \Box \\
\Box &amp; \Box  &amp;d_0d_1
\end{bmatrix} ((\mathbf{V^TX} _ {a0})×(\mathbf{V^TX} _ {b0}))\\
\quad\quad=\mathbf{U} \begin{bmatrix}
d_1d_2&amp; \Box  &amp; \Box \\
\Box  &amp; d_0d_2 &amp; \Box \\
\Box &amp; \Box  &amp;d_0d_1
\end{bmatrix} \mathbf{V^T} (\mathbf{X} _ {a0} × \mathbf{X} _ {b0})\quad=d_0d_1d_2\mathbf{U} \begin{bmatrix}
1/d_0&amp; \Box  &amp; \Box  \\
\Box  &amp; 1/d_1 &amp; \Box  \\
\Box &amp; \Box  &amp;1/d_2
\end{bmatrix} \mathbf{V^T} (\mathbf{X} _ {a0}×\mathbf{X} _ {b0}) \\
\quad\quad=\mathrm{det} (\mathbf{F} )\mathbf{F} ^{−\mathbf{T}}(\mathbf{X} _ {a0}×\mathbf{X} _ {b0})=\mathrm{det} (\mathbf{F} )\mathbf{F} ^{−\mathbf{T}}(2A^\mathrm{ref}\mathbf{N})
\end{array}
$$</p>
<p>P20</p>
<p>Now we know: \(A\mathbf{n} =\mathrm{det} (\mathbf{F})\mathbf{F^{−T}} (A^{\mathrm{ref}}\mathbf{N} )\).</p>
<p>We also know the force can be calculated using two different stresses:</p>
<p>$$
\mathbf{f} =−\frac{1}{3}  {\textstyle \sum {A^{\mathrm{ref} }}}\mathbf{PN} =−\frac{1}{3}\sum A\mathbf{σn} 
$$</p>
<p>Therefore, we get:</p>
<p>$$
\mathbf{P} (A^{\mathrm{ref} }\mathbf{N} )=\mathbf{σ} \mathrm{det} (\mathbf{F} )\mathbf{F^{−T}} (A^{\mathrm{ref} }\mathbf{N} )
$$</p>
<p>$$
\mathrm{det} ^{−1}(\mathbf{F} )\mathbf{PF^T=σ} 
$$</p>
<p>P21</p>
<h3 id="结论-1"><a class="header" href="#结论-1">结论</a></h3>
<p>We can now have different stresses, serving the same purpose but in different forms.</p>
<p><img src="./assets/07-17.png" alt="" /></p>
<p>P22 </p>
<h2 id="根据stress算出力"><a class="header" href="#根据stress算出力">根据stress算出力</a></h2>
<p>The previous analysis suggests we can use reference normals instead.</p>
<p><img src="./assets/07-18.png" alt="" /></p>
<p>Second Piola–Kirchhoff stress:<br />
\(\mathbf{S} =\frac{∂W}{∂\mathbf{G}}\), as in previous FEM formulation</p>
<blockquote>
<p>✅ 第一行公式：用 deformed position 计算 deformed position. 第二行公式：用 ref position 计算 deformed position, 因此直接把\(\sigma \)换成 \(\mathbf{P} \) 就可以。<br />
✅ 好处：ref position 是常数，可以做预计算、并存储为\(b_1\).<br />
✅ F：deformation gradient.见P5<br />
✅ 用三种不同定义的 stress 来算力、目的是得到计­算最友好的公式<br />
✅ 此处内容涉及材料力学、</p>
</blockquote>
<p>P23</p>
<h2 id="关于b1"><a class="header" href="#关于b1">关于b1</a></h2>
<p><img src="./assets/07-19-01.png" alt="" /></p>
<blockquote>
<p>✅ 问：  \(\mathbf{X}_ {20}^\mathbf{T} b_1\)的计算公式中、绿色的\(\mathbf{X}_ {01}×\mathbf{X} _ {21}\)怎么变成了\(\mathbf{X}_ {20}\times \mathbf{X}_ {10}\)？下面的\(\mathbf{X}_ {30}^\mathbf{T} b_1\),也一样。<br />
答：因为\(\mathbf{X}_o，\mathbf{X}_1，\mathbf{X}_2\)是同一个三角形上的顶点，任意两条边做cross都是一样的，处理好正负就好了。<br />
也可以用cross的乘法分配律得出相同的结论</p>
</blockquote>
<p>P24<br />
Therefore, We get:</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _1=\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T}(\mathbf{X} _{01}×\mathbf{X} _{21}+\mathbf{X} _{21}×\mathbf{X} _{31}+\mathbf{X} _{31}×\mathbf{X} _{01})=\begin{bmatrix}
6Vol\\
0\\
0
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _2=\begin{bmatrix}
0\\
6Vol\\
0
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^\mathbf{T} \mathbf{b} _3=\begin{bmatrix}
0\\
0\\
6Vol
\end{bmatrix}
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{b} _{1} &amp; \mathbf{b} _{2} &amp;\mathbf{b} _{3}
\end{bmatrix}^\mathbf{T} =6Vol\begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-\mathbf{T}}\\
\quad\quad=\frac{1}{\mathrm{det}( \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-1})} \begin{bmatrix}
\mathbf{X} _{10} &amp; \mathbf{X} _{20} &amp;\mathbf{X} _{30}
\end{bmatrix}^{-\mathbf{T}}
$$</p>
<p>P25</p>
<h2 id="a-quick-summary-1"><a class="header" href="#a-quick-summary-1">A Quick Summary</a></h2>
<p><img src="./assets/07-20.png" alt="" /></p>
<blockquote>
<p>✅reference 状态下，\(F＝I,G=0,P=0,f=0\)</p>
</blockquote>
<p>P26</p>
<h2 id="after-class-reading-6"><a class="header" href="#after-class-reading-6">After-Class Reading</a></h2>
<h3 id="重点推荐"><a class="header" href="#重点推荐">重点推荐：</a></h3>
<p>Teran et al. 2003. <em>Finite Volume Methods for the
Simulation of Skeleton Muscles</em>. SCA.</p>
<blockquote>
<p>✅ 这篇论文重点推荐，但论文中的公式与 PPT 中的不完全一样. PPT 上的又进一步简化。</p>
</blockquote>
<h3 id="optional"><a class="header" href="#optional">Optional</a></h3>
<p>Volino et al. 2009. <em>A Simple Approach to Nonlinear Tensile
Stiffness for Accurate Cloth Simulation</em>. TOG.</p>
<blockquote>
<p>✅ 2D有限元</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P28</p>
<h1 id="hyperelastic-models"><a class="header" href="#hyperelastic-models">Hyperelastic Models</a></h1>
<p>连续材质力学</p>
<blockquote>
<p>✅ 前面的内容，都假设使用 StVK 材料、优点是简单；缺点是无法处理反转。因此在材料力学中不常用。这一节讲弹性材料。<br />
✅ Hyperplasia 利用能量密度(W)、提供一个从 Strain (G) 到 Stress (S)的映射</p>
</blockquote>
<p>Lecture 3 [17:18]<br />
Stress：材料恢复自身形状的内力，应力。<br />
Strain：应变。</p>
<p><img src="./assets/07-%E6%89%8B%E5%B7%A5%E5%9B%BE.png" alt="" /></p>
<p>P29</p>
<h3 id="材料参数和超弹性模型"><a class="header" href="#材料参数和超弹性模型">材料参数和超弹性模型</a></h3>
<p>定义：<br />
We treat the first Piola–Kirchhoff stress tensor \(\mathbf{P}\) as a function of deformation gradient \(\mathbf{F}\):</p>
<p>函数 \(\mathbf{P(F)}\) 中除了变量 \(\mathbf{F}\)，还包其它超量，这些参数就是材料系数。Lecture 3 [22:17]</p>
<p>不同的 \(\mathbf{P}\) 的定义方式称为超弹性模型<br />
Lecture 3 [25:45]</p>
<p>$$
\mathbf{f} _0= −\frac{\mathbf{P} (\mathbf{F} )}{6}(\mathbf{X} _{10}×\mathbf{X} _{20}+\mathbf{X} _{20}×\mathbf{X} _{30}+\mathbf{X} _{30}×\mathbf{X} _{10})
$$</p>
<p>It converts an interface normal \(\mathbf{N}\) in the reference state to a traction \(\mathbf{t}\) in the deformed state. </p>
<p>$$
\mathbf{t}=\mathbf{P} (\mathbf{UDV^T} )\mathbf{N} 
$$</p>
<p><img src="./assets/07-21.png" alt="" /></p>
<p>P30</p>
<h3 id="rotation-invariance"><a class="header" href="#rotation-invariance">Rotation-Invariance</a></h3>
<p>The stress tensor \(\mathbf{P}\) is rotation-invariant to \(\mathbf{U}\):</p>
<p><img src="./assets/07-22.png" alt="" /></p>
<p>$$
\mathbf{P} (\mathbf{UDV^T} )=\mathbf{UP} (\mathbf{DV^T} )
$$</p>
<blockquote>
<p>✅ 没讲，</p>
</blockquote>
<p>P31</p>
<h3 id="isotropic-materials"><a class="header" href="#isotropic-materials">Isotropic Materials</a></h3>
<p>The stress tensor \(\mathbf{P}\) is rotation-invariant to \(\mathbf{U}\):</p>
<p><img src="./assets/07-23.png" alt="" /></p>
<p>$$
\mathbf{P} (\mathbf{DV^T} )=\mathbf{P} \mathbf{(D)V^T} 
$$</p>
<blockquote>
<p>✅ 没讲，</p>
</blockquote>
<p>P32</p>
<h2 id="isotropic-materials-1"><a class="header" href="#isotropic-materials-1">Isotropic Materials</a></h2>
<blockquote>
<p>Isotropic Materials：各向同性材料</p>
</blockquote>
<p><img src="./assets/07-24.png" alt="" /></p>
<blockquote>
<p>✅ 符号解释：\(\mathbf{P}\)：First Piola Stress、 \(\mathbf{F}\)：Deformation Gradient<br />
✅ 各向同性公式认为：\(\mathbf{P}\) 是关于 \(\mathbf{F}\) 的函数<br />
✅ 对F做 \(\mathbf{SVD}\) 分解可得到 \(\mathbf{UDV^T}\)，其中\(D\)是对角矩阵、其对角元素描述了三个方向的拉伸的量、把公式中的旋转分量剔除掉、 \(\mathbf{P}\) 只与 Principal stretches 有关。</p>
</blockquote>
<p>In many literatures, people parameterize \(\mathbf{P} (I_\mathbf{C},II_\mathbf{C},III_\mathbf{C} )\) by principal invariants, for:</p>
<p>$$
I_\mathbf{C} =\mathrm{trace} (\mathbf{C} )=λ_0^2+λ_1^2+λ_2^2
$$</p>
<p>$$
III_\mathbf{C} =\mathrm{det} (\mathbf{C} ^2)=λ_0^4+λ_1^4+λ_2^4
$$</p>
<p>$$
II_\mathbf{C} =\frac{1}{2} (\mathrm{trace} ^2(\mathbf{C} )−\mathrm{trace} (\mathbf{C} ^2))=λ_0^2λ_1^2+λ_0^2λ_2^2+λ_1^2λ_2^2
$$</p>
<p>\(\mathbf{C=U^TU}\) is the right Cauchy-Green deformation tensor.</p>
<blockquote>
<p>✅ \(I_c、 II_c、 III_c\) 的定义是基于材料学、数学的先验知识</p>
</blockquote>
<p>P33</p>
<h2 id="isotropic-models"><a class="header" href="#isotropic-models">Isotropic Models</a></h2>
<p><img src="./assets/07-25.png" alt="" /></p>
<blockquote>
<p>✅ 材料力学中更常用 neo-Hookean<br />
✅ Fung常用来模拟人体组织。</p>
</blockquote>
<p>P34</p>
<h2 id="计算p"><a class="header" href="#计算p">计算P</a></h2>
<p>Anyway, we still use the principal stretches for computation:</p>
<p>$$
\mathbf{P} (λ_0,λ_1,λ_2)=\begin{bmatrix}
\frac{∂W}{∂λ_0}  &amp; \Box  &amp;\Box  \\
\Box  &amp; \frac{∂W}{∂λ_1}  &amp; \Box \\
\Box  &amp; \Box  &amp;\frac{∂W}{∂λ_2} 
\end{bmatrix}
$$</p>
<p>And we compute the first Piola-Kirchhoff stress as:</p>
<p>$$
\mathbf{P} = \mathbf{UP} (λ_0,λ_1,λ_2)\mathbf{V} ^\mathbf{T} 
$$</p>
<p>P35</p>
<h2 id="a-quick-summary-2"><a class="header" href="#a-quick-summary-2">A Quick Summary</a></h2>
<p><img src="./assets/07-26.png" alt="" /></p>
<blockquote>
<p>✅ 主要是算P的方法不同</p>
</blockquote>
<p>P36</p>
<h2 id="the-limitation-of-stvk"><a class="header" href="#the-limitation-of-stvk">The Limitation of StVK</a></h2>
<p><img src="./assets/07-27.png" alt="" /></p>
<p>Irving et al. 2004. <em>Invertible Finite Elements For Robust Simulation of Large Deformation</em>. SCA</p>
<blockquote>
<p>✅ 纵轴是力、横轴长度为弹簧长度、参考长度是1， 因此横轴为1时纵轴为0. 横轴 &gt; 1 代表拉伸、拉伸越大代表力越大。但压缩时， \(StVK\) 表现出的力不对，且当弹簧（四面体）反转以后，力也会反转，这种表现也不对，因为最后会停在横轴-1的状态上。</p>
</blockquote>
<p>P37</p>
<p><img src="./assets/07-28.png" alt="" /></p>
<blockquote>
<p>✅ Poison Effect： 弹性体往上拉时两边会凹进去，本质原因是保体积。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P39</p>
<h1 id="a-summary-for-the-day-3"><a class="header" href="#a-summary-for-the-day-3">A Summary For the Day</a></h1>
<ul>
<li>
<p>FEM uses the <strong>derivates</strong> of the strain energy function to obtain the force.</p>
</li>
<li>
<p>FVM uses the <strong>integral</strong> of the interface traction to obtain the force.</p>
</li>
<li>
<p>The two approaches lead to the <strong>identical outcome</strong>, in <strong>different formulations</strong></p>
</li>
<li>
<p>Hyperelastic models define the strain energy function by principal stretches, i.e., the singular values of the deformation gradient.</p>
</li>
<li>
<p>For isotropic materials, we can calculate the stress through diagonalization.</p>
</li>
</ul>
<blockquote>
<p>✅ Level：1. 了解，会用；2. 理解、举一反三；3. 跳出图形学；<br />
✅ 图形学关注的不是数学模型，而是快。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P4</p>
<h1 id="a-height-field-model"><a class="header" href="#a-height-field-model">A Height Field Model</a></h1>
<h2 id="高度场height-field和速度场"><a class="header" href="#高度场height-field和速度场">高度场（Height Field）和速度场</a></h2>
<p>P5</p>
<h3 id="高度场height-field和速度场的定义"><a class="header" href="#高度场height-field和速度场的定义">高度场（Height Field）和速度场的定义</a></h3>
<p><img src="./assets/10-3.png" alt="" /></p>
<blockquote>
<p>✅ 利用高度函数来表达波的平面，通过更新\(h(x)\)来表达水面随时间波动的效果。<br />
✅ 由于用函数表达，无法描述大海浪的效果，因为这种情况下一个位置对应多个高度。<br />
✅ 速度场描述水流的速度和方向， 速度&lt; 0 则右往左， &gt; 0 则左往右。</p>
</blockquote>
<p>P6</p>
<h3 id="高度场的更新"><a class="header" href="#高度场的更新">高度场的更新</a></h3>
<p><img src="./assets/10-4-1.png" alt="" /> </p>
<blockquote>
<p>✅ 高度场更新公式第一项：高度场随时间的变化。<br />
✅ 高度场更新公式第二项，根据微分的定义：<br />
\(h(x)u(x)\): 单位时间内流过x线的水量。<br />
\(d(h(x)u(x))\) ：单位时间内区域 \([x \quad x+dx]\) 的水量变化、<br />
\(d(h(x)u(x))1/dx\) ：单位时间内区域区 \([x \quad x+dx]\) 的水位高度变化</p>
</blockquote>
<p>P7</p>
<h3 id="速度场的更新"><a class="header" href="#速度场的更新">速度场的更新</a></h3>
<p>The velocity is also a function of \(x:u(x)\).</p>
<p><img src="./assets/10-5-1.png" alt="" /></p>
<blockquote>
<p>✅ 第一项：当水在流动时，速度应该跟水一起流动，下节课再讲。<br />
✅ 第三项：外力，当前也不考虑。</p>
</blockquote>
<p>P8</p>
<p>Ignoring advection and external acceleration, we get a simple form:</p>
<p>$$
\begin{matrix}
\frac{du(x)}{dt}=−\frac{1}{ρ} \frac{dP(x)}{dx} \quad \quad &amp; ρ: \text{density} \quad \quad &amp; P(x):\text{pressure}
\end{matrix}
$$</p>
<p><img src="./assets/10-6.png" alt="" /></p>
<blockquote>
<p>✅ 第二项： 在短时间内、速度变化由左右压强差决定。同样的压强下，密度大则难推，密度小则好推。</p>
</blockquote>
<p>P9</p>
<h2 id="shallow-wave-equation"><a class="header" href="#shallow-wave-equation">Shallow Wave Equation</a></h2>
<blockquote>
<p>✅ 为什么叫 Shallow Wave, 因为该算法假设水波很小，因此 \(dh / dx\) 可忽略不计。</p>
</blockquote>
<p>We now have two equations:</p>
<p><img src="./assets/10-7.png" alt="" /> </p>
<blockquote>
<p>✅ 公式化简的目的：不需要关心速度场\(u\)、仅关注高度场就可以。<br />
✅ 第一个公式：（1）对\(d(hu)\)展开（2）再求一次\(dt\)<br />
✅ 第二个公式：对\(x\)求导</p>
</blockquote>
<p>We can then eliminate \(u\) and formulate the shallow wave equation:</p>
<table><thead><tr><th>$$\frac{d^2ℎ}{dt^2} =\frac{ℎ}{ρ} \frac{d^2P}{dx^2} $$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 合并同类项，得到最终方程<br />
✅ 但引擎无法直接处理微分程，因此要离散化开求解。</p>
</blockquote>
<p>P10</p>
<h2 id="高度场离散化"><a class="header" href="#高度场离散化">高度场离散化</a></h2>
<p>前面的仿真都需要时间的离散化。这里除了时间离散化，还要空间离散化。<br />
时间离散和空间离散是有区别的。<br />
时间上，每个时间步要计算的是与上一个时间步的积累差异，因此需要积。\(\Delta a→\Delta \nu→\Delta x\)<br />
空间上，每个位置要计算的是这个位置上的物理属性，因此要用微分。 \(\Delta x→\Delta \nu→\Delta a\)</p>
<p>We discretize a continuous height field into a discrete set of height columns.</p>
<p><img src="./assets/10-8.png" alt="" /></p>
<blockquote>
<p>✅ 高度场离散化为多个水柱，微分算子也要离散化。</p>
</blockquote>
<p>P11</p>
<h2 id="微分算子离散化"><a class="header" href="#微分算子离散化">微分算子离散化</a></h2>
<h3 id="前向差分与后向差分"><a class="header" href="#前向差分与后向差分">前向差分与后向差分</a></h3>
<p>The idea of finite differencing is to use the difference to approximate the derivative.</p>
<p>$$
f(t_0+∆t)=f(t_0)+∆t\frac{df(t_0)}{dt} +\frac{∆t^2}{2} \frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Forward differencing (first-order)</p>
<table><thead><tr><th>$$\frac{df(t_0)}{dt} ≈\frac{f(t_0+∆t)−f(t_0)}{∆t}$$</th></tr></thead><tbody>
</tbody></table>
<p>$$
f(t_0−∆t)=f(t_0)−∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Backward differencing (first-order)</p>
<table><thead><tr><th>$$ \frac{df(t_0)}{dt}≈\frac{f(t_0)−f(t_0−∆t)}{∆t} $$</th></tr></thead><tbody>
</tbody></table>
<p>P12</p>
<h3 id="central-differencing"><a class="header" href="#central-differencing">Central Differencing</a></h3>
<p>The idea of finite differencing is to use the difference to approximate the derivative.</p>
<p>$$
f(t_0+∆t)=f(t_0)+∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>$$
f(t_0−∆t)=f(t_0)−∆t\frac{df(t_0)}{dt}+\frac{∆t^2}{2}\frac{d^2f(t_0)}{dt^2} +…
$$</p>
<p>Central differencing (second-order)</p>
<table><thead><tr><th>$$ \frac{df(t_0)}{dt}≈\frac{f(t_0+∆t)−f(t_0−∆t)}{2∆t} $$</th></tr></thead><tbody>
</tbody></table>
<p>P13</p>
<h2 id="二阶微分算子离散化"><a class="header" href="#二阶微分算子离散化">二阶微分算子离散化</a></h2>
<h3 id="高度"><a class="header" href="#高度">高度</a></h3>
<p>We apply central differencing twice to estimate \(d^2ℎ_i/dt^2\).</p>
<p>$$
\begin{matrix}
\frac{dℎ_i(t_0+0.5∆t)}{dt}≈\frac{ℎ_i(t_0+∆t)−ℎ_i(t_0)}{∆t}  \quad\quad&amp; \frac{dℎ_i(t_0−0.5∆t)}{dt}≈\frac{ℎ_i(t_0)−ℎ_i(t_0−∆t)}{∆t} 
\end{matrix}
$$</p>
<table><thead><tr><th>$$\frac{d^2ℎ_i(t_0)}{dt^2}≈\frac{\frac{dℎ_i(t_0+0.5∆t)}{dt}−\frac{dℎ_i(t_0−0.5∆t)}{dt} }{∆t} ≈\frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/10-12.png" alt="" /></p>
<blockquote>
<p>✅ 先用 central difference 求出两个中点的一阶导数，再基于此计算 \(t_0\) 处的二阶导。这种操作又称为一维Laplace 算子。</p>
</blockquote>
<p>P14</p>
<h3 id="压强"><a class="header" href="#压强">压强</a></h3>
<p>Similarly, we apply central differencing twice to estimate \(d^2P/dx^2\).</p>
<p>$$
\begin{matrix}
\frac{dP_{i+0.5}}{dt} ≈\frac{P_{i+1}−P_i}{∆x} \quad\quad &amp; \frac{dP_{i−0.5}}{dx} ≈\frac{P_i−P_{i−1}}{∆x} 
\end{matrix}
$$</p>
<table><thead><tr><th>$$\frac{d^2P_i}{dx^2}≈\frac{\frac{dP_{i+0.5}}{dx}−\frac{dP_{i−0.5}}{dx}}{∆x} ≈\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2}$$</th></tr></thead><tbody>
</tbody></table>
<p><img src="./assets/10-13.png" alt="" /></p>
<blockquote>
<p>✅ 二维情况用周围4个元素，见 Games102 离散拉普拉斯算子。</p>
</blockquote>
<p>P15</p>
<h2 id="discretized-shallow-wave-equation"><a class="header" href="#discretized-shallow-wave-equation">Discretized Shallow Wave Equation</a></h2>
<p>We can now discretize the shallow wave equation \(\frac{d^2ℎ}{dt^2}=\frac{ℎ}{ρ}\frac{d^2P}{dx^2}\).</p>
<table><thead><tr><th>\(\begin{matrix}\ \frac{d^2ℎ_i(t_0)}{dt^2}≈\frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}\quad  &amp;\frac{d^2P_i}{dx^2 }≈\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2}\\\end{matrix}\)</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\Rightarrow \frac{ℎ_i(t_0+∆t)+ℎ_i(t_0−∆t)−2ℎ_i(t_0)}{∆t^2}=\frac{ℎ_i}{ρ} (\frac{P_{i+1}+P_{i−1}−2P_i}{∆x^2})\)</th></tr></thead><tbody>
</tbody></table>
<p>\(\quad\)</p>
<table><thead><tr><th>\(\Rightarrow ℎ_i(t_0+∆t)=2ℎ_i(t_0)−ℎ_i(t_0−∆t)+\frac{∆t^2ℎ_i}{∆x^2ρ}(P_{i+1}+P_{i−1}−2P_i)\)</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 更新目标：下一个时刻的水柱的高度，即 \(h_i(t_0 + ∆t)\)<br />
✅ 但按此公式模拟可能出现水的体积变多或变少的问题。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P16</p>
<h1 id="volume-preservation"><a class="header" href="#volume-preservation">Volume Preservation</a></h1>
<p>We want the volume to stay the same. Suppose that \(\sum ℎ_i(t)=\sum ℎ_i(t−∆t)=V\). But,</p>
<p>$$
ℎ_i(t_0+∆t)=2ℎ_i(t_0)−ℎ_i(t_0−∆t)+\frac{∆t^2ℎ_i}{∆x^2ρ}(P_{i+1}+P_{i−1}−2P_i)
$$</p>
<p><img src="./assets/10-14.png" alt="" /></p>
<blockquote>
<p>✅ 体积会变大还是变小，取决于桔色项，但很难保证这一项是0.</p>
</blockquote>
<p>P17</p>
<h2 id="volume-preservation--solution-1"><a class="header" href="#volume-preservation--solution-1">Volume Preservation – Solution 1</a></h2>
<p><img src="./assets/10-15.png" alt="" /></p>
<blockquote>
<p>✅ 保证 \(h_i\) 和 \(h_{i+1}\)的交换的水量相等、因此保体积<br />
✅ 把\(h_{i-1}\)与\(h_i\)的交换和\(h_i\)与\(h_{i+1}\)的交换拆开。即：<br />
（1）把\((P_{i+1}+P_{i−1}−2P_i)\)拆成\(P_{i−1}−P_i\)和\(P_{i+1}−P_i\)<br />
（2）把\(h_i\)拆成\(\frac{h_{i-1}+h_i}{2}\)和\(\frac{h_{i+1}+h_i}{2}\)<br />
✅ 直观理解：对每个水柱而言，流入的量和流出的量是等价的。</p>
</blockquote>
<p>P18</p>
<blockquote>
<p>🔎 Kass and Miller. 1990. <em>Rapid, Stable Fluid Dynamics for Computer Graphics</em>. Computer Graphics.</p>
</blockquote>
<p>P19</p>
<h2 id="volume-preservation--solution-2"><a class="header" href="#volume-preservation--solution-2">Volume Preservation – Solution 2</a></h2>
<p>An easier way to preserve volume is to <strong>simply assume</strong> \(h_i\) in the right term is constant.</p>
<p><img src="./assets/10-16.png" alt="" /></p>
<p>P20</p>
<h1 id="pressure"><a class="header" href="#pressure">Pressure</a></h1>
<p><img src="./assets/10-17.png" alt="" /> </p>
<p>P21</p>
<h1 id="viscosity"><a class="header" href="#viscosity">Viscosity</a></h1>
<p>Like damping, viscosity tries to slow down the waves. </p>
<p><img src="./assets/10-18-1.png" alt="" /> </p>
<blockquote>
<p>✅ Viscosity: 粘滞，相当于流体的阻尼。</p>
</blockquote>
<p>P22</p>
<h1 id="algorithm-1"><a class="header" href="#algorithm-1">Algorithm</a></h1>
<p>$$\text{A Shallow Wave Simulator}$$
For every cell \(i\)
$$ℎ_i^{new}←ℎ_i+β(ℎ_i−ℎ_i^{old})\\
ℎ_i^{new}←ℎ_i^{new}+α(ℎ_{i−1}−ℎ_i)\\
ℎ_i^{new} ←ℎ_i^{new}+α(ℎ_{i+1}−ℎ_i)\\$$
For every cell \(i\)
$$ℎ_i^{old}←ℎ_i\\<br />
ℎ_i←ℎ_i^{new}$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P23</p>
<h1 id="boundary-conditions"><a class="header" href="#boundary-conditions">Boundary Conditions</a></h1>
<h2 id="dirichlet-boundary"><a class="header" href="#dirichlet-boundary">Dirichlet boundary</a></h2>
<p><img src="./assets/10-19-1.png" alt="" /> </p>
<p>A Dirichlet boundary assumes that the boundary height \(H_{i+1}\) is constant.  It’s considered as an open boundary.</p>
<p>$$
ℎ_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i=H_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i
$$</p>
<p><img src="./assets/10-19-2.png" alt="" /> </p>
<blockquote>
<p>✅ 这种方法用于模拟开放的水面，例如大海的区域、假设被模拟的区域外是静止的水面、高度为常数，(Dirichlet)<br />
✅ \(h\)为边界内，\(H\)为边界外。</p>
</blockquote>
<p>P25</p>
<h2 id="algorithm-with-neumann-boundaries"><a class="header" href="#algorithm-with-neumann-boundaries">Algorithm with Neumann Boundaries</a></h2>
<p>Extending the simulator to 3D is also straightforward.</p>
<p><img src="./assets/10-19-3.png" alt="" /> </p>
<h2 id="neumann-boundary"><a class="header" href="#neumann-boundary">Neumann boundary</a></h2>
<p>A Neumann boundary specifies the boundary derivatives.  For example, a zero-derivative boundary means \(ℎ_{i+1}≡ℎ_i\).  It’s considered as a closed boundary.</p>
<p>$$
ℎ_{i+1}−ℎ_i+ℎ_{i−1}−ℎ_i=ℎ_{i−1}−ℎ_i
$$</p>
<blockquote>
<p>✅ Neuman 用于模拟有边界水域，例如池堂、假设边界上没有水流交换。</p>
</blockquote>
<p>P24</p>
<p><img src="./assets/10-19-4.png" alt="" /> </p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P33</p>
<h2 id="a-summary-for-the-day-4"><a class="header" href="#a-summary-for-the-day-4">A Summary For the Day</a></h2>
<ul>
<li>
<p>The shallow wave model simulates waves over a height field.</p>
</li>
<li>
<p>It’s based on a lot of simplification. We will discuss what fluid dynamics really looks like without simplification.</p>
</li>
<li>
<p>The strength of the shallow wave model is its <strong>simplicity</strong> and <strong>efficiency</strong>. It can easily simulate water-solid coupling too.</p>
</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topics-for-the-day-1"><a class="header" href="#topics-for-the-day-1">Topics for the Day</a></h1>
<pre class="mermaid">mindmap
Grid
    网格表示
        Regular 表示
        Stagger 表示
    网格的属性
        有限差分
        插值
        Diffusion
    网格的仿真
        外力
        Advection
        压强
        粕滞 Viscons
    应用场景
        气体
        流体
</pre>
<h1 id="reference-2"><a class="header" href="#reference-2">Reference</a></h1>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>解决了什么痛点</th><th>主要贡献是什么</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>1996</td><td>Realistic animation of liquids</td><td>在固定网格上利用纳维-斯托克斯方程模拟流体运动</td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P3</p>
<h1 id="a-grid-representation-and-finite-differencing"><a class="header" href="#a-grid-representation-and-finite-differencing">A Grid Representation and Finite Differencing</a></h1>
<p>P4</p>
<h2 id="a-regular-grid-representation"><a class="header" href="#a-regular-grid-representation">A Regular Grid Representation</a></h2>
<p><img src="./assets/11-01.png" alt="" /></p>
<blockquote>
<p>✅ 把场定义在标准格子上的好处：(1)把物理量定义在格子的中心（2）计算导数或利用导数进行微分计算变得容易了。<br />
✅ 上节课grid用1D来表示2D，2D表示3D，不是真正的grid方法。<br />
🔎 Central Differencing：L10.<br />
✅ 空间中任意位置的物理量由格子中心插值得出。</p>
</blockquote>
<p>P6</p>
<h3 id="finite-differencing-on-grid"><a class="header" href="#finite-differencing-on-grid">Finite Differencing on Grid</a></h3>
<p>P13</p>
<h1 id="staggered-grid-表示"><a class="header" href="#staggered-grid-表示">Staggered Grid 表示</a></h1>
<h3 id="problem-with-regular-grid-表示"><a class="header" href="#problem-with-regular-grid-表示">Problem with Regular Grid 表示</a></h3>
<p>Central differencing gives the derivative in the middle.</p>
<p><img src="./assets/11-6.png" alt="" /></p>
<ul>
<li>
<p>The cell doesn’t exist at (i+0.5, j).</p>
</li>
<li>
<p>To get \( \frac{∂f_ {i,j}}{∂x} \), we need \(f_{i−1,j}\) and \(f_{i+1,j}\).  But this is weird, because \(f_{i,j}\) is unused.</p>
</li>
</ul>
<blockquote>
<p>✅ 前面假设所有物理量定义在格子的中间。但此处算出来的一阶微分量不在格子中间。 </p>
</blockquote>
<p>P14</p>
<h2 id="solution-把速度属性放在墙上"><a class="header" href="#solution-把速度属性放在墙上">Solution: 把速度属性放在墙上</a></h2>
<blockquote>
<p>✅ 不规定所有物理量都定义在格子中间，也可以定义在墙上。<br />
✅ 对照 Height Fleld 方法，也是把 \(P\) 和 \(H\) 定义在格子上，把速度定义在格子交界处。</p>
</blockquote>
<p>We define some physical quantities on faces, specifically <strong>velocities</strong>.</p>
<p><img src="./assets/11-7.png" alt="" /></p>
<ul>
<li>
<p>The x-part of the velocity is defined on vertical faces.</p>
</li>
<li>
<p>The y-part of the velocity is defined on horizonal faces.</p>
</li>
</ul>
<blockquote>
<p>✅ 把速度定义在墙上的好处量，速度是矢量、可以用不同方向的墙表达不同方向上的速度、直观。</p>
</blockquote>
<p>The grid is very friendly with central differencing.</p>
<h3 id="一阶导数"><a class="header" href="#一阶导数">一阶导数</a></h3>
<p><img src="./assets/11-2.png" alt="" /></p>
<table><thead><tr><th>$$\frac{∂f_{i+0.5,j}}{∂x}≈\frac{f_{i+1,j}−f_{i,j}}{ℎ}$$</th></tr></thead><tbody>
</tbody></table>
<p>P7</p>
<h3 id="二阶导数"><a class="header" href="#二阶导数">二阶导数</a></h3>
<p><img src="./assets/11-3.png" alt="" /></p>
<p>P8</p>
<h3 id="discretized-laplacian"><a class="header" href="#discretized-laplacian">Discretized Laplacian</a></h3>
<p>We can then obtain the discretized Laplacian operator on grid.</p>
<p><img src="./assets/11-4.png" alt="" /></p>
<p>$$
\frac{∂^2f_{i,j}}{∂x^2}≈\frac{\frac{∂f_{i−0.5,j}}{∂x}−\frac{∂f_{i+0.5,j}}{∂x}}{ℎ}≈\frac{f_{i−1,j}+f_{i+1,j}−2f_{i,j}}{ℎ^2}
$$</p>
<p>$$
\frac{∂^2f_{i,j}}{∂y^2}≈\frac{\frac{∂f_{i,j+0.5}}{∂y}−\frac{∂f_{i,j−0.5}}{∂y}}{ℎ} ≈\frac{f_{i,j−1}+f_{i,j+1}−2f_{i,j}}{ℎ^2} 
$$</p>
<table><thead><tr><th>$$∆f_{i,j}=\frac{∂^2f_{i,j}}{∂x^2}+\frac{∂^2f_{i,j}}{∂y^2}≈\frac{f_{i−1,j}+f_{i+1,j}+f_{i,j−1}+f_{i,j+1−4}f_{i,j}}{ℎ^2} $$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 网格上的Laplace算子。</p>
</blockquote>
<p>P9</p>
<h3 id="boundary-conditions-1"><a class="header" href="#boundary-conditions-1">Boundary Conditions</a></h3>
<p>The boundary condition specifies \(f_{i−1,j}\) if it’s outside.</p>
<p><img src="./assets/11-5.png" alt="" /></p>
<p>A <strong>Dirichlet</strong> boundary: \(f_{i−1,j}=C\)</p>
<table><thead><tr><th>$$ ∆f_{i,j}≈\frac{C+f_{i+1,j}+f_{i,j−1}+f_{i,j+1}−4f_{i,j}}{ℎ^2}$$</th></tr></thead><tbody>
</tbody></table>
<p>A <strong>Neumann</strong> boundary: \(f_{i−1,j}=f_{i,j}\)</p>
<table><thead><tr><th>$$∆f_ {i,j} ≈ \frac{f_ {i+1,j}+f_ {i,j−1}+f_ {i,j+1}−3f_{i,j}}{ℎ^2}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 至少有一个边界使用Dirithlet．否则会全部收缩为0．<br />
✅ Neumann是约束相对关系，没有绝对数值，会有无穷多解。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P14</p>
<ul>
<li><strong>Intuitively</strong>, they represent the flow speed between two cells. For example, we write the volume changing speed at cell (i,j) as:</li>
</ul>
<table><thead><tr><th>$$u_{i+1,j}+v_{i,j+1}−u_{i,j}−v_{i,j}$$</th></tr></thead><tbody>
</tbody></table>
<blockquote>
<p>✅ 通过四面墙上的速度计算当前格子的净流出（注意正负号）</p>
</blockquote>
<p>P15</p>
<h3 id="divergence-free-condition"><a class="header" href="#divergence-free-condition">Divergence-Free Condition</a></h3>
<p>No volume change is equal to say the fluid is incompressible. This can be formally written as a divergence-free velocity field.</p>
<blockquote>
<p>✅ 由于流体不可压，当有流出时，就会产生使等量流入反生的内力。反之亦然。导致最终的趋势是净流入流出为0。</p>
</blockquote>
<p><img src="./assets/11-8-1.png" alt="" /></p>
<blockquote>
<p>✅ \(\nabla\)为散度符号，见前面课程。<br />
✅ 公式1为直观理解，公式2为数学推导，本质上是一致的。</p>
</blockquote>
<p>P16</p>
<h2 id="bilinear-interpolation"><a class="header" href="#bilinear-interpolation">Bilinear Interpolation</a></h2>
<p>通过微分和差分，可以计算特定点位置的物理属性。再通过插值，计算出任意位置的物理属性。</p>
<p>P17</p>
<p><img src="./assets/11-8-2.png" alt="" /></p>
<blockquote>
<p>🔎 双线性插值：见GAMES 101</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P18</p>
<h1 id="incompressible-viscous--navier-stokes-equations"><a class="header" href="#incompressible-viscous--navier-stokes-equations">Incompressible, Viscous  Navier-Stokes Equations</a></h1>
<h2 id="材料导数"><a class="header" href="#材料导数">材料导数</a></h2>
<p><strong>材料导数就是“流体微团所经历的真实变化率”</strong>，它是将牛顿第二定律应用于流动流体时自然出现的关键算子，是连接流体力学中欧拉描述与拉格朗日描述的桥梁。</p>
<p>$$
\frac{D\phi}{Dt} = \underbrace{\frac{\partial \phi}{\partial t}} _ {\text{局部导数}} + \underbrace{(\mathbf{u} \cdot \nabla) \phi} _ {\text{对流导数}}
$$</p>
<ul>
<li><strong>∂φ/∂t</strong>：<strong>局部导数</strong>。固定点，随时间的变化。</li>
<li><strong>(u · ∇)φ</strong>：<strong>对流导数</strong>。固定时间，随空间运动的变化。速度 <strong>u</strong> 越大，或者物理量梯度 ∇φ 越大，这项贡献就越大。</li>
<li></li>
</ul>
<h3 id="局部导数"><a class="header" href="#局部导数"><strong>局部导数</strong></a></h3>
<p>在<strong>空间某个固定点</strong>上，物理量随时间的变化率。它只反映流场在<strong>该点</strong>的不定常性。数学上就是偏导数 ∂/∂t。</p>
<p><strong>例子</strong>：你坐在河岸边一个固定的岩石上，测量河水温度。如果温度计读数随时间增加，那是因为流经该点的水本身在变热（比如太阳照射），这就是局部温度变化。</p>
<h3 id="对流导数"><a class="header" href="#对流导数"><strong>对流导数</strong></a></h3>
<p>由于流体微团<strong>运动到流场中不同位置</strong>，而该位置物理量的空间分布不均匀，导致微团自身属性发生的变化。它反映了流场的<strong>空间不均匀性</strong>和微团的<strong>运动速度</strong>。</p>
<p><strong>例子</strong>：你坐在一艘随河水漂流的小船上，手里拿着温度计。即使河水在每一点的温度不随时间变化（定常流），但如果你从冰冷的山区漂到温暖的下游，你测得的温度也会上升。这个变化就是因为你（流体微团）移动到了温度不同的地方。</p>
<p><strong>材料导数就是这两种变化的总和</strong>。</p>
<p>P19</p>
<p>NS方程有很多变种，这是其中一种</p>
<p>材料导数定义：<br />
$$
\frac{D\boldsymbol{u}}{Dt} = \frac{\partial\boldsymbol{u}}{\partial t} + \boldsymbol{u} \cdot \nabla\boldsymbol{u}
$$</p>
<p>NS方程：</p>
<p>$$
\rho\frac{D\boldsymbol{u}}{Dt} = -\nabla p + \mu\Delta\boldsymbol{u} + \boldsymbol{f}
$$</p>
<h2 id="ns-equation-fomulation"><a class="header" href="#ns-equation-fomulation">NS Equation Fomulation</a></h2>
<p>合并材料导数公式与 NS 方程，得：</p>
<p><img src="./assets/11-9-1.png" alt="" /></p>
<blockquote>
<p>✅ 这是一个描述了速度场的公式，它可以告许你速度如何更新。<br />
✅ 第一项代表重力。有时也把所有的外力统一表达为 \(g\).<br />
✅ 第二项 advection 描述速度的流动。<br />
✅ 第三项 diffusion 的目的是粘滞。\(\Delta\) 不是指增量，而是指 Laplace.<br />
✅ 第四项限制流体不可压。</p>
</blockquote>
<p>Method of Characteristics: solving a long partial differential equation (PDE) in steps</p>
<ul>
<li>Step 1: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=\mathbf{g}\)</li>
<li>Step 2: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−(\mathbf{u}\cdot ∇)\mathbf{u}\)</li>
<li>Step 3: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=υ∆\mathbf{u}\)</li>
<li>Step 4: Update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−\frac{1}{\rho} ∇\mathbf{p}\)</li>
</ul>
<blockquote>
<p>✅ Operator splitting：把偏微分方程分解几个小块，依次轮流优化每一小块。</p>
</blockquote>
<p>P20</p>
<h2 id="step-1-external-acceleration"><a class="header" href="#step-1-external-acceleration">Step 1: External Acceleration</a></h2>
<p>The Update of \(\mathbf{u}\) by \(∂\mathbf{u}∕∂t=\mathbf{g}\) is straightforward, just add acceleration to \(u\) and \(v\).</p>
<p><img src="./assets/11-10.png" alt="" /></p>
<blockquote>
<p>✅ \(v_{i,j}\)代表向下的速度，对所有格子更新\(v_{i,j}\).<br />
✅ 其它外部速度同理。</p>
</blockquote>
<p>P21</p>
<h2 id="step-2-advection"><a class="header" href="#step-2-advection">Step 2: Advection</a></h2>
<blockquote>
<p>✅  Advection,代表流动。即速度会跟着粒子移动，基于欧拉的方法才需要考虑这个问题。因为固定的格子无法描述水的流动。<br />
✅ 基于拉格朗日的方法，变量定义在粒子上，天然满足这个特点。</p>
</blockquote>
<h3 id="方法一数学模型"><a class="header" href="#方法一数学模型">方法一：数学模型</a></h3>
<p>Next we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−(\mathbf{u}\cdot ∇)\mathbf{u}\).</p>
<p><img src="./assets/11-11.png" alt="" /></p>
<table><thead><tr><th>$$(\mathbf{u} \cdot ∇)\mathbf{u} =u\cdot \frac{∂u}{∂x} +v\cdot \frac{∂v}{∂\mathbf{y}} $$</th></tr></thead><tbody>
</tbody></table>
<p>Solving this in an Eulerian way can be a source of instability.</p>
<blockquote>
<p>✅ Eulerian way： \(\mathbf{u}^{\mathrm{new} }=\frac{\partial u}{\partial t} ·Δt＋\mathbf{u}\) 不稳定<br />
✅ 由当前状态计算下一刻的速度，显式积分。</p>
</blockquote>
<p>To solve this problem, we come to realize that advection means to carry physical quantities by velocity.</p>
<p>P22</p>
<h3 id="方法二-semi-lagrangian-method"><a class="header" href="#方法二-semi-lagrangian-method">方法二: Semi-Lagrangian Method</a></h3>
<p>The solution is to trace a virtual particle backward over time.<br />
特点：非常稳定，但数值粘性非常高。</p>
<blockquote>
<p>✅ 做模拟通常更在乎稳定而不是误差，此方法更稳定，但会有模糊的 artifacts.<br />
✅ 例如要求\(\mathbf{x}_0\)的速度，倒推哪个粒子会运动到\(\mathbf{x}_0\)处；假设短时间内速度不变，根据当前速度猜测上一帧的位置。因此找到\(\mathbf{x}_1\)，用\(\mathbf{x}_1\)的速度来更新\(\mathbf{x}_0\)的速度。<br />
✅ 怎么计算每个\(\mathbf{x}\)的\(\mathbf{u}\)?答：双线性插值方法、</p>
</blockquote>
<p><img src="./assets/11-12.png" alt="" /></p>
<ul>
<li>
<p>Define \(\mathbf{x}_0←(i−0.5, j)\)</p>
</li>
<li>
<p>Compute \(\mathbf{u}(\mathbf{x}_0)\)</p>
</li>
<li>
<p>\(\mathbf{x}_1←\mathbf{x}_0−∆t \mathbf{u}(\mathbf{x}_0)\)</p>
</li>
<li>
<p>Compute \(\mathbf{u}(\mathbf{x}_1)\) 双线性插值</p>
</li>
<li>
<p>\(u_{i,j}^{new}←u(\mathbf{x}_1)\)</p>
</li>
</ul>
<p>\(\mathbf{u}\) 和 \(u\) 都是表达某个点的速度，它们的区别在于：<br />
\(\mathbf{u}\) 描述空间点 \(\mathbf{x}\) 的速度，是 2D 速度，是通过相邻格子插值得来的。<br />
\(u\) 描述空间点 \(\mathbf{x}\) 在水平方向上的速度，是 1D 的。向左或向右，由于 \(\mathbf{x}_0\) 定义在竖直墙上，所以只取水平方向的速度。</p>
<p>Note that if the velocities are staggered, we need to do staggered bilinear interpolation.</p>
<p>P23</p>
<blockquote>
<p>✅ 对每个墙上的速度都以相同的方式更新。</p>
</blockquote>
<p>直接向前推一个时间步来取 \(\mathbf{x}_1\) 的位置，可能是非常不准的，用这个 \(\mathbf{x}_1\) 的速度作为 \(\mathbf{x}\) 的速度也很不合适。</p>
<p><img src="./assets/11-13-1.png" alt="" /></p>
<p>因此衍伸出不同的方法来确定 \(\mathbf{x}_1\) 位置及 \(\mathbf{x}\) 速度。</p>
<p>这是一个 Initial value problem (ODE)，以下是显式时间积分的方法：</p>
<ol>
<li>Forward Euler (&quot;RK1&quot;)</li>
</ol>
<pre><code class="language-c++">p -= dt * velocity(p)
</code></pre>
<p>即上文提到的方法</p>
<ol start="2">
<li>Explicit Midpoint (&quot;RK2&quot;)</li>
</ol>
<pre><code class="language-c++">p_mid = p - 0.5 * dt * velocity(p)
p -= dt * velocity(p_mid)
</code></pre>
<ol start="3">
<li>RK3</li>
</ol>
<pre><code class="language-c++">v1 = velocity(p)
p1 = p - 0.5 * dt * v1
v2 = velocity(p1)
p2 = p - 0.75 * dt * v2
v3 = velocity(p2)
p -= dt * (2 / 9 * v1 + 1 / 3 * v2 + 4 / 9 * v3)
</code></pre>
<p>一般RK2就够用了。</p>
<p>P24</p>
<ol start="4">
<li>We could also subdivided the time step for better tracing.</li>
</ol>
<blockquote>
<p>✅ 反推找\(\mathbf{x}_1\)时 step 细一点，这样能找得准一点</p>
</blockquote>
<p><img src="./assets/11-14.png" alt="" /></p>
<h3 id="方法三bfecc"><a class="header" href="#方法三bfecc">方法三：BFECC</a></h3>
<p>方法二中多次使用双线性插值，导致结果变糊(表现在流体上就是看上去很粘)</p>
<p>BFECC: Back and Forth Error Compensation and Correction</p>
<ul>
<li>\(\mathbf{x}^* = \text{SL}(\mathbf{x}, \Delta t)\)</li>
<li>\( \mathbf{x}^{** }= \text{SL} ( \mathbf{x} ^ {*}, -\Delta t) \)</li>
<li>Estimate the error \(\mathbf{x}^{\text{error}} = \frac{1}{2}(\mathbf{x}^{**} - \mathbf{x})\)</li>
<li>Apply the error \(x^{\text{final}} = \mathbf{x}^* + \mathbf{x}^{\text{error}}\)</li>
</ul>
<p>公式中的 SL 代表方法二</p>
<p>Be careful: need to prevent overshooting，因此方法之后要接 error 的截断保护</p>
<h3 id="其它方法"><a class="header" href="#其它方法">其它方法</a></h3>
<p>结合粒子的方法</p>
<p>P25</p>
<h2 id="step-3-diffusion"><a class="header" href="#step-3-diffusion">Step 3: Diffusion</a></h2>
<p>Next we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=\upsilon ∆\mathbf{u}\).</p>
<p>根据公式更新即可。</p>
<p><img src="./assets/11-15-1.png" alt="" /></p>
<blockquote>
<p>✅ 分别对\(u\)和 \(v\) 做 laplacian.<br />
✅ 注意公式中\(v\)和\(\nu \)的不同，后者为粘滞系数。</p>
</blockquote>
<p>The process of applying Laplacian smoothing is called <strong>diffusion</strong>.</p>
<blockquote>
<p>✅ Laplace的本质是与邻居做平均。</p>
</blockquote>
<p>We could also use even smaller sub-steps…</p>
<p>P27</p>
<h2 id="step-4-pressure-projection"><a class="header" href="#step-4-pressure-projection">Step 4: Pressure Projection</a></h2>
<p>通过压强实现散度为0(流体不可压)的效果。</p>
<p>Finally, we need to update \(\mathbf{u}\) by solving \(∂\mathbf{u}∕∂t=−∇\mathbf{p}\). </p>
<h3 id="公式推导法"><a class="header" href="#公式推导法">公式推导法</a></h3>
<p>$$
u^{new} = u - \Delta t \nabla p
$$</p>
<p>两边同时应用\(\nabla\)算子，得：</p>
<p>$$
\nabla \cdot u^{new} = \nabla \cdot u - \Delta t \nabla \cdot \nabla p
$$</p>
<p>考虑不可压约束 \(\nabla \cdot u^{new}=0\)，得：</p>
<p>$$
\nabla \cdot \nabla p = \frac{1}{\Delta t} \nabla \cdot u
$$</p>
<p>即Poisson's Equation.<br />
离散化得：</p>
<p>$$
4p_{i,j}−p_{i−1,j}−p_{i+1,j}−p_{i,j−1}−p_{i,j+1}= \\
\\
ℎ(−u_{i+1,j}−v_{i,j+1}+u_{i,j}+v_{i,j})
$$</p>
<h3 id="直观理解法"><a class="header" href="#直观理解法">直观理解法</a></h3>
<p><img src="./assets/11-16.png" alt="" /></p>
<p>同样在墙上定义带方向的压强</p>
<p>Staggering makes this very straightforward:</p>
<p>$$
u_{i,j}^{new}←u_{i,j}−\frac{∆t}{ℎ}(p_{i,j}−p_{i−1,j})
$$</p>
<p>$$
v_{i,j}^{new}←v_{i,j}−\frac{∆t}{ℎ}(p_{i,j}−p_{i,j−1})
$$</p>
<blockquote>
<p>✅ \(u\)和\(v\)分别为两个方向上的速度。</p>
</blockquote>
<p>But what is \(\mathbf{p}\)?</p>
<p>P28</p>
<h3 id="压强的来源流体不可压"><a class="header" href="#压强的来源流体不可压">压强的来源：流体不可压</a></h3>
<p>The pressure is caused by incompressibility.</p>
<blockquote>
<p>✅ 压强的原因：由于流体不可压缩、对于流体的压力会传导到每个点上。<br />
✅ 每个点都有压强，虽然压强未知，但可以根据不可压条件构造方程组。<br />
✅ 不可压的表现为有压强，产生的效果是散度为0．</p>
</blockquote>
<p>In other words, after this update by pressure, we should achieve:</p>
<table><thead><tr><th>$$∇\cdot \mathbf{u}^{new}=0$$</th></tr></thead><tbody>
</tbody></table>
<p>which means</p>
<table><thead><tr><th>$$u_{i+,j}^{new}+v_{i,j+1}^{new}−u_{i,j}^{new}−v_{i,j}^{new}=0$$</th></tr></thead><tbody>
</tbody></table>
<p>$$
\Downarrow
$$</p>
<table><thead><tr><th>$$ \begin{matrix}u_{i+1,j}−\frac{(p_{i+1,j} − p_{i,j})}{ℎ}+v_{i,j+1}−\frac{(p_{i,j+1}−p_{i,j})}{ℎ} \\−u_{i,j}−\frac{(p_{i,j} − p_{i−1,j})}{ℎ} −v_{i,j}−\frac{(p_{i,j}−p_{i,j−1})}{ℎ}=0 \end{matrix}$$</th></tr></thead><tbody>
</tbody></table>
<p>P29</p>
<p>The pressure is caused by incompressibility. Eventually, we get a Poisson equation:</p>
<p>$$
4p_{i,j}−p_{i−1,j}−p_{i+1,j}−p_{i,j−1}−p_{i,j+1}= \\
\\
ℎ(−u_{i+1,j}−v_{i,j+1}+u_{i,j}+v_{i,j})
$$</p>
<p>with boundary conditions:</p>
<p>$$ \text{Dirichlet boundary (open) } p_{i−1,j}=P \\
\text{Neumann boundary (close) } p_{i−1,j}=p_{i,j}$$</p>
<p>Once we solve \(\mathbf{p}\), we update \(\mathbf{u}\) and done.</p>
<p>P30</p>
<h2 id="after-class-reading-7"><a class="header" href="#after-class-reading-7">After-Class Reading</a></h2>
<p>Jos Stam. 1999. <em>Stable Fluids. TOG (SIGGRAPH)</em>.</p>
<blockquote>
<p>✅ 这篇论文主要讨论了step2，但也包含了全部过程</p>
</blockquote>
<h3 id="求解压强-p"><a class="header" href="#求解压强-p">求解压强 \(p\)</a></h3>
<p>Poisson's Equation 构成了一个巨大的线性系统</p>
<p>$$
A_x = b
$$</p>
<p>其中 \(A\) 为 \(p\) 的系数构成的矩阵，\(x\) 为未知量 \(p\)，\(b\) 为已知量 \(u\)</p>
<h3 id="压强-laplacian-算子的离散化"><a class="header" href="#压强-laplacian-算子的离散化">压强 Laplacian 算子的离散化</a></h3>
<p><img src="./assets/11-16-1.png" alt="" /></p>
<p>$$
(\nabla \cdot \nabla p) _ {i,j} = \frac{1}{\Delta x^2}(-4p _ {i,j} + p _ {i+1,j} + p _ {i-1,j} + p_{i,j-1} + p_{i,j+1})
$$</p>
<h3 id="解泊松方程"><a class="header" href="#解泊松方程">解泊松方程</a></h3>
<p>\(A\) 的特点：稀疏、对称、正定<br />
Krylov-Subspace solvers：conjugate gradients + damped Jacobi smoothing + PARDISO</p>
<p>$$
\mathbf{r}_0 = \mathbf{b} - \mathbf{A} \mathbf{x}_0
$$</p>
<p>$$
\mathbf{p}_0 = \mathbf{r}_0
$$</p>
<p>$$
\mathbf{k} = 0
$$</p>
<p>while True:<br />
$$
\alpha_k = \frac{\mathbf{r}_k^T \mathbf{r}_k}{\mathbf{p}_k^T \mathbf{A} \mathbf{p}_k}
$$</p>
<p>$$
\mathbf{x}_{k+1} = \mathbf{x}_k + \alpha_k \mathbf{p}_k
$$</p>
<p>$$
\mathbf{r}_{k+1} = \mathbf{r}_k - \alpha_k \mathbf{A} \mathbf{p}_k
$$</p>
<p>if \(||\mathbf{r}_{k+1}||\) is sufficiently small, break</p>
<p>$$
\beta_k = \frac{\mathbf{r} _ {k+1}^T \mathbf{r} _ {k+1}}{\mathbf{r} _ k ^ T \mathbf{r} _ k}
$$</p>
<p>$$
\mathbf{p} _ {k+1} = \mathbf{r} _ {k+1} + \beta_k \mathbf{p} _ k
$$</p>
<p>$$
k = k + 1
$$ </p>
<p>return \(\mathbf{x}_{k+1}\)</p>
<p>\(A\) 的 condition 数越大，迭代法收敛越慢<br />
让 condition 更小的方法：把问题变为</p>
<p>$$
M^{-1}Ax = M^{-1}b
$$</p>
<p>\(M\) 是一个与 \(A\) 近似但易于求逆的矩阵</p>
<h4 id="multigrid-求-m"><a class="header" href="#multigrid-求-m">Multigrid 求 M</a></h4>
<p><img src="./assets/11-16-2.png" alt="" /></p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P31</p>
<h1 id="air-and-smoke"><a class="header" href="#air-and-smoke">Air and Smoke</a></h1>
<blockquote>
<p>✅ 前面讲的是怎么更新速度；后面讲怎么利用速度做出效果。 </p>
</blockquote>
<ul>
<li>To simulate air and water, we need to advect some physical quantities.
<ul>
<li>Smoke (density); water (volume-of-fluid, or signed distance  function)</li>
<li><strong>Volume loss</strong> issue in water (how to fix it?)</li>
<li>If you need to create a mesh from grid for rendering, you need something like <u>marching cube</u>.</li>
</ul>
</li>
</ul>
<p>P32</p>
<h2 id="air-simulation"><a class="header" href="#air-simulation">Air Simulation</a></h2>
<ul>
<li>Air simulation is done in two steps.</li>
<li>In Step 1, we update the flow (the velocity field) \(\mathbf{u}\).</li>
<li>In Step 2, we use semi-Lagrangian (page 22) advect all of the other physical quantities, i.e., density, temperature…</li>
<li>Typically we use Dirichlet boundaries for an open space (or Neumann boundaries for a container.)</li>
<li>We can use it to simulate underwater as well.</li>
</ul>
<p>P33</p>
<h2 id="water-simulation"><a class="header" href="#water-simulation">Water Simulation</a></h2>
<blockquote>
<p>✅ 要渲染的不是水，而是水与空气的接触面。但通常只模拟水不模拟空气。</p>
</blockquote>
<ul>
<li>
<p>Two representations</p>
<ul>
<li>Volume-of-fluid (as the name suggests…)</li>
</ul>
<blockquote>
<p>✅ 表示1：例如一个格子存储水的体积的百分化。用于早期，无法描述水的界面，因此不精准。</p>
</blockquote>
<ul>
<li>A signed distance function defined over the grid.</li>
</ul>
<blockquote>
<p>❓ 怎么计算一个格子中的水的百分比？</p>
</blockquote>
</li>
<li>
<p>How to advect(更新)?</p>
<ul>
<li>Semi-Lagrangian (volume loss)</li>
<li>Level set method (volume loss)，专用于 SDF 表示方法</li>
</ul>
<blockquote>
<p>✅ 水变少是常见问题，两种advect都存在。</p>
</blockquote>
</li>
</ul>
<p>P35</p>
<h3 id="after-class-reading-8"><a class="header" href="#after-class-reading-8">After-Class Reading</a></h3>
<p>Osher and Fedkiw.<br />
Level Set Methods and Dynamic Implicit Surfaces.</p>
<blockquote>
<p>✅ 介绍流体模拟的很好的书。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P36</p>
<h2 id="a-summary-for-the-day-5"><a class="header" href="#a-summary-for-the-day-5">A Summary For the Day</a></h2>
<ul>
<li>
<p>The <strong>Eulerian grid</strong> presentation is very friendly with finite <strong>differencing</strong>. This makes calculus a lot easier.</p>
</li>
<li>
<p>For <strong>velocity</strong> fields, we can use <strong>staggered grid</strong>.</p>
</li>
<li>
<p>For low-speed, incompressible, viscous flow, we need to solve the Navier-Stokes equations.</p>
</li>
<li>
<p>To solve the equations, we can do this in step-by-step (method of characteristics). </p>
</li>
</ul>
<blockquote>
<p>✅ 用有限元方法也能模拟水，但难以模拟流动性。流动需要对四面体重新构造，成本很高。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signed-distance-function"><a class="header" href="#signed-distance-function">Signed Distance Function</a></h1>
<p>A <u>signed</u> distance function \(\phi (\mathbf{x} )\) defines the distance from \(\mathbf{x}\) to a surface with a sign. The sign indicates on which side \(\mathbf{x}\) is located.</p>
<p><img src="./assets/04-6.png" alt="" /></p>
<p>P12</p>
<h2 id="signed-distance-function-examples"><a class="header" href="#signed-distance-function-examples">Signed Distance Function Examples</a></h2>
<p><img src="./assets/04-07.png" alt="" /></p>
<blockquote>
<p>✅ 圆柱SDF基于勾股定理，\(\sqrt{\cdot }\) 内第一项为斜边长，
第二项为底边长，得出点到中轴的距离。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="two-types-of-simulation-approaches"><a class="header" href="#two-types-of-simulation-approaches">Two Types of Simulation Approaches</a></h1>
<p>数值模拟方法可分为拉格朗日方法和欧拉方法两大类。</p>
<table><thead><tr><th>Lagrangian Approach</th><th>Eulerian Approach</th></tr></thead><tbody>
<tr><td><img src="ParticleGrid/../assets/10-1.png" alt="" /></td><td><img src="ParticleGrid/../assets/10-2.png" alt="" /></td></tr>
<tr><td>✅ 无 Grid. 物理量附加在粒子上，粒子运动时更新自身物理量。</td><td>✅ 固定 Grid. 物理量固定在 Grid 上。粒子运动后统一新格子的物理量。</td></tr>
<tr><td>拉格朗日法中计算网格随物质一起变形，可方便地跟踪材料界面和引入与变形历史相关的材料模型，但对于涉及特大变形的问题会因网格严重畸变而产生数值求解困难，且难以有效地模拟材料的破碎、融化和汽化等行为。此类方法代表性程序为DYAN。</td><td>欧拉法中计算网格固定在空间中，不存网格畸变问题，但不易跟踪材料界面，且非线性对流项也会导致数值求解困难。</td></tr>
</tbody></table>
<h1 id="粒子法与网格法的结合"><a class="header" href="#粒子法与网格法的结合">粒子法与网格法的结合</a></h1>
<p>$$
\frac{D}{Dt} = \frac{\partial}{\partial t} + U \cdot \nabla
$$</p>
<p>这个公式将欧拉法与拉格朗日法联系在一起 \(\frac{\partial}{\partial t}\) 代表固定点物理属性随时间的变化。<br />
\(\frac{D}{Dt}\) 代表流动粒子的物理属性随时间的变化。<br />
\(U \cdot \nabla\) 代表物理属性随位置的变化。</p>
<p>欧拉网格上的物理属性基于 \(\frac{\partial}{\partial t}\) 更新。
拉格朗日粒子上的物理属性基于 \(\frac{D}{Dt}\) 更新。</p>
<h3 id="motivation"><a class="header" href="#motivation">Motivation</a></h3>
<ul>
<li><strong>Recall that a fluid solver usually has two components</strong>:
<ul>
<li><strong><u>Advection</u></strong> (evolving the fields)</li>
<li><strong><u>Projection</u></strong> (enforcing incompressibility)</li>
</ul>
</li>
<li><strong>Eulerian grids are really good at projection</strong>:
<ul>
<li>Easy to discretize</li>
<li>Efficient neighbor look-up</li>
<li>Easy to precondition (geometric multigrid)</li>
</ul>
</li>
<li><strong>But Eulerian grids are bad at advection...</strong>
<ul>
<li>Dissipative: loss of energy and geometry</li>
</ul>
</li>
</ul>
<h2 id="常见方法"><a class="header" href="#常见方法">常见方法</a></h2>
<p><img src="ParticleGrid/../assets/10-2-1.png" alt="" /> </p>
<h2 id="发展趋势"><a class="header" href="#发展趋势"><strong>发展趋势</strong></a></h2>
<ol>
<li><strong>多尺度耦合</strong>：如量子-分子动力学-连续体的跨尺度模拟。</li>
<li><strong>机器学习加速</strong>：用神经网络替代部分网格求解或粒子交互。</li>
<li><strong>高性能计算优化</strong>：针对GPU/异构计算设计混合算法。</li>
</ol>
<h1 id="reference-3"><a class="header" href="#reference-3">Reference</a></h1>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>解决了什么痛点</th><th>主要贡献是什么</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2005</td><td>Animating sand as a fluid</td><td>将FLIP方法应用于不可压缩流模拟。这使混合流体模拟达到了新的高度，得以以更高的精度和稳定性探索复杂的流体动力学。</td><td></td><td></td><td></td></tr>
<tr><td></td><td>1999</td><td>Stable fluids</td><td>该方法最终使得稳定的、三维的、基于物理的流体仿真成为可实现的目标，并能生成逼真的流体效果。这是首个无条件稳定的流体仿真方法，引入了半拉格朗日平流的概念，也是该领域最早应用混合仿真思路的研究之一。</td><td></td><td>里程碑</td><td></td></tr>
<tr><td></td><td>1986</td><td>FLIP: A method for adaptively zoned, particle-in-cell calculations of fluid flows in two dimensions. Journal of Computational Physics Vol</td><td><strong>流体隐式粒子法</strong></td><td></td><td></td><td></td></tr>
<tr><td></td><td>1962</td><td>The particle-in-cell method for numerical solution of problems in fluid dynamics.</td><td><strong>质点网格法</strong></td><td></td><td></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="粒子-网格法particle-in-cell-pic"><a class="header" href="#粒子-网格法particle-in-cell-pic"><strong>粒子-网格法（Particle-in-Cell, PIC）</strong></a></h1>
<h2 id="原理-3"><a class="header" href="#原理-3"><strong>原理</strong></a></h2>
<ul>
<li><strong>原理</strong>：在流体模拟中结合粒子和网格，粒子携带速度等信息，网格用于求解压力泊松方程（实现不可压缩性）。</li>
</ul>
<h2 id="步骤"><a class="header" href="#步骤"><strong>步骤</strong>：</a></h2>
<p><img src="ParticleGrid/../assets/10-2-22.png" alt="" /> </p>
<h3 id="粒子到网格插值"><a class="header" href="#粒子到网格插值"><strong>粒子到网格插值</strong>：</a></h3>
<p>粒子属性与网格属性是分别用两种不同的载体来描述同一物理量。</p>
<p>将粒子的质量、电荷等属性分配到邻近网格节点。</p>
<p>分配时，距离近的点有更大的权重</p>
<p><img src="ParticleGrid/../assets/10-2-2.png" alt="" /> </p>
<p>权重由核函和数定义</p>
<p><img src="ParticleGrid/../assets/10-2-3.png" alt="" /> </p>
<h3 id="网格上求解场方程"><a class="header" href="#网格上求解场方程"><strong>网格上求解场方程</strong>：</a></h3>
<ol>
<li>施加外力</li>
<li>在网格上求解泊松方程（静电场）或麦克斯韦方程（电磁场）等。
在 Grid 上解 presure，得到无散速度场</li>
<li>处理边界</li>
</ol>
<h3 id="网格到场插值"><a class="header" href="#网格到场插值"><strong>网格到场插值</strong>：</a></h3>
<p>将网格节点上的场量(例如无散速度场)插值回粒子位置，更新粒子状态。</p>
<p><img src="ParticleGrid/../assets/10-2-4.png" alt="" /> </p>
<h3 id="粒子推进"><a class="header" href="#粒子推进"><strong>粒子推进</strong>：</a></h3>
<p>根据牛顿定律更新粒子位置和速度。</p>
<p>可以是不同的积分法</p>
<h2 id="应用-1"><a class="header" href="#应用-1"><strong>应用</strong>：</a></h2>
<p>等离子体模拟、天体物理（N体+网格）、流体模拟（如物质点法MPM）。</p>
<h2 id="缺点"><a class="header" href="#缺点">缺点：</a></h2>
<p>能量耗散严重，表现为“黏”。<br />
因为 G2P 过程有信息丢失</p>
<ul>
<li>Two solutions:<br />
1. Transfer more information: APIC, PolyPIC<br />
2. Transfer the <u>delta</u>: FLIP (later in this lecture)</li>
</ul>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="流体隐式粒子法fluid-implicit-particle-flip"><a class="header" href="#流体隐式粒子法fluid-implicit-particle-flip">流体隐式粒子法（Fluid Implicit Particle, FLIP</a></h1>
<h2 id="原理-dont-gather-the-physical-quantity-gather-the-delta-of-the-physical-quantities-beforeafter-grid-operation"><a class="header" href="#原理-dont-gather-the-physical-quantity-gather-the-delta-of-the-physical-quantities-beforeafter-grid-operation">原理: don’t gather the physical quantity. Gather the <u>delta</u> of the physical quantities before/after grid operation.</a></h2>
<h2 id="方法-1"><a class="header" href="#方法-1">方法：</a></h2>
<h3 id="网格更新"><a class="header" href="#网格更新">网格更新</a></h3>
<ul>
<li>grid op = pressure projection in incompressible fluid simulation</li>
<li>grid op = internal force computation in solid simulation (MPM)</li>
</ul>
<h2 id="g2p"><a class="header" href="#g2p">G2P</a></h2>
<p>PIC：\(V_p^{t+1} = \text{gather}(V_i^{t+1})\)<br />
FLIP：\(V_p^{t+1}=V_p^t + \text{gather}(V_i^{t+1}-V_i^t)\)，这会导致粒子速度趋于平均，表现为粒子糊掉，可液体细节消失。</p>
<blockquote>
<p>FLIP 引入了 P2P 的信息路径来避免信息丢失。<br />
但纯 FLIP 会因增量传递而积累误差，所以需要少量PIC进平衡。<br />
FLIP0.99 = 0.99.  FLIP + 0.01PIC</p>
</blockquote>
<ul>
<li><strong>PIC（流体版）</strong>：粒子速度完全由网格插值获得，较稳定但<strong>耗散大</strong>。</li>
<li><strong>FLIP</strong>：粒子<strong>速度变化量</strong>由网格插值，保留更多细节，适合高分辨率模拟。</li>
</ul>
<h2 id="应用计算机图形学中的流体动画如烟雾水"><a class="header" href="#应用计算机图形学中的流体动画如烟雾水">应用：计算机图形学中的流体动画（如烟雾、水）。</a></h2>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mpm"><a class="header" href="#mpm">MPM</a></h1>
<h2 id="原理-4"><a class="header" href="#原理-4"><strong>原理</strong>：</a></h2>
<p>物质点法 (material point method, MPM)采用拉格朗日和欧拉双重描述，将物体离散为一组在空间网格中运动的质点。</p>
<ul>
<li>质点携带了所有的物质信息，如质量、速度、应变和应力等，可很方便地跟踪材料的界面和引入与变形历史相关的材料模型。</li>
<li>质点在空间网格中运动，运动方程在空间网格上求解，避免了网格畸变问题，适合于分析特大变形及流动问题。</li>
</ul>
<h2 id="核心思想"><a class="header" href="#核心思想">核心思想</a></h2>
<p>拉格朗日视角 (粒子)：物质点携带密度、速度、应力等信息，随物质变形运动。<br />
欧拉视角 (背景网格)：划分计算域，用于计算空间导数和物理量更新。<br />
粒子-网格-粒子 (P-G-P)：信息通过物质点映射到网格节点，在网格上计算更新，再插值回物质点，完成一个时间步。</p>
<h2 id="主要特点与优势"><a class="header" href="#主要特点与优势">主要特点与优势</a></h2>
<p>融合拉格朗日与欧拉：兼具拉格朗日法的精确追踪物质界面能力和欧拉法的网格独立性，避免了有限元网格缠绕畸变问题。<br />
处理大变形：能有效模拟材料的超大变形、破碎、断裂等非线性问题。<br />
自动处理多体接触：物质点在网格内运动，自动处理多介质界面，无需复杂的碰撞检测。<br />
适用范围广：适用于高速碰撞、爆炸冲击、岩土动力学、流体与固体相互作用等复杂问题。</p>
<p>但 MPM 在精度上存在劣势。</p>
<h2 id="基本步骤一个时间步"><a class="header" href="#基本步骤一个时间步">基本步骤（一个时间步）</a></h2>
<p><img src="ParticleGrid/../assets/10-2-6.png" alt="" /> </p>
<h3 id="粒子到网格-p2g"><a class="header" href="#粒子到网格-p2g">粒子到网格 (P2G)</a></h3>
<p>将物质点信息（如质量、动量）通过插值函数映射到背景网格节点。</p>
<h3 id="网格计算"><a class="header" href="#网格计算">网格计算</a></h3>
<p>在背景网格上，根据控制方程（如动量守恒）计算节点力、加速度等。</p>
<h3 id="网格到粒子-g2p"><a class="header" href="#网格到粒子-g2p">网格到粒子 (G2P)</a></h3>
<p>将网格上的计算结果（如速度、应力）通过插值函数传回物质点。<br />
（可选）丢弃网格：根据需要重新划分或更新背景网格。</p>
<h3 id="更新粒子"><a class="header" href="#更新粒子">更新粒子</a></h3>
<p>更新物质点的位置、速度和应力状态。</p>
<h2 id="优点-1"><a class="header" href="#优点-1"><strong>优点</strong></a></h2>
<p>避免网格畸变，适合大变形问题（如雪、泥沙、断裂模拟）。</p>
<h2 id="变种"><a class="header" href="#变种"><strong>变种</strong></a></h2>
<ul>
<li><strong>广义插值物质点法（GIMP）</strong>：改进插值函数，减少数值噪声。</li>
<li><strong>CPDI（Convected Particle Domain Interpolation）</strong>：更精确描述粒子变形。</li>
</ul>
<h2 id="应用场景-2"><a class="header" href="#应用场景-2">应用场景</a></h2>
<ol>
<li>可以处理不同材质(流、固等)及它们之间的耦合关系</li>
<li>可以处理碰撞、破碎等效果</li>
<li>擅长摸拟大形变</li>
</ol>
<h2 id="p2g"><a class="header" href="#p2g">P2G</a></h2>
<ol>
<li>粒子的质量、动量、速度等属性，过程同PIC</li>
<li>粒子应力属性 ⟶ 网格力属性<br />
流体/固体受力 ⟶ 变形梯度 F ⟶ 柯西应力张量 σ ⟶ 应力张量散度 ⟶ 粒子时网格的力<br />
力来自应力的空间变化(梯度)，而不是应力本身的空间插值。</li>
</ol>
<h2 id="网格更新-1"><a class="header" href="#网格更新-1">网格更新</a></h2>
<p><img src="ParticleGrid/../assets/10-2-61.png" alt="" /> </p>
<p>只更新网格速度</p>
<h3 id="g2p-1"><a class="header" href="#g2p-1">G2P</a></h3>
<ol>
<li>网格速度插值出粒子速度</li>
<li>更新粒子位置</li>
<li>重新计算粒子的变形梯度/应力<br />
变形梯度F的更新 \(∇N_I(x_P)\)</li>
</ol>
<blockquote>
<p>🔎 Deborah Sulsky, Shi-Jian Zhou, and Howard L Schreyer.
Application of a particle-in-cell method to solid mechanics.</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mls-mpm-移动最小二乘物质点法"><a class="header" href="#mls-mpm-移动最小二乘物质点法">MLS-MPM 移动最小二乘物质点法</a></h1>
<p><img src="ParticleGrid/../assets/10-2-7.png" alt="" /> </p>
<p>Use MLS shape function in MPM</p>
<p><img src="ParticleGrid/../assets/10-2-8.png" alt="" /> </p>
<p>传统MPM将物体离散为携带各类拉格朗日量的粒子，包括位置 \( \mathbf{x}_p \)、速度 \( \mathbf{v}_p \) 和变形梯度 \( \mathbf{F}_p \)。随后通过粒子到欧拉网格的传递操作与网格到粒子的传递操作更新粒子状态。</p>
<ol>
<li>在该方法中，在时间步 \( t^n \) 到 \( t^{n+1} \) 的更新过程中，使用 \( \nabla N_i(\mathbf{x}_p) \)（三维二次B样条核函数需迭代27次）计算网格动量，其中 \( N_i(\mathbf{x}_p) \) 是在第 \( i \) 个网格上定义、并于粒子位置 \( \mathbf{x}_p \) 处取值的B样条核函数。<br />
如果场景包含上万个点，使用传统MPM方法模拟这些点将非常耗时。而MLS-MPM 相较于传统 MPM，加速模拟的同时，显著降低了计算成本。</li>
<li>MPM 存在数值耗散问题，虽引入 Affine 速度场改善，但 A 与 F 不统一。</li>
</ol>
<h2 id="关键步骤"><a class="header" href="#关键步骤">关键步骤</a></h2>
<h3 id="p2g-1"><a class="header" href="#p2g-1">P2G</a></h3>
<p>按 MLS 权重，把离子属性投影到网格。</p>
<p>$$
\frac{m_i^{n+1} \hat{\mathbf{v}}_i^{n+1} - m_i^n \mathbf{v}_i^n}{\Delta t} = m_i^n \mathbf{g} + \mathbf{f}_i^n,
$$</p>
<p>其中，\( m_i^n \) 是第 \( i \) 个网格的质量，\( \mathbf{v}_i^n \) 是第 \( i \) 个网格的速度，\( \mathbf{g} \) 为重力加速度，\( \Delta t \) 是时间步长。此外：</p>
<p>$$
\mathbf{f}_i^n = -\frac{\partial E}{\partial \mathbf{x}_i} = -\sum_p N_i(\mathbf{x}_p^n) V_p^0 \mathbf{W}_p^{-1} \frac{\partial \Psi}{\partial \mathbf{F}}(\mathbf{F}_p^n) \mathbf{F}_p^{nT} (\mathbf{x}_i^n - \mathbf{x}_p^n),
$$</p>
<p>\(f_{ip}\) 为 particle \(p\) 对结点 \(i\) 的力的贡献<br />
这里 \( i \) 与 \( p \) 分别表示欧拉网格场与拉格朗日粒子场。</p>
<p>$$
E = \sum_p V_p^0 \Psi_p(\mathbf{F}_p)
$$</p>
<p>\(E\) 表示系统整体的强性势能。<br />
其中 \( V_p^0 \) 为粒子初始体积，\( \Psi_p \) 是能量密度函数；\( \mathbf{W}_p \) 是 \( \mathbf{x}_p \) 的矩矩阵，对于二次 \( N_i(x) \) 有 \( \mathbf{W}_p = \frac{1}{4} \Delta x^2 \)，对于三次核函数则为 \( \frac{1}{3} \Delta x^2 \)；\( \mathbf{F}_p \) 是从拉格朗日视角观察的粒子变形梯度(Defor mation gradients)，通过 \( \mathbf{F}_p^{n+1} = (\mathbf{I} + \Delta t \mathbf{C}_p^{n+1}) \mathbf{F}_p^n \) 更新，其中 \( \mathbf{C}_p^{n+1} \) 是粒子 \( p \) 的仿射矩阵，是 \(\nabla\nu \) 的近似。</p>
<p>\( \mathbf{F}_p \) 会变化是因为欧拉视角下局部速度场的梯度 (\(\nabla\nu \)) 不为0。</p>
<blockquote>
<p>🔎 Yuanming Hu, Yu Fang, Ziheng Ge, Ziyin Qu, Yixin Zhu, Andre Pradhana, and Chenfanfu Jiang. 2018. A moving least squares material point method with displacement discontinuity and two-way rigid body coupling.</p>
</blockquote>
<h3 id="g2p-2"><a class="header" href="#g2p-2">G2P</a></h3>
<p>无网格插值，用局部粒子的加权最小二乘 (MLS) 拟合连续场。<br />
MLS 可同时拟合值与梯度，得到仿射速度场与变形梯度更新一致的离散。</p>
<h2 id="grid-操作边界条件"><a class="header" href="#grid-操作边界条件">Grid 操作：边界条件</a></h2>
<p><img src="ParticleGrid/../assets/10-2-9.png" alt="" /> </p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>解决了什么痛点</th><th>主要贡献是什么</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td>177</td><td>2025.6.18</td><td>Particle-Grid Neural Dynamics for Learning Deformable Object Models from RGB-D Videos</td><td></td><td></td><td><a href="https://arxiv.org/pdf/2506.15680">link</a></td><td></td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="affine-picapic"><a class="header" href="#affine-picapic">Affine PIC(APIC)</a></h1>
<h2 id="背景"><a class="header" href="#背景">背景</a></h2>
<p>PIC 的 P2G 和 G2P 过程都包含加权平均，导致速度被平均化。平均化表现为数值耗散（糊）和细节丢失（大形变时失真）。<br />
FLIP 算法改为传递速度增量，解决平均化问题，但引入振荡问题。</p>
<h2 id="apic-核心创新"><a class="header" href="#apic-核心创新">APIC 核心创新</a></h2>
<p>每个粒子维护一个额外的属性 \(A \in R^{2\times 2}\) 或 \(A \in R^{3\times 3}\), A 用于记录粒子周围的 Affine 速度场,可以描述粒子所在局部区域的速度梯度。</p>
<p>A 仅在G2P这一步被计算和使用。</p>
<p><img src="ParticleGrid/../assets/10-2-99.png" alt="" /> </p>
<p>pressure projection 一般是指解泊松方程。</p>
<h2 id="基本步骤"><a class="header" href="#基本步骤">基本步骤</a></h2>
<h3 id="g2p-3"><a class="header" href="#g2p-3">G2P</a></h3>
<ol>
<li>计算  \(A_p\)</li>
</ol>
<p>$$
A_p = \sum_I V_I \otimes \nabla N_I(x_p)
$$</p>
<ol start="2">
<li>根据 \(A_p\) 计算 \(v_p\)</li>
</ol>
<p>$$
v_p = \sum_I N_I(x_p) v_I + A_p(x_p - \bar{x}_p)
$$</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constitutive-models"><a class="header" href="#constitutive-models">Constitutive Models</a></h1>
<ol>
<li>更新变形的梯度</li>
<li>计算 stress<br />
stress 描述这个材料的 particle 怎么对周围的 Grid 施加力</li>
</ol>
<h2 id="应用于弹性体"><a class="header" href="#应用于弹性体">应用于弹性体</a></h2>
<h2 id="应用于流体"><a class="header" href="#应用于流体">应用于流体</a></h2>
<h2 id="应用于塑形体"><a class="header" href="#应用于塑形体">应用于塑形体</a></h2>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多项式粒子网格法-polypic"><a class="header" href="#多项式粒子网格法-polypic">多项式粒子网格法 PolyPIC</a></h1>
<p>APIC 引入的仿射速度是一阶近似。PolyPIC 把速度场近似升级为任意阶多项式。<br />
目的是实现无损功能传输。</p>
<h2 id="关键步骤-1"><a class="header" href="#关键步骤-1">关键步骤</a></h2>
<h3 id="g2p-4"><a class="header" href="#g2p-4">G2P</a></h3>
<p>用多项式拟合局部速度。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h3 id="4-任意拉格朗日-欧拉法arbitrary-lagrangian-eulerian-ale"><a class="header" href="#4-任意拉格朗日-欧拉法arbitrary-lagrangian-eulerian-ale"><strong>4. 任意拉格朗日-欧拉法（Arbitrary Lagrangian-Eulerian, ALE）</strong></a></h3>
<ul>
<li><strong>原理</strong>：网格可随物质运动（拉格朗日）或固定（欧拉），也可任意移动以兼顾两者优点。通常与粒子结合用于处理大变形或界面问题。</li>
<li><strong>结合方式</strong>：在变形过大区域将材料转为粒子，避免网格畸变。</li>
<li><strong>应用</strong>：爆炸、冲击、金属成型等固体力学问题。</li>
</ul>
<hr />
<h3 id="5-耦合粒子-网格法coupled-particle-grid-methods"><a class="header" href="#5-耦合粒子-网格法coupled-particle-grid-methods"><strong>5. 耦合粒子-网格法（Coupled Particle-Grid Methods）</strong></a></h3>
<ul>
<li><strong>离散元法（DEM）与有限元法（FEM）耦合</strong>：
<ul>
<li>颗粒物质（DEM粒子）与连续体（FEM网格）交互，用于模拟颗粒-结构相互作用。</li>
</ul>
</li>
<li><strong>光滑粒子流体动力学（SPH）与网格耦合</strong>：
<ul>
<li>近界面区域用SPH（粒子法），远处用网格法（如FVM），提高计算效率。</li>
</ul>
</li>
</ul>
<hr />
<h3 id="6-其他混合方法"><a class="header" href="#6-其他混合方法"><strong>6. 其他混合方法</strong></a></h3>
<ul>
<li><strong>分子动力学（MD）与连续体耦合</strong>：
<ul>
<li>微观区域用MD（粒子），宏观区域用有限元网格，通过重叠区交换信息。</li>
</ul>
</li>
<li><strong>蒙特卡洛粒子与网格耦合</strong>：
<ul>
<li>在辐射传输、稀薄气体动力学中，粒子跟踪与网格场计算结合。</li>
</ul>
</li>
</ul>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p><img src="ParticleGrid/../assets/10-2-5.png" alt="" /> </p>
<h3 id="选择依据"><a class="header" href="#选择依据"><strong>选择依据</strong></a></h3>
<table><thead><tr><th><strong>方法</strong></th><th><strong>适用领域</strong></th><th><strong>主要优点</strong></th></tr></thead><tbody>
<tr><td><strong>PIC</strong></td><td>等离子体、电磁场</td><td>场求解稳定，粒子自由度灵活</td></tr>
<tr><td><strong>MPM</strong></td><td>固体大变形、多相材料</td><td>避免网格畸变，适合历史相关材料</td></tr>
<tr><td><strong>FLIP/PIC</strong></td><td>不可压缩流体</td><td>细节保留好，适合动画</td></tr>
<tr><td><strong>ALE</strong></td><td>冲击、流固耦合</td><td>自适应网格，兼顾精度与变形</td></tr>
<tr><td><strong>DEM-FEM</strong></td><td>颗粒-结构相互作用</td><td>离散与连续介质自然耦合</td></tr>
</tbody></table>
<pre class="mermaid">flowchart LR
    A[时空采样优化]
    A --&gt; B[时间自适应]
    A --&gt; C[空间自适应]
    B --&gt; D[全局自适应]
    B --&gt; E[局部自适应]
    C --&gt; F[欧拉法]
    C --&gt; G[拉格朗日法]
    C --&gt; H[混合法]
    
</pre>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P11</p>
<h1 id="粒子--sdf"><a class="header" href="#粒子--sdf">粒子 + SDF</a></h1>
<pre class="mermaid">mindmap
粒子SDF仿真
    碰撞检测
        离散相交检测
           
        连续穿透检测
           
    碰撞响应
        相交解除
        状态更新
            Penalty
            Impulse
</pre>
<h1 id="碰撞检测"><a class="header" href="#碰撞检测">碰撞检测</a></h1>
<p>P13</p>
<h2 id="离散相交检测"><a class="header" href="#离散相交检测">离散相交检测</a></h2>
<p>检测粒子是否在 SDF 的内部</p>
<p><img src="./assets/04-8.png" alt="" /></p>
<blockquote>
<p>If \(\phi _0(\mathbf{x} )&lt;0\) and \(\phi_1(\mathbf{x} )&lt;0\) and \(\phi_2(\mathbf{x} )&lt;0\)<br />
then inside<br />
\(\quad \phi (\mathbf{x} )\)=max \(⁡(\phi_0(\mathbf{x}),\phi_1(\mathbf{x}),\phi_2(\mathbf{x}))\)<br />
Else outside<br />
\(\quad \phi (\mathbf{x})=?\)</p>
</blockquote>
<p>P14</p>
<h3 id="union-of-signed-distance-functions"><a class="header" href="#union-of-signed-distance-functions">Union of Signed Distance Functions</a></h3>
<p><img src="./assets/04-9.png" alt="" /></p>
<blockquote>
<p>✅ 有时候此公式不成立，例如图中\(\mathbf{x}\) 点</p>
</blockquote>
<p>Intuitively, we can consider collision detection with the union of two objects as <strong>collision detection with two separate objects</strong>.</p>
<p>P15</p>
<h2 id="穿透检测"><a class="header" href="#穿透检测">穿透检测</a></h2>
<p>$$ \phi (x(t))=0 $$<br />
解出 \(t\)<br />
如果 \(t\) 在所检测的时间范围内有解，则说明存在穿透 \(t\) 为穿透时刻。</p>
<h1 id="粒子碰撞响应"><a class="header" href="#粒子碰撞响应">粒子碰撞响应</a></h1>
<p>SDF 常用于代表静态物体，这种物体不响应力和碰撞，所以所有的碰撞响应都发生在粒子上。</p>
<h2 id="碰撞解除"><a class="header" href="#碰撞解除">碰撞解除</a></h2>
<p>碰撞解除是将粒子移到不发生碰撞的位置上。</p>
<p><img src="./assets/04-17.png" alt="" /></p>
<blockquote>
<p>✅ 更新方向：N方向。更新距离：穿入的距离。即把粒子移动到离它最近的 SDF 的表面上。<br />
✅ 这种解法非常简单，但存在不合理的情况，考虑以场景：粒子从 \(t_k\) 移动到 \(t_{k+1}\)，此时检测到了相交。这种情况下，粒子应退回到发生穿遂时刻的Ⓐ处，而不是离它最近的Ⓑ处。<br />
<img src="./assets/0001.png" alt="" /></p>
</blockquote>
<h2 id="状态更新"><a class="header" href="#状态更新">状态更新</a></h2>
<p>状态更新是更新粒子的速度，使其表现出碰撞后反弹的效果。</p>
<h3 id="penalty-method"><a class="header" href="#penalty-method">Penalty Method</a></h3>
<h4 id="quadratic-penalty-method"><a class="header" href="#quadratic-penalty-method">Quadratic Penalty Method</a></h4>
<p>A penalty method applies a penalty force in the next update. When the penalty potential is quadratic, the force is linear.</p>
<p><img src="./assets/04-11.png" alt="" /></p>
<p><img src="./assets/04-10.png" alt="" /></p>
<p>当粒子进入物体内部后，就会产生一个向外的推力。力的大小与距离有关，方向为normal.粒子的状态由下一步仿真更新。</p>
<p>P16</p>
<blockquote>
<p>✅ 粒子的运动状态发生变化确实是由于力的作用。但对力的大小的假设不合理。<br />
✅ 力的大小确实与穿透深度有关，因为：<br />
✅ 穿透深 → 相对速度大 → 碰撞速度和反弹速度都大 → 速度改变大 → 力大<br />
✅ 力的大小与碰撞深度只是间接的正相交，没有直接的必然性。因此把它们的关系假设为正比关系是不合理的。<br />
✅ 存在的问题：只有\(\mathbf{x}\) 进入 mesh 内部了，才会有力，但此时穿透的 artifacts 已经产生了。解决方法：使用buffer</p>
</blockquote>
<h4 id="quadratic-penalty-method-with-a-buffer"><a class="header" href="#quadratic-penalty-method-with-a-buffer">Quadratic Penalty Method with a Buffer</a></h4>
<p>A buffer helps lessen the penetration issue. But it cannot strictly prevent penetration, no matter how large \(k\) is.</p>
<p><img src="./assets/04-12.png" alt="" /><br />
<img src="./assets/04-13.png" alt="" /></p>
<blockquote>
<p>✅ 存在的问题：<br />
✅ 如果 \(k\) 太小，快速的碰撞仍会产生 artifacts<br />
✅ 如果 \(k\) 太大，碰撞的反弹过于强烈(overshooting)<br />
✅ 解决方法：不用常数 \(k\) ，而是 \(k\) 与距离相关</p>
</blockquote>
<p>P17</p>
<h4 id="log-barrier-penalty-method"><a class="header" href="#log-barrier-penalty-method">Log-Barrier Penalty Method</a></h4>
<p>A log-barrier penalty potential ensures that the force can be large enough. But it assumes \(\phi (\mathbf{x} ) &lt; 0\) will never happen!!! To achieve that, it needs to adjust \(\Delta t\).</p>
<p><img src="./assets/04-15.png" alt="" /></p>
<blockquote>
<p>✅ 用倒数关系代替线性关系。<br />
✅ 存在的问题：<br />
1.当\(\mathbf{x}\) 靠近物体表面时，仍然会 overshooting<br />
2.\(\mathbf{x}\) 穿透表面后，会越陷越深。<br />
3.本算法如果要求保证穿透永远不会发生，因此要仔细调节 \(\Delta t\).</p>
</blockquote>
<ul>
<li>Log-barrier method can be limited within a buffer as well.
<ul>
<li>Li et al. 2020. <em>Incremental Potential Contact: Intersection- and Inversion-free Large Deformation Dynamics</em>. TOG.</li>
<li>Wu et al. 2020. <em>A Safe and Fast Repulsion Method for GPU-based Cloth Self Collisions</em>. TOG.</li>
</ul>
</li>
</ul>
<p>P18</p>
<h4 id="a-short-summary-of-penalty-methods"><a class="header" href="#a-short-summary-of-penalty-methods">A Short Summary of Penalty Methods</a></h4>
<ul>
<li>
<p>The use of step size adjustment is a must.</p>
<ul>
<li>To avoid overshooting.</li>
<li>To avoid penetration in log-barrier methods.</li>
</ul>
</li>
<li>
<p>Frictional contacts are difficult to handle.</p>
</li>
</ul>
<blockquote>
<p>✅ 缺点：<br />
(1) 难以模拟摩擦。<br />
(2) 这种方法一开始所建立的假设基础就是不合理的。再怎么修补也难以避免其 artifacts.<br />
优点：易实现</p>
</blockquote>
<p>P19</p>
<h3 id="impulse-method"><a class="header" href="#impulse-method">Impulse Method</a></h3>
<p>An impulse method assumes that collision changes the position and the velocity all of sudden.</p>
<blockquote>
<p>✅ Penalty 方法是碰撞 → 力 → 下一时刻的速度和位置，效果滞后。<br />
✅ lmpulse 省去了力这一步，立即直接更新刚体状态。<br />
✅ 这不是这两种方法的关键区别，关键区别在于对状态变化规则的假设。</p>
</blockquote>
<p><img src="./assets/04-16.png" alt="" /></p>
<p>P20</p>
<blockquote>
<p>✅ \(\mathbf{v}\cdot \mathbf{N}\ge 0\)：当前速度想要让物体越陷越深, 这种情况下才需要更新速度</p>
</blockquote>
<p><img src="./assets/04-18-1.png" alt="" /></p>
<blockquote>
<p>✅ 把\(\mathbf{v}\)分解为\(\mathbf{v_T}\)（切线方向的速度）和\(\mathbf{v_N}\)（法线方向的速度）.<br />
✅ \(\mathbf{v_N}\)方向速度反弹， \(\mu _\mathbf{N}\) 为反弹系数。\(\mathbf{v_N}\)方向不变或由于摩擦而衰减<br />
✅ a的约束：（1）越小越好，尽量把速度衰减掉（2）满足库仑定律（切方向的速度改变不应大于法线方向的速度改变）（3）切方向速度不能反转，即a不能为负</p>
</blockquote>
<h4 id="impulse方法总结"><a class="header" href="#impulse方法总结">Impulse方法总结</a></h4>
<blockquote>
<p>✅ 优点：可以精确控制摩擦力和反弹位置。缺点：计算比 Penalty 复杂<br />
✅ 刚体常见于 Impulse； 弹性体常见于Penalty.</p>
</blockquote>
<table><thead><tr><th></th><th>速度大小</th><th>速度方向</th></tr></thead><tbody>
<tr><td>Penalty</td><td>碰撞深度-&gt;力的大小</td><td>力的方向+原方向</td></tr>
<tr><td>Impulse</td><td>相对速度 * decay</td><td>反弹方向+惯性方向</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/ </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="粒子与-mesh"><a class="header" href="#粒子与-mesh">粒子与 Mesh</a></h1>
<h1 id="碰撞检测-1"><a class="header" href="#碰撞检测-1">碰撞检测</a></h1>
<h2 id="相交检测"><a class="header" href="#相交检测">相交检测</a></h2>
<p>检测粒子是否在 Mesh 的内部<br />
射线法：粒子从自身出发，发出一条射线，判断射线是与 Mesh 上的面片相交。<br />
相交次数为奇数，则在 Mesh 内<br />
相交次数为偶数，则在 Mesh 外<br />
如果 Mesh 为凸，Mesh 上所有面片的顶点的顺序正确，即仅通法面片方向就能判断内外，那么检测方法要容易得多。</p>
<h2 id="穿透检测-1"><a class="header" href="#穿透检测-1">穿透检测</a></h2>
<p>P24</p>
<h2 id="example-11-particle-triangle-intersection"><a class="header" href="#example-11-particle-triangle-intersection">Example 11: Particle-triangle Intersection</a></h2>
<p><img src="./assets/02-27.png" alt="" /></p>
<ul>
<li>First, we find t when the particle hits the plane:</li>
</ul>
<p>$$
(\mathbf{p} (t)−\mathbf{x} _0)\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}=0
$$</p>
<p>$$
(\mathbf{p}-\mathbf{x} _0+t\mathbf{v})\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}=0
$$</p>
<p>$$
t=\frac{(\mathbf{p}−\mathbf{x}_0)\cdot  \mathbf{x} _{10}\times \mathbf{x} _{20}}{\mathbf{v}\cdot \mathbf{x} _{10}\times \mathbf{x} _{20}} 
$$</p>
<ul>
<li>We then check if \(\mathbf{p}(t)\) is inside or not.
<ul>
<li>See Example 6.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 代入体积公式，体积为0时发生碰撞</p>
</blockquote>
<h1 id="碰撞响应"><a class="header" href="#碰撞响应">碰撞响应</a></h1>
<p>粒子与 SDF 的碰撞响应在此处同样适用，但碰撞深度与反弹方向不同的计算方法不同。</p>
<table><thead><tr><th></th><th>粒子+SDF</th><th>粒子+Mesh</th></tr></thead><tbody>
<tr><td>碰撞深度</td><td>\(\phi (x)\)</td><td>点到最近面片的距离</td></tr>
<tr><td>反弹方向</td><td>\(\nabla \phi (x)\)</td><td>面片的法向</td></tr>
</tbody></table>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P24</p>
<h1 id="碰撞检测-2"><a class="header" href="#碰撞检测-2">碰撞检测</a></h1>
<p>让刚体上的每个顶点与SDF做一次碰撞检测，检测方法与<a href="">粒子+SDF</a>相同。<br />
区别在每个顶点当前的位置与速度的获取当法与粒子不同。</p>
<p><img src="./assets/04-20.png" alt="" /></p>
<p>以Vertex i为例，先分析i当前的位置和速度:</p>
<p><img src="./assets/04-21.png" alt="" /></p>
<blockquote>
<p>✅ \(x\)和\(v\)分别是刚体质心点的位置和速度,第二项为刚体上的特定点相对于质心点的位置和速度</p>
</blockquote>
<h1 id="碰撞响应-1"><a class="header" href="#碰撞响应-1">碰撞响应</a></h1>
<p>SDF 常用于代表静态物体，这种物体不响应力和碰撞，所以所有的碰撞响应都发生在粒子上。</p>
<p>Problem: <strong>we cannot directly modif</strong>y \(\mathbf{x}_i\) or \(\mathbf{v}_i\) <strong>since they not state variables</strong>. They areindirectly determined.</p>
<p><strong>对于粒子，可以直接用Impulse修改\(x\)和\(v\)</strong><br />
<strong>对于刚体，impulse只能修改\(x\)和\(v\)，不能修改\(x_i\)和\(v_i\)</strong>；其中\(x\)可以通过直接修改更新，也可以通过修改\(v\)来更新，这里选择后者。</p>
<p>解决方法：通过修改\(\mathbf{v}\)和\(\mathbf{\omega}\)实现修改\(x_i\)和\(v_i\)</p>
<h2 id="相交解除"><a class="header" href="#相交解除">相交解除</a></h2>
<p>P32</p>
<h3 id="shape-matching-2"><a class="header" href="#shape-matching-2">Shape Matching</a></h3>
<blockquote>
<p>✅ 用粒子的方法来解决刚体的问题</p>
</blockquote>
<p>P33</p>
<h3 id="basic-idea"><a class="header" href="#basic-idea">Basic Idea</a></h3>
<p>We allow each vertex to have its own velocity, so it can move by itself.</p>
<p><img src="./assets/04-26.png" alt="" /></p>
<p>First, move vertices <strong>independently</strong> by its velocity, with collision and friction being handled.</p>
<p>Second, enforce the <strong>rigidity</strong> constraint to become a rigid body again.</p>
<p>先对 Mesh 上的每个顶点看作是粒子对它们进行独立的仿真。保证仿真后每个粒子(顶点)不与 SDF 发生相交。<br />
此时刚体可能发生了形变，再更新刚体的位置和旋转，使其各个顶点尽量接近第一步的仿真结果。</p>
<blockquote>
<p>✅ 第二步是 Shape Matching 的关键</p>
</blockquote>
<p>Rigidity：包含更新质心的位置和旋转</p>
<p>P34</p>
<h3 id="更新质心位置"><a class="header" href="#更新质心位置">更新质心位置</a></h3>
<p>Now \(\mathbf{c}\) and \(\mathbf{R}\) are unknowns we want to find out from:</p>
<p><img src="./assets/04-27.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{c}\) 代表质心，即前面的 \(\mathbf{x}\)<br />
✅ 约束1：新的顶点位置与原顶点位置的距离尽量接近。<br />
✅ 约束2：\(\mathbf{R}\) 是旋转矩阵。<br />
✅ 很难通过定义目标函数来满足约束2，因此问题简化：用任意矩阵A代替需要满足旋转矩阵约束的\(R\)。<br />
✅ \(\sum Ar_i = A \sum r_i = 0\)，因此得出结论：约束前后质心位置不变<br />
❓ 优化之后的刚体可能还是与地面穿透的。</p>
</blockquote>
<p>P35</p>
<h3 id="更新质心旋转"><a class="header" href="#更新质心旋转">更新质心旋转</a></h3>
<p><img src="./assets/04-28-1.png" alt="" /></p>
<blockquote>
<p>✅ 先假设 \(\mathbf{R}\) 是任意矩阵 \(\mathbf{A}\),再从中提取旋转成分<br />
✅ <a href="%5BTODO%5D">Polar Decomposition</a>：极性分解，把任意矩阵分解旋转部分和形变部分。</p>
</blockquote>
<p>P36</p>
<p>结论：<br />
\(A^TA=S^TS=S^2\)<br />
\(R=AS^{-1}\)</p>
<p>P39</p>
<h3 id="shape-matching-pipeline"><a class="header" href="#shape-matching-pipeline">Shape Matching Pipeline</a></h3>
<p><img src="./assets/04-33.png" alt="" /> </p>
<p><img src="./assets/04-34.png" alt="" /> </p>
<p><img src="./assets/04-35.png" alt="" /> </p>
<p>Physical quantities are attached to each vertex, not to the entire body.</p>
<p>P40</p>
<h4 id="算法分析"><a class="header" href="#算法分析">算法分析</a></h4>
<ul>
<li>
<p>优点：Easy to implement and compatible with other nodal systems, i.e., cloth, soft bodies and even particle fluids.</p>
</li>
<li>
<p>局限性：Difficult to strictly enforce friction and other goals. The rigidification process will destroy them.</p>
</li>
<li>
<p>适用场景：More suitable when the <strong>friction accuracy is unimportant</strong>, i.e., buttons on clothes.</p>
</li>
</ul>
<p>P41</p>
<h4 id="after-class-reading-9"><a class="header" href="#after-class-reading-9">After-Class Reading</a></h4>
<p>Muller et al. 2005.<br />
<em>Meshless Deformations Based on Shape Matching</em>. TOG (SIGGRAPH).</p>
<h2 id="状态更新-1"><a class="header" href="#状态更新-1">状态更新　　　</a></h2>
<h3 id="冲量法"><a class="header" href="#冲量法">冲量法</a></h3>
<p>碰撞 → 粒子响应 → 粒子速度 → 刚体冲量 → 刚体状态</p>
<p>P25</p>
<h4 id="反向思考"><a class="header" href="#反向思考">反向思考</a></h4>
<p>What happens to \(\mathbf{v}_i\) when an impulse \(\mathbf{j}\) is appliedat vertex \(i\)?</p>
<blockquote>
<p>✅ \(\mathbf{j}\) 是一个未知的冲量。\(\mathbf{v}_i\) 是点速度、\(\mathbf{v}\)是线速度<br />
✅ 假设：此时对\(x_i\)点施加冲量\(j\)，会发生什么？</p>
</blockquote>
<h4 id="冲量mathbfj对刚体的影响"><a class="header" href="#冲量mathbfj对刚体的影响">冲量\(\mathbf{j}\)对刚体的影响</a></h4>
<p>根据<a href="">刚体动力学</a>可得：</p>
<p><img src="./assets/04-22-1.png" alt="" /></p>
<blockquote>
<p>✅ 冲量 = \(Ft\) = \(m\Delta v \Rightarrow \Delta v\) = 冲量/\(m\)，由此得到\(v^{new}\)<br />
✅ 冲量力矩=质量矩阵 * \( \Delta \omega \) = 力矩 \(·t\), 由力矩=\(Rr_i \times f_i\)，可得：
\(Rr_i \times j\) = 冲量力矩 \(\Rightarrow \Delta \omega\) ＝ 质量矩阵\(^{-1}\) · 冲量力矩 ，由此得到\(\omega^{new}\)</p>
</blockquote>
<h4 id="冲量mathbfj对刚体顶点mathbfi的影响"><a class="header" href="#冲量mathbfj对刚体顶点mathbfi的影响">冲量\(\mathbf{j}\)对刚体顶点\(\mathbf{i}\)的影响</a></h4>
<p>由线速度\(v^{new}\)得到点速度\(\mathbf{v}_i^{new}\)</p>
<p><img src="./assets/04-22-2.png" alt="" /></p>
<p>P27</p>
<p>$$
\mathbf{v_i^{new}} = \mathbf{v} _i+\frac{1}{M}\mathbf{j} −(\mathbf{Rr} _i)×(\mathbf{I} ^{−1}(\mathbf{Rr} _\mathbf{i}\times \mathbf{j} ))
$$</p>
<blockquote>
<p>✅ 向量之间的点乘可以转化为矩阵与向量的乘法，方便化简。具体内容见页面最后的<strong>补充1</strong></p>
</blockquote>
<p>$$
\mathbf{v_i^{new}} = \mathbf{v} _i+\frac{1}{M} \mathbf{j} −(\mathbf{Rr} _i)^∗\mathbf{I} ^{−1} (\mathbf{Rr} _i)^∗\mathbf{j} 
$$</p>
<p>化简得：</p>
<blockquote>
<p>$$
\mathbf{v_i^{new}}-\mathbf{v}_i=\mathbf{Kj}
$$
$$
\mathbf{K} \longleftarrow \frac{1}{M} \mathbf{1} −(\mathbf{Rr} _i)^{∗}\mathbf{I} ^{−1}(\mathbf{Rr} _i)^{∗}
$$</p>
</blockquote>
<blockquote>
<p>✅ 结论，当碰撞点\(i\)确定时，冲量\(j\)和其造成的速度改变量\(Δv\)是确定的，这样，可以通过施加\(j\)，精确修改\(v_i\)<br />
✅ 已知 \(\mathbf{v}_i^{new},\mathbf{v}_i,\mathbf{K}\),可求得 \(\mathbf{j}\)</p>
</blockquote>
<p>P28</p>
<h4 id="pipeline-1"><a class="header" href="#pipeline-1">Pipeline</a></h4>
<p><img src="./assets/04-24.png" alt="" /></p>
<blockquote>
<p>✅ \(i\)点发生碰撞 → 算出i点碰撞后的速度 → 算出给i点什么样的冲量能让\(i\)出现碰撞后的效果 → 真的施加这样一个冲量 → 更新刚体状态<br />
✅ 此处假设不合理。这里假设刚体上每个顶点被撞后的响应效果是确定的，即与刚体被撞击的位置及刚体自身状态无关，但又由于刚体自身状态等原因，为了达到目标效果，碰撞所产生的冲量却是不一样的。<br />
✅ 事实上，正确逻辑应该，碰撞所生的冲量是确定的。而由于刚体自身状态等原因，对刚体顶点产生的效果是不同的。</p>
</blockquote>
<p>P29</p>
<h4 id="some-implementation-details"><a class="header" href="#some-implementation-details">Some Implementation Details</a></h4>
<ul>
<li>We can decrease the restitution \(\mathbf{\mu_N} \) to reduce oscillation（抖动）.</li>
</ul>
<blockquote>
<p>✅ 抖动原因：重力让它往下，冲量让它往上，导致在地面上反复振荡<br />
✅ 解决方法：接近静止时衰减 \(\mathbf{\mu_N} \)</p>
</blockquote>
<ul>
<li>We don't update the position here. Why?
<ul>
<li>Because the problem is nonlinear.</li>
<li>We will come back to this later when we talk about constraints.</li>
</ul>
</li>
</ul>
<p>P30</p>
<h3 id="多碰撞点场景"><a class="header" href="#多碰撞点场景">多碰撞点场景</a></h3>
<blockquote>
<p>✅ 如果有多个顶点发生碰撞呢？<br />
答：方法1，问题简化，用平均值。方法2，解线性系统。</p>
</blockquote>
<p><img src="./assets/04-25.png" alt="" /></p>
<p>Relative velocity at joints</p>
<p>$$
\begin{cases}
\mathbf{v} _0 ^{\mathbf{new} }− \mathbf{v} _0=\mathbf{K} _{a00 }\mathbf{j} _0+\mathbf{K} _{a01 }\mathbf{j} _1 −(−\mathbf{K} _{b00 }\mathbf{j} _0 +\mathbf{K} _{b02}\mathbf{j} _2 )\\
\mathbf{v} _1 ^{\mathbf{new} }− \mathbf{v} _1=\mathbf{K} _{a10 }\mathbf{j} _0+\mathbf{K} _{a11 }\mathbf{j} _1 −(−\mathbf{K} _{c11 }\mathbf{j} _0 +\mathbf{K} _{c13 }\mathbf{j} _3 )\\
\mathbf{v} _2 ^{\mathbf{new} }− \mathbf{v} _2=\mathbf{K} _{b20 }\mathbf{j} _0+\mathbf{K} _{b22 }\mathbf{j} _2\\
\mathbf{v} _3 ^{\mathbf{new} }− \mathbf{v} _3=\mathbf{K} _{c31 }\mathbf{j} _1+\mathbf{K} _{c33 }\mathbf{j} _3
\end{cases}
$$</p>
<p>$$
\Downarrow
$$</p>
<p>$$
\begin{bmatrix}
\mathbf{K} _{a00 }+\mathbf{K} _{b00 } &amp; \mathbf{K} _{a01 } &amp; -\mathbf{K} _{b02 } &amp; \Box \\
\mathbf{K} _{a10 } &amp; \mathbf{K} _{a11 }+\mathbf{K} _{c11 } &amp; \Box  &amp; -\mathbf{K} _{c13 }\\
-\mathbf{K} _{b20 } &amp; \Box  &amp; \mathbf{K} _{b22} &amp; \Box \\
\Box  &amp; -\mathbf{K} _{c31 } &amp; \Box  &amp; \mathbf{K} _{c33 } 
\end{bmatrix}\begin{bmatrix}
\mathbf{j} _{0 }\\
\mathbf{j} _{1}\\
\mathbf{j} _{2}\\
\mathbf{j} _{3}
\end{bmatrix}=\begin{bmatrix}
\bigtriangleup \mathbf{v} _{0}\\
\bigtriangleup \mathbf{v} _{1}\\
\bigtriangleup \mathbf{v} _{2}\\
\bigtriangleup \mathbf{v} _{3}
\end{bmatrix}
$$</p>
<p>\(\mathbf{K} _{a01}\mathbf{j} _1\) stands for the velocity change of bunny \(a\) at joint 0, caused by impulse \(\mathbf{j}_1\).</p>
<p>P31</p>
<h3 id="after-class-reading-before-collision-1"><a class="header" href="#after-class-reading-before-collision-1">After-Class Reading (Before Collision)</a></h3>
<p><a href="https://graphics.pixar.com/pbm2001">https://graphics.pixar.com/pbm2001</a><br />
Rigid Body Dynamics</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P9</p>
<h1 id="topics-for-the-day-2"><a class="header" href="#topics-for-the-day-2">Topics for the Day</a></h1>
<pre class="mermaid">mindmap
刚体系统仿真
    碰撞检测
        离散相交检测
            宽检测
            窄检测
        连续穿透检测
            宽检测 Broad Phase
             窄检测Narrow Phase
    碰撞响应
        相交解除
            内点法 Interior Point Methods
                IPC
            优化法 Impact Zone Optimization
        状态更新
            
</pre>
<p><strong>碰撞检测提供以信息：</strong></p>
<ol>
<li>是否存在穿模</li>
<li>最快解除模的移动方向</li>
<li>解除穿模移动方向对应的矩离</li>
</ol>
<p><strong>碰撞检测层次：</strong></p>
<ol>
<li>刚体 bbox 之间</li>
<li>刚体之间</li>
<li>三角形面片之间</li>
</ol>
<p><strong>其它：</strong></p>
<ol>
<li>粗/精检测，是否能准确判断穿模情况，或是提供排除信息</li>
<li>是否支持多个对象之间碰撞检测</li>
</ol>
<p>输出：是否存在穿模(粗)<br />
检测层次：1.2.3<br />
多对象检测：支持</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P5</p>
<h1 id="相交检测-1"><a class="header" href="#相交检测-1">相交检测</a></h1>
<h2 id="方法一spatial-partitioning"><a class="header" href="#方法一spatial-partitioning">方法一：Spatial Partitioning</a></h2>
<p>Spatial partitioning divides the space by a grid and stores objects into grid cells.</p>
<blockquote>
<p>✅ 把空间划分成固定大小的格子，标记每个对象所占的格子。</p>
</blockquote>
<p>P6</p>
<h3 id="静止场景"><a class="header" href="#静止场景">静止场景</a></h3>
<p>To find pair candidates for collision test, we just have to check the grid cells.</p>
<blockquote>
<p>✅ 位于同一格子里的两个对象可能存在穿模。</p>
</blockquote>
<p><img src="./assets/09-2.png" alt="" /></p>
<blockquote>
<p>✅ 图中以三角形面片为例，但实际上对刚体和 bbox 同样适用。</p>
</blockquote>
<p>P7</p>
<h3 id="运动场景"><a class="header" href="#运动场景">运动场景</a></h3>
<p>If we need to consider moving objects, we just expand the object region.</p>
<p><img src="./assets/09-3.png" alt="" /></p>
<p>P8</p>
<h3 id="数据存储"><a class="header" href="#数据存储">数据存储</a></h3>
<p>Instead of allocating <strong>memories</strong> to cells, we can build an object-cell list and then sort them. This avoids memories wasted in empty cells.</p>
<blockquote>
<p>✅要解决的问题：3D空间需要划分出大量的小格。有的格子可能包含很多object. 大多数格子可能没有object.<br />
✅方法：3D数组转为list表示法。<br />
✅缺点：内存访问不连续。</p>
</blockquote>
<p><img src="./assets/09-5.png" alt="" /></p>
<p>P9</p>
<h4 id="morton-code"><a class="header" href="#morton-code">Morton Code</a></h4>
<blockquote>
<p>✅ Morton Code：一种对格子编号的顺序。</p>
</blockquote>
<p>One question is how to define the cell ID. Using the grid order is not optimal, since it cannot be easily extended and it is lack of locality. Morton code uses a Z-pattern instead.</p>
<p><img src="./assets/09-6.png" alt="" /></p>
<blockquote>
<p>✅ 希望内存访问尽量连续。也就是下一次访问的内存地址在上次的附近<br />
✅ Grid Order：横向访问连续、纵向访问不连续、三维情况会更严重。</p>
</blockquote>
<p><img src="./assets/09-7.png" alt="" /></p>
<p>P10</p>
<h2 id="after-class-reading-10"><a class="header" href="#after-class-reading-10">After-Class Reading</a></h2>
<p>GPU Gems 3</p>
<p>Chapter 32. Broad-Phase Collision Detectionwith CUDA</p>
<p>P14</p>
<h2 id="方法二bounding-volume-hierarchy"><a class="header" href="#方法二bounding-volume-hierarchy">方法二：Bounding Volume Hierarchy</a></h2>
<p>输出：是否存在穿模(粗)<br />
检测层次：1.2.3<br />
多对象检测：支持</p>
<p>Bounding volume hierarchy is built on geometric/topological proximity of objects.</p>
<blockquote>
<p>✅空间划分→物体划分</p>
</blockquote>
<p>P16</p>
<h2 id="构造bounding-box"><a class="header" href="#构造bounding-box">构造Bounding Box</a></h2>
<p><u>Axis-aligned bounding box (AABB)</u> is the most popular bounding volume. Besides that, there are also <u>spheres</u> and <u>oriented bounding box (OBB)</u>.</p>
<p>Two AABBs intersect if and only if they intersect in every axis.</p>
<h2 id="构造bvh"><a class="header" href="#构造bvh">构造BVH</a></h2>
<p><img src="./assets/09-8.png" alt="" /></p>
<p>P15</p>
<h2 id="外部物体与身体相交检测"><a class="header" href="#外部物体与身体相交检测">外部物体与身体相交检测</a></h2>
<p>To find elements potentially in collision with an object, we just traverse the tree.</p>
<p><img src="./assets/09-9.png" alt="" /></p>
<p>P17</p>
<h2 id="自相交检测"><a class="header" href="#自相交检测">自相交检测</a></h2>
<p>To process <strong>self collisions</strong> by BVH, we define two procedures.</p>
<p><img src="./assets/09-10-1.png" alt="" /></p>
<p><img src="./assets/09-10.png" alt="" /></p>
<p>P18</p>
<p>The performance depends on the effectiveness of 剪枝。</p>
<table><thead><tr><th>ID</th><th>Year</th><th>Name</th><th>Note</th><th>Tags</th><th>Link</th></tr></thead><tbody>
<tr><td></td><td>2012</td><td>Energy-based Self-Collision Culling for Arbitrary Mesh Deformations</td><td>✅ 对每个区域计算能量，根据形变能量的大小来判断有没有可能相交，此方法不适用于衣服，因为在衣服模拟中大形变很常见、不代表有相交。</td><td></td><td></td></tr>
</tbody></table>
<p>P19</p>
<h1 id="comparison-between-sh-and-bvh"><a class="header" href="#comparison-between-sh-and-bvh">Comparison between SH and BVH</a></h1>
<ul>
<li>
<p>Spatial Hashing</p>
<ul>
<li>Easy to implement</li>
<li>GPU friendly</li>
<li>Needs to <u>recompute</u> after updating objects</li>
</ul>
</li>
<li>
<p>Bounding Volume Hierarchy</p>
<ul>
<li>More involved</li>
<li>Not GPU friendly</li>
<li>To update BVH, just update bounding volumes</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ CUDA 代码. NVIDIA 代码通常使用SH。GPU 喜欢简单粗爆的数据结构，BVH相对于GPU过于复杂。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="离散相交检测gjk"><a class="header" href="#离散相交检测gjk">离散相交检测——GJK</a></h1>
<p>输出：是否存在穿模(细)<br />
检测层次：凸几何体，例如凸 bbox、凸 Mesh、三角形面片<br />
是否支持多个：否</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P21</p>
<h1 id="离散相交检测--公式求解"><a class="header" href="#离散相交检测--公式求解">离散相交检测 —— 公式求解</a></h1>
<p>Discrete Collision Detection (DCD)</p>
<p>DCD tests if any intersection exists in each state at discrete time instant: \(\mathbf{x}^{[0]}\), \(\mathbf{x}^{[1]}\), …</p>
<blockquote>
<p>✅ 准确来说。DCD检测的不是碰撞，而是相交</p>
</blockquote>
<p>输出：是否碰撞(精)，碰撞位置<br />
检测层次：边、面片<br />
是否支持多个：否</p>
<h2 id="edge-triangle-intersection"><a class="header" href="#edge-triangle-intersection">edge-triangle intersection</a></h2>
<p>To a triangle mesh, the basic test is <u>edge-triangle intersection</u> test.</p>
<p><img src="./assets/09-13.png" alt="" /></p>
<p><img src="./assets/09-14.png" alt="" /></p>
<blockquote>
<p>\(t\) 代表相交位置对应 \(\mathbf{x}_a\) 和\(\mathbf{x}_b\)的插值量</p>
</blockquote>
<blockquote>
<p>✅ 检测在特定状态下是否相交，每一帧都不相交就认为无碰撞。<br />
✅ 相交和碰撞的区别：相交分析的是运动前后的状态、碰撞检测的是运动的过程、未相交不一定无碰撞、</p>
</blockquote>
<p>P22</p>
<h1 id="连续穿透检测"><a class="header" href="#连续穿透检测">连续穿透检测</a></h1>
<h2 id="tunneling"><a class="header" href="#tunneling">Tunneling</a></h2>
<p>DCD is simple and robust, but it suffers from the tunneling problem: objects penetrating through each other without being detected.</p>
<p><img src="./assets/09-15.png" alt="" /></p>
<blockquote>
<p>tunneling problem：当物体运动特别快时，有可能的穿透另一物体而没有被检测到，常见于细薄物体、例如衣服<br />
这种情况无相交但是有碰撞</p>
</blockquote>
<p>P23<br />
Continuous Collision Detection (CCD)</p>
<p>CCD tests if any intersection exists between two states: \(\mathbf{x} ^{[0]}\) and \(\mathbf{x} ^{[1]}\).</p>
<p>To a triangle mesh, there two basic tests: <u>vertex-triangle</u> and <u>edge-edge</u> tests.</p>
<h2 id="vertex-triangle-tests"><a class="header" href="#vertex-triangle-tests">vertex-triangle tests</a></h2>
<p><img src="./assets/09-17.png" alt="" /></p>
<p><img src="./assets/09-16.png" alt="" /></p>
<blockquote>
<p>✅ 当四点共面时，构成的四面体体积为0、利用四面体的体积公式，可求出四点共面的时间 \(t\) . <strong>这里的</strong>\(\mathbf{t}\)<strong>是时间</strong><br />
✅ 假设运动是匀速的，\( \mathbf{x}_ {30}(t)、 \mathbf{x}_ {10}(t)、\mathbf{x}_ {20}(t)\)都是关于\(t\)的线性函数。<br />
✅ 一元三次方程有公式解，但用到\(\sqrt[3]{\cdot}\)，\(\sqrt[3]{\cdot }\) 的误差非常大。因此不建议使用，建议用牛顿法。</p>
</blockquote>
<p>P24</p>
<h2 id="edge-edge-tests"><a class="header" href="#edge-edge-tests">edge-edge tests</a></h2>
<blockquote>
<p>✅ 为什么要检测边边相交，因为有可能三角形相交但点面没有相交。</p>
</blockquote>
<p><img src="./assets/09-18.png" alt="" /></p>
<p><img src="./assets/09-19.png" alt="" /></p>
<blockquote>
<p>✅ 先求四点共面的 \(t\)<br />
✅ 解一元三次方程也不建议牛顿法，而是二分法，因为\(t\)的范围是[0,1]</p>
</blockquote>
<p>P25</p>
<h2 id="issues-with-ccd"><a class="header" href="#issues-with-ccd">Issues with CCD</a></h2>
<ul>
<li>Floating-point errors, especially due to root finding of a cubic equation
<ul>
<li>Buffering epsilons, but that causes <strong>false positives</strong>.</li>
<li>Gaming GPUs often use single floating-point precision.</li>
</ul>
</li>
</ul>
<blockquote>
<p>✅ 游戏 GPU 以单精度为主，因此要注意浮点误差问题。</p>
</blockquote>
<ul>
<li>
<p>Computational costs: more expensive than DCD.</p>
<ul>
<li>Some argue that broad-phase collision culling is the bottleneck.</li>
</ul>
</li>
<li>
<p>Difficulty in implementation.</p>
</li>
</ul>
<p>P26</p>
<h2 id="after-class-reading-11"><a class="header" href="#after-class-reading-11">After-Class Reading</a></h2>
<p>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact and Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</p>
<p>Relative simple explicit integration of cloth dynamics</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P27</p>
<h1 id="相交解除-1"><a class="header" href="#相交解除-1">相交解除</a></h1>
<p>P39</p>
<h2 id="a-practical-system-summary"><a class="header" href="#a-practical-system-summary">A Practical System Summary</a></h2>
<p><img src="./assets/09-30.png" alt="" /></p>
<blockquote>
<p>✅ 有碰撞，先做 Impact Zone. 因为这个快、不能解决再用后面方法、计算量不允许则选择 Rigid Impact.</p>
</blockquote>
<p>P28</p>
<h2 id="interior-point-methods-and-impact-zone-optimization"><a class="header" href="#interior-point-methods-and-impact-zone-optimization">Interior Point Methods and Impact Zone Optimization</a></h2>
<blockquote>
<p>✅ 这是两个大的套路，不是具体的方法。</p>
</blockquote>
<p>Given the calculated next state \(\mathbf{x} ^{[1]}\), we want to update it into \(\bar{\mathbf{x} } ^{[1]}\), such that the path from \(\mathbf{x} ^{[0]}\) to \(\bar{\mathbf{x} } ^{[1]}\) is intersection-free.</p>
<p><img src="./assets/09-20.png" alt="" /></p>
<blockquote>
<p>✅ 整个图代表刚体的状态空间而不是位置空间。<br />
✅ 每个小圆点代表一个刚体状态，而不是一个粒子。<br />
✅ \(\mathbf{x} \) 是刚体状态的表示符，至少包含质心的状态和旋转信息。</p>
</blockquote>
<table><thead><tr><th></th><th>内点法</th><th>Impact Zone 法</th><th></th></tr></thead><tbody>
<tr><td></td><td>✅ 从\(\mathbf{x}^{[0]}\)出来，朝\(\mathbf{x}^{[1]}\)走，并永远保证只在安全区域走，直到不能走为止。</td><td>✅ 从\(\mathbf{x}^{[1]}\)出发，反复优化结果（投影），直到回到安全区域为止。</td><td>✅ 蓝色区域为安全区域</td></tr>
<tr><td>优点</td><td>Always succeed</td><td>Fast. <br> 1. Close to solution. <br> 2. Only vertices in collision (impact zones). <br> 3. Can take large step sizes.</td><td>✅ Impact Zone：1. \(\mathbf{x}^{[1]}\)通常离安全区域不太远，且优化时只针对 Impact Zone 优化，因此快。<br> 2. 只有\(\mathbf{x}\)不在安全区域时才需要做。 <br>  ✅ 内点：哪怕\(\mathbf{\bar{x}}^{[1]}\)最终没有到最佳位置，但能保证一定在安全区域，因此一定成功。</td></tr>
<tr><td>局限性</td><td>Slow.  <br> 1. Cautiously by small step sizes. <br> 2. Far from solution. <br> 3. All of the vertices.</td><td>May not succeed.</td><td>✅ 内点：1. 为保证每一步安全，步长不能太大，因此慢。<br> 2. \(\mathbf{x}^{[0]}\)和\(\mathbf{x}^{[1]}\)可能比较远，也导致慢。 <br> 3. 每一次都必须要做</td></tr>
</tbody></table>
<p>P47</p>
<h1 id="a-summary-for-the-day-6"><a class="header" href="#a-summary-for-the-day-6">A Summary For the Day</a></h1>
<ul>
<li>
<p>Collision handling involves two steps: <em>collision detection</em> and <em>collision response</em>.</p>
</li>
<li>
<p>Collision detection contains two phases: <em>broad-phase culling</em> and <em>narrow-phase test</em>.</p>
</li>
<li>
<p>There are two types of collision detection tests: <em>discrete</em> and <em>continuous</em>.</p>
</li>
<li>
<p>Similarly, there are discrete and continuous collision responses.</p>
</li>
<li>
<p>For continuous collision responses, we must update the state to become collisionfree state. There are two approaches: <em>interior point method</em> and <em>impact zone optimization</em>. <strong>Rigid impact zone is also a method, but it’s problematic</strong>.</p>
</li>
<li>
<p>For discrete collision responses, we allow intersections to stay and hope to remove them in long turn. <strong>Cloth-cloth intersections are difficult to handle</strong>.</p>
</li>
</ul>
<blockquote>
<p>✅ 如果考虑摩擦，通常把摩擦做为后处理，但这样结果不精确。如果同时处理摩擦和碰撞、会很复杂。<br />
✅ Impulse方法的碰撞检测通常用SDF．但很多形变体无法使用SDF.<br />
✅ Impulse响应方式是离散响应方式，无法处理穿透问题。<br />
✅ 碰撞问题通常不使用物理方法，因为使用物理方法需要小步长，效率非常低。<br />
✅ 碰撞开源代码：bullet. physics X</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P30</p>
<h2 id="log-barrier-interior-point-methods"><a class="header" href="#log-barrier-interior-point-methods">Log-Barrier Interior Point Methods</a></h2>
<p>内点法把碰撞解除抽象为带约束优化问题。优化的目标是\(\mathbf{x}^{[0]}→\mathbf{x}^{[1]}\)，优化的约束是不碰撞。问题是如何把离散曲面的碰撞检测描述为优化公式？<br />
\(||\mathbf{x}_{ij}||\)就是这个目的。</p>
<h3 id="算法过程"><a class="header" href="#算法过程">算法过程</a></h3>
<p>For simplicity, let’s consider the Log-barrier repulsion between two vertices.</p>
<p>$$E(\mathbf{x} )=−\rho \text{ log} ||\mathbf{x} _{ij}||$$</p>
<p>$$
\mathbf{f} _i(\mathbf{x} )=−∇_iE=ρ\frac{\mathbf{x} _ {ij}}{||\mathbf{x} _ {ij}||^2} \\
\mathbf{f} _j(\mathbf{x} )=−∇_jE=−ρ\frac{\mathbf{x} _ {ij}}{||\mathbf{x} _{ij}||^2}
$$</p>
<p>[TODO]<br />
$$
\frac{\alpha ||\mathbf{x}|| }{\alpha \mathbf{x}} =\frac{\mathbf{x}^\mathbf{T} }{||\mathbf{x}||} 
$$</p>
<blockquote>
<p>✅ 用 Log 定义能量、前面某一节课讲过。距离 → 能量 → 斥力<br />
❓ \(||\mathbf{x}_{ij}|| \) 的物理含义没有定义。可能是希望两个三角形之间穿透矩离。\( \mathbf{x}\) 代表两个刚体的状态。</p>
</blockquote>
<p><img src="./assets/09-23.png" alt="" /></p>
<blockquote>
<p>✅ 不需要互斥力一直存在，因此做了一个截断（IPC）</p>
</blockquote>
<p>P31</p>
<h3 id="算法实现"><a class="header" href="#算法实现">算法实现</a></h3>
<p>We can then formulate the problem as:</p>
<p>$$
\bar{\mathbf{x} }^ {[1]}\longleftarrow \mathrm{argmin} _\mathbf{x} (\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2−ρ\sum \mathrm{log} ||\mathbf{x} _{ij}||)
$$</p>
<blockquote>
<p>✅ 优化目标：点的位置与目标位置（穿模）尽量接近，且不穿模。<br />
✅ 绿色是来自\(\mathbf{x}^{[1]}\)的引力，对应公式第1页。黄色是来自边界的斥力对应公式第2页。<br />
❓ ||\(X_{ij}\)||代表穿模情况，为什么是用距离的方式定义？</p>
</blockquote>
<p><img src="./assets/09-24.png" alt="" /></p>
<p>Gradient Descent:</p>
<blockquote>
<p>\(\mathbf{x} ^{(0)}\longleftarrow \mathbf{x} ^{[0]}\)<br />
For \(k=0…K\)<br />
$$\mathbf{x} ^{(k+1)}\longleftarrow \mathbf{x} ^{(k)}+α(\mathbf{x} ^{[1]}−\mathbf{x} ^{(k)}+ρ\sum \frac{\mathbf{x} _{ij}}{||\mathbf{x} _{ij}||^2})$$ 
\(\bar{\mathbf{x} }^ {[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
</blockquote>
<blockquote>
<p>✅ <strong>每走一小步都需要反复的碰撞检测，重新计算</strong>\(||\mathbf{x} _{ij}||\)。<br />
✅ 关键是步长\(\alpha \)</p>
</blockquote>
<p>The step size \({\color{Red} α}\) must be adjusted to ensure that no collision happens on the way.  To find \({\color{Red} α}\), <strong>we need collision tests</strong>.</p>
<p>[❓] \( \alpha \) 不是 learning rate 吗？为什么碰撞检测的结果会影响到\( \alpha \) ？</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P32</p>
<h2 id="impact-zone-optimization"><a class="header" href="#impact-zone-optimization">Impact Zone Optimization</a></h2>
<p>The goal of impact zone optimization is to optimize \(\mathbf{x}^{[1]}\) until it becomes intersection-free. (This potentially suffers from the tunneling issue, but it’s uncommon.)</p>
<blockquote>
<p>tunneling issue 是指：\(\mathbf{x} ^{[1]}\) 离两个安全区都比较近。\(\mathbf{x} ^{[0]}\) 在其中一个安全区，而\(\mathbf{x} ^{[1]}\) 被优化到了另一个安全区。表现出的现象为穿透。</p>
</blockquote>
<h3 id="带约束优化问题"><a class="header" href="#带约束优化问题">带约束优化问题</a></h3>
<p>目标优化：</p>
<p>$$
\bar{\mathbf{x} }^{[1]}\longleftarrow \mathrm{argmin} _\mathbf{x}  \frac{1}{2} ||\bar{\mathbf{x} }-\mathbf{x}^{[1]}||^2
$$</p>
<p>约束：</p>
<p>$$
\text{such that}
\begin{cases}
C(\mathbf{x} )=−(\mathbf{x} _3−b_0\mathbf{x} _0−b_1\mathbf{x} _1−b_2\mathbf{x} _1)\cdot \mathbf{N} ≤0 &amp; \text{ For each detected vertex-triangle pair }  \\
C(\mathbf{x} )=−(b_2\mathbf{x} _2+b_3\mathbf{x} _3−b_0\mathbf{x} _0−b_1\mathbf{x} _1)\cdot \mathbf{N}≤0 &amp; \text{ For each detected edge-edge pair }
\end{cases}
$$</p>
<p><img src="./assets/09-25.png" alt="" /></p>
<p>这是一个带约束优化问题。　　　</p>
<h3 id="带约束优化问题转为无约束优化问题"><a class="header" href="#带约束优化问题转为无约束优化问题">带约束优化问题转为无约束优化问题　　　</a></h3>
<p>P36</p>
<p>We can then convert it into an unconstrained form:</p>
<p>$$\bar{\mathbf{x} } {[1]}\longleftarrow \text{argmin}_{x,λ}(\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2+\frac{ρ}{2} ||\text{max}(\tilde{C}  (\mathbf{x} ))||^2−\frac{1}{2ρ}||\mathbf{λ} ||^2)
$$</p>
<p>$$
\tilde{C}  (\mathbf{x})= \text{max}(\mathbf{C} (\mathbf{x} )+\mathbf{λ} /ρ)
$$</p>
<p>Augmented Lagrangian:</p>
<blockquote>
<p>\(\mathbf{x} ^{(0)} \longleftarrow \mathbf{x} ^{[0]}\)<br />
\(\mathbf{λ \longleftarrow 0} \)<br />
For \(k=0…K\)<br />
$$\mathbf{x} ^{(k+1)} \longleftarrow \mathbf{x} ^{(k)}−α∇(\frac{1}{2} ||\mathbf{x} −\mathbf{x} ^{[1]}||^2+\frac{ρ}{2} ||\text{max}(\tilde{C} (\mathbf{x} ))||^2−\frac{1}{2ρ}||\mathbf{λ} ||^2)$$<br />
\(λ\longleftarrow ρ\tilde{C} (\mathbf{x} )\)<br />
\(\bar{\mathbf{x} } ^{[1]}\longleftarrow \mathbf{x} ^{(k+1)}\)</p>
</blockquote>
<p>Tang et al. 2018. I-Cloth: <em>Incremental Collision Handling for GPU-Based Interactive Cloth Simulation</em>. TOG. (SIGGRAPH Asia)</p>
<p>P37</p>
<h3 id="about-impact-zone-optimization"><a class="header" href="#about-impact-zone-optimization">About Impact Zone Optimization</a></h3>
<ul>
<li>
<p>Fast per iteration</p>
<ul>
<li>Only have to deal with vertices in collision.</li>
</ul>
</li>
<li>
<p>Convergence sensitive to \(||\mathbf{x} ^{[0]}−\mathbf{x} ^{[1]}||^2\), or the time step \(∆t\)</p>
<ul>
<li>Can take many iterations to, or never achieve <em>intersection-free</em>.</li>
<li>Easy solution is to reduce \(∆t\), but that increases total costs.</li>
</ul>
</li>
</ul>
<p><img src="./assets/09-28.png" alt="" /></p>
<p>P33</p>
<p><img src="./assets/09-26.png" alt="" /></p>
<p>Every pair gives new positions to the involved vertices.  We can combine them together in a Jacobi, or Gauss-Seidel fashion, just like position-based dynamics.</p>
<p>P34</p>
<h3 id="after-class-reading-cont"><a class="header" href="#after-class-reading-cont">After-Class Reading (Cont.)</a></h3>
<p>Bridson et al. 2002. <em>Robust Treatment of Collisions, Contact
and Friction for Cloth Animation. TOG (SIGGRAPH)</em>.</p>
<p>Relative simple explicit integration of cloth dynamics</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P38</p>
<h2 id="rigid-impact-zones"><a class="header" href="#rigid-impact-zones">Rigid Impact Zones</a></h2>
<p>The rigid impact zone method simply freezes vertices in collision from <strong>moving in their pre-collision state</strong>. It’s simple and safe, but has noticeable artifacts.</p>
<p><img src="./assets/09-29.png" alt="" /></p>
<blockquote>
<p>✅ 检测到碰撞，则把这个区域退回到上一帧。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incremental-potential-contact"><a class="header" href="#incremental-potential-contact">Incremental Potential Contact</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="补充1-cross-product-as-a-matrix-product"><a class="header" href="#补充1-cross-product-as-a-matrix-product">补充1： Cross Product as a Matrix Product</a></h1>
<p>We can convert the cross product \(\mathbf{r}\times\) into a matrix product \(\mathbf{r}^*\).</p>
<p><img src="./assets/04-23.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{r}^*\) 是 \(\mathbf{r}\) 的 cross matrix.<br />
✅ 目的：用矩阵形式代替叉乘形式，方便公式化简</p>
</blockquote>
<h1 id="补充2极性分解"><a class="header" href="#补充2极性分解">补充2：极性分解</a></h1>
<h3 id="极性分解"><a class="header" href="#极性分解">极性分解</a></h3>
<p>Singular value decomposition says any matrix can be decomposed into: rotation,scaling and rotation: \(\mathbf{A = UDV} ^T\).</p>
<p><img src="./assets/04-29.png" alt="" /></p>
<p>We can rotate the object back before the final rotation: \(\mathbf{A}  = (\mathbf{UV} ^T)(\mathbf{VDV} ^T)\).</p>
<p><img src="./assets/04-31.png" alt="" /></p>
<blockquote>
<p>✅ \(\mathbf{A} = （\mathbf{UV}^T）(\mathbf{VDV}^T) =\mathbf{RS}\)<br />
✅ \(\mathbf{R}\) 代表全局旋转，\(\mathbf{S}\)代表本地形变，扔掉S保留R。</p>
</blockquote>
<p><img src="./assets/04-32.png" alt="" /></p>
<p>$$
\mathbf{A=RS} 
$$</p>
<p>$$
\mathbf{A} ^T\mathbf{A}  = \mathbf{S} ^T\mathbf{S}  = \mathbf{S} ^2
$$</p>
<p>分解结果:unique</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>Bullet3 中刚体与软体的交互主要通过其 <strong>软体动力学模块（Soft Body Dynamics）</strong> 实现，该模块与刚体动力学模块紧密集成。以下是主要机制和技术要点：</p>
<hr />
<h3 id="1-软体表示"><a class="header" href="#1-软体表示">1. <strong>软体表示</strong></a></h3>
<p>软体通常用 <strong>质点-弹簧系统</strong> 或 <strong>有限元模型</strong> 表示：</p>
<ul>
<li><strong>质点网格</strong>：软体由网格顶点（质点）和连接边（弹簧/约束）构成。</li>
<li><strong>物理属性</strong>：每个质点具有质量、速度，弹簧具有刚度、阻尼等参数。</li>
</ul>
<hr />
<h3 id="2-交互基本原理"><a class="header" href="#2-交互基本原理">2. <strong>交互基本原理</strong></a></h3>
<p>刚体与软体的交互本质上是 <strong>碰撞检测与响应</strong> 在混合系统中的应用：</p>
<h4 id="a-碰撞检测"><a class="header" href="#a-碰撞检测"><strong>a) 碰撞检测</strong></a></h4>
<ul>
<li><strong>软体包围盒</strong>：基于软体顶点动态更新 AABB 包围盒，进行粗检测。</li>
<li><strong>顶点级检测</strong>：将软体的每个顶点/面与刚体进行精确碰撞检测（如 GJK/EPA 或 Bullet 内置的凸包检测）。</li>
<li><strong>双向交互</strong>：
<ul>
<li>软体顶点 vs 刚体形状（如球体、立方体等）。</li>
<li>刚体也可检测与软体三角形面的碰撞。</li>
</ul>
</li>
</ul>
<h4 id="b-碰撞响应"><a class="header" href="#b-碰撞响应"><strong>b) 碰撞响应</strong></a></h4>
<ul>
<li><strong>冲量法</strong>：碰撞时对软体质点和刚体施加相反的冲量，满足动量守恒。</li>
<li><strong>约束求解</strong>：将碰撞转化为位置或速度约束，通过求解器（如 PBD 或 impulse-based 方法）处理。</li>
<li><strong>摩擦力与恢复系数</strong>：为软体顶点设置摩擦和弹性参数，模拟真实交互。</li>
</ul>
<hr />
<h3 id="3-实现流程bullet-代码层面"><a class="header" href="#3-实现流程bullet-代码层面">3. <strong>实现流程（Bullet 代码层面）</strong></a></h3>
<p>以下是典型流程（以 <code>btSoftBody</code> 和 <code>btRigidBody</code> 为例）：</p>
<h4 id="步骤-1创建软体并添加到世界"><a class="header" href="#步骤-1创建软体并添加到世界"><strong>步骤 1：创建软体并添加到世界</strong></a></h4>
<pre><code class="language-cpp">btSoftBodyWorldInfo worldInfo;
btSoftBody* softBody = btSoftBodyHelpers::CreateFromTriMesh(...);
btRigidBody* rigidBody = ...; // 创建刚体

btSoftRigidDynamicsWorld* world = new btSoftRigidDynamicsWorld(...);
world-&gt;addSoftBody(softBody);
world-&gt;addRigidBody(rigidBody);
</code></pre>
<h4 id="步骤-2交互通过碰撞检测触发"><a class="header" href="#步骤-2交互通过碰撞检测触发"><strong>步骤 2：交互通过碰撞检测触发</strong></a></h4>
<ul>
<li>Bullet 的 <code>btSoftRigidCollisionAlgorithm</code> 处理软体-刚体碰撞。</li>
<li>在 <code>btSoftBody::solveCollisions</code> 中更新顶点位置以响应碰撞。</li>
</ul>
<h4 id="步骤-3求解器迭代"><a class="header" href="#步骤-3求解器迭代"><strong>步骤 3：求解器迭代</strong></a></h4>
<p>在 <code>btSoftRigidDynamicsWorld::stepSimulation</code> 中：</p>
<ol>
<li>检测所有碰撞（包括软体-刚体对）。</li>
<li>通过 <code>btSoftBodySolver</code> 更新软体顶点位置。</li>
<li>对刚体应用软体碰撞产生的力（或冲量）。</li>
<li>迭代求解约束（如 LCP 或 PBD 步骤）。</li>
</ol>
<hr />
<h3 id="4-关键参数与调优"><a class="header" href="#4-关键参数与调优">4. <strong>关键参数与调优</strong></a></h3>
<ul>
<li><strong>软体顶点质量</strong>：影响惯性响应。</li>
<li><strong>弹簧刚度</strong>：控制形变程度。</li>
<li><strong>阻尼</strong>：减少振荡。</li>
<li><strong>碰撞余量（margin）</strong>：防止穿透。</li>
<li><strong>迭代次数</strong>：越多越稳定，但性能越低。</li>
</ul>
<hr />
<h3 id="5-示例代码片段"><a class="header" href="#5-示例代码片段">5. <strong>示例代码片段</strong></a></h3>
<pre><code class="language-cpp">// 创建软体（如布料的网格）
btSoftBody* cloth = btSoftBodyHelpers::CreatePatch(
    worldInfo, corner1, corner2, resolutionX, resolutionY, 0, true);

// 设置软体物理参数
cloth-&gt;m_cfg.kDP = 0.01; // 阻尼
cloth-&gt;m_cfg.kDF = 0.5;  // 摩擦
cloth-&gt;m_cfg.collisions |= btSoftBody::fCollision::SDF_RD; // 启用与刚体碰撞

// 将软体固定在某个位置（如悬挂布料）
cloth-&gt;appendAnchor(0, rigidBodyAnchor); // 将顶点0锚定到刚体
</code></pre>
<hr />
<h3 id="6-注意事项"><a class="header" href="#6-注意事项">6. <strong>注意事项</strong></a></h3>
<ul>
<li><strong>性能开销</strong>：软体-刚体交互计算量大，需控制网格分辨率。</li>
<li><strong>稳定性</strong>：软体易振荡，需适当调整阻尼和迭代次数。</li>
<li><strong>穿透问题</strong>：复杂形状可能需要更小的步长或 CCD（连续碰撞检测）。</li>
</ul>
<hr />
<h3 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h3>
<ul>
<li><strong>Bullet 源码</strong>：<code>btSoftRigidDynamicsWorld.cpp</code>、<code>btSoftBody.cpp</code>。</li>
<li><strong>官方示例</strong>：<code>SoftDemo</code>（位于 Bullet 的示例目录）。</li>
<li><strong>论文</strong>：《Soft Body Dynamics in Bullet Physics》（Erwin Coumans，Bullet 作者）。</li>
</ul>
<p>通过以上机制，Bullet3 能够实现逼真的刚软交互（如布料落在刚体上、软球撞击墙壁等）。</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P41</p>
<h1 id="相交解除-intersection-elimination"><a class="header" href="#相交解除-intersection-elimination">相交解除 Intersection Elimination</a></h1>
<p>P42</p>
<h2 id="对于有体积的物体"><a class="header" href="#对于有体积的物体">对于有体积的物体</a></h2>
<p>Eliminating cloth-volume and volume-volume intersections is straightforward: simply pushing vertices/edges in the volume out.</p>
<p><img src="./assets/09-32.png" alt="" /></p>
<p>P43</p>
<h2 id="对于没有体积的物体untangling-cloth问题"><a class="header" href="#对于没有体积的物体untangling-cloth问题">对于没有体积的物体，Untangling Cloth问题</a></h2>
<p>The situation is complicated in cloth-cloth intersection, since we don’t have a clear definition of inside and outside.</p>
<blockquote>
<p>✅ P42适用于有体积的物体，但布没有封闭体积，两根线没有里面外面之分，因此相交时不知道哪一段是正确的。</p>
</blockquote>
<h2 id="方法一-1"><a class="header" href="#方法一-1">方法一</a></h2>
<blockquote>
<p>✅ 方法：对布分段，根据分段区域决定谁在上谁在下，以此为依据推动顶点。</p>
</blockquote>
<h3 id="算法过程-1"><a class="header" href="#算法过程-1">算法过程</a></h3>
<p>Baraff et al. used flood-fill to segment cloth into regions and decided which region is in intersection. (<strong>Cannot handle boundary well</strong>.)</p>
<p><img src="./assets/09-33.png" alt="" /></p>
<p>Baraff et al. 2003. Untangling Cloth. TOG (SIGGRAPH)</p>
<p>P44</p>
<h3 id="算法效果"><a class="header" href="#算法效果">算法效果</a></h3>
<p><img src="./assets/09-34-1.png" alt="" /></p>
<blockquote>
<p>✅缺点：1. 难以处理边界；2. 对整个面进行评估，难以用于GPU.</p>
</blockquote>
<p>P45</p>
<h2 id="方法二-1"><a class="header" href="#方法二-1">方法二</a></h2>
<p>Volino and Magnenat-Thalmann proposed to untangle cloth by reducing the
intersection contour.<br />
Their method can handle boundaries, but it doesn’t always work.</p>
<p><img src="./assets/09-35.png" alt="" /></p>
<blockquote>
<p>✅ 两个面相交会产生一条曲线，目标是让曲线变短。优点：可以处理边界；缺点：基于局部优化、可用于 GPU。<br />
✅ 可以处理边界情况，缩短边界也能解除相交。</p>
</blockquote>
<p>P46</p>
<h3 id="after-class-reading-12"><a class="header" href="#after-class-reading-12">After-Class Reading</a></h3>
<p>Volino and Magnenat-Thalmann et al. 2006. <em>Resolving
Surface Collisions through Intersection Contour
Minimization</em>. TOG (SIGGRAPH).</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p>P26</p>
<h2 id="two-way-coupling"><a class="header" href="#two-way-coupling">Two-Way Coupling</a></h2>
<blockquote>
<p>✅ 水和水中的物体相互作用，物体可以是刚体、弹性体能各种类型的物体。</p>
</blockquote>
<p>The coupling between a solid and a liquid should be two-way, i.e., liquid-&gt;solid and solid-&gt;liquid.</p>
<p><img src="./assets/10-20.png" alt="" /></p>
<blockquote>
<p>✅ 水 → 物体：浮力。物体 → 水，会把这个水柱的水排出去，此处只讲 “物体 → 水” 部分</p>
</blockquote>
<p>P27</p>
<h2 id="关键问题"><a class="header" href="#关键问题">关键问题</a></h2>
<p>The coupling between solid and water should be two-way, i.e., water&gt;solid and solid- &gt;water.</p>
<p>The key question is how to expel water out of the gray cell regions???</p>
<p><img src="./assets/10-21.png" alt="" /></p>
<p>P28</p>
<h2 id="virtual-height"><a class="header" href="#virtual-height">Virtual Height</a></h2>
<blockquote>
<p>✅ 在要排的水柱上面增加一个虚拟的高度，然后正常模拟，关键是求出要加多少虚拟高度，能正好达到排出那么多水的效果。</p>
</blockquote>
<p>The idea is to set up a virtual height \(v_i\), so that  \(ℎ_i^\text{real_new}=ℎ_i−e_i\).</p>
<p>$$
ℎ_i−e_i=ℎ_i+β(ℎ_i−ℎ_i^{old})+α(v_{i+1}+ℎ_{i+1}+ℎ_{i−1}−2v_i−2{ℎ_i})=ℎ_i^{new}+α(v_{i+1}−2v_i)
$$</p>
<blockquote>
<p>✅ \(ℎ_i^\text{real_new}=ℎ_i−e_i\)：下图左边格子的理想高度。</p>
</blockquote>
<p>$$
ℎ_{i+1}−e_{i+1}=ℎ_{i+1}+β(ℎ_{i+1}−ℎ_{i+1}^{old})+α(ℎ_{i+2}+v_i+ℎ_i−2v_{i+1}−2ℎ_{i+1})=ℎ_{i+1}^{new}+α(v_i−2v_{i+1})
$$</p>
<blockquote>
<p>✅ 公式2对应右边格子。</p>
</blockquote>
<p><img src="./assets/10-22.png" alt="" /></p>
<p>P29</p>
<h2 id="poissons-equation"><a class="header" href="#poissons-equation">Poisson’s Equation</a></h2>
<p>The outcome is Poisson’s equation, with \(v_i\) and \(v_{i+1}\) being unknowns.</p>
<p>$$
2v_i−v_{i+1}=\frac{1}{α}(ℎ_i^{new}−ℎ_i+e_i)=b_i
$$</p>
<p>$$
−v_i+2v_{i+1}=\frac{1}{α}(ℎ_{i+1}^{new}−ℎ_{i+1}+e_{i+1})=b_{i+1}
$$</p>
<blockquote>
<p>✅ 通过公式化简提取出其中的线性关系。</p>
</blockquote>
<p>P30</p>
<p>The outcome is Poisson’s equation, with \(v_i\) and \(v_{i+1}\) being unknowns.</p>
<p><img src="./assets/10-24-1.png" alt="" /></p>
<blockquote>
<p>✅ 由于木块位置会变，需要解的\(v_i\)也要改变。 为了让公式统一方便计算，把图左矩阵乘法写成右边形式。公式结果不变，只是工程实现上的简化。</p>
</blockquote>
<p>P31</p>
<h2 id="algorithm-with-coupling"><a class="header" href="#algorithm-with-coupling">Algorithm with Coupling</a></h2>
<p><img src="./assets/10-25.png" alt="" /></p>
<blockquote>
<p>✅ \(\gamma \) 的作用：本算法显式积分，不稳定、\(\gamma \) 会让水波小很多。</p>
</blockquote>
<p>P32</p>
<h2 id="rigid-body-update"><a class="header" href="#rigid-body-update">Rigid Body Update</a></h2>
<p>We estimate the floating force by the actual water expelled in every column.</p>
<p><img src="./assets/10-26.png" alt="" /></p>
<p>$$
f_i=ρg∆x(ℎ_i−ℎ_i^{new})
$$</p>
<p>Or in 3D,</p>
<p>$$
f_{i,j}=ρg∆A(ℎ_{i,j}−ℎ_{i,j}^{new})
$$</p>
<blockquote>
<p>✅ 阿基米得定律：物体受到的浮力 = 排出去的水的重力<br />
✅ 同时要考虑旋转和力矩。但目前旋转的效果不太好，可以考虑改进为隐式积分。<br />
✅ 流体对方块的效果。</p>
</blockquote>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="刚体--sph"><a class="header" href="#刚体--sph">刚体 + SPH</a></h1>
<p>Lecture 2 [1:12:26]</p>
<p>强耦合：两个系统联立求解<br />
弱耦合：两个系统独立求解，或先解一个，然后作为条件解另一个</p>
<hr />
<blockquote>
<p>本文出自CaterpillarStudyGroup，转载请注明出处。</p>
<p>https://caterpillarstudygroup.github.io/GAMES103_mdbook/</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/pagetoc.js"></script>
        <script type="text/javascript" src="theme/mermaid.min.js"></script>
        <script type="text/javascript" src="theme/mermaid-init.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
